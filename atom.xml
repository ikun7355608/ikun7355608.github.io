<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>残局</title>
  
  <subtitle>没有故事，不会喝酒。</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-08-14T15:01:00.939Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>某卑微社畜</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>20230812</title>
    <link href="http://example.com/20230812/"/>
    <id>http://example.com/20230812/</id>
    <published>2023-08-14T14:23:05.000Z</published>
    <updated>2023-08-14T15:01:00.939Z</updated>
    
    <content type="html"><![CDATA[<p>这是关于一个学妹的故事，暂且不知道该叫什么名字。就以想写这个故事的时间命名吧。</p><span id="more"></span><p>这个学妹比我小两届，从老乡群里认识的。和她主要的交集大概有两次吧，一次是去年暑假在北京实习时候，我是夜班每天要奋战到早晨八点半，而她要早起五点多坐公交去市区家教，那段时间基本上每天清晨会找我聊天。再有就是今年四五月份时候，她失恋了要找我出去喝酒，找了好多次都被我拒绝了。（我觉得和她并不是很熟不清楚为什么是我，就没去）除此之外也就水群时候可能混个脸熟，就基本没什么交集。自认为和她关系一般。</p><p>周六下午时候她和我说她父亲车祸追尾别人去世了。当时的我并不知道她和我说这件事是什么目的，不清楚是因为无助找个朋友倾诉、陪伴，还是通知一下让我随礼，而这种事情我又没办法问只能靠自己猜测。看到她的消息，思想斗争了一段时间。因为我自认为和她关系蛮一般的，刚开始的时候更倾向于是让我随礼，毕竟没什么交集顶多算作认识；但仔细想想，倘若我俩的关系真像我以为的那样，她也没必要单独通知我。最终，我更倾向于她拿我当朋友，回想起之前她失恋找我喝酒我拒绝了之后，还吐槽过她是不是没有朋友怎么会来找我（当时自认为关系一般）、而且当时我怕她对我有什么特殊想法，回她的消息里也充满了轻视。（她说她的情感问题，我说我的「速十」）回想起来感觉挺内疚的，再加上这件事本身就很让人心疼、怜悯。在这些情感的作用下，给她转了一千块。这个钱放在我家那边是非常多的，我家那边正常的丧事关系还不错的随200、特别特别好的随500，基本都见不到1000。这个钱更多的是出于我的愧疚吧。</p><p>其实周日的时候就想写这件事，但是想了想还是算了。毕竟我也分不清是我自作多情还是确实如此。直到今天下午，有一个学长问我她和我说过这件事没。据了解，她好像只告诉了5个人（看起来我上面的推断还是有些正确的，但也蛮愧疚的）。学长问我既然她说了这件事，问我要不要跟他们一起随礼。我问了下随多少，他说他们打算到现场看一下她家那边普遍随多少，然后我们随一半。也挺讽刺的，就又决定写了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是关于一个学妹的故事，暂且不知道该叫什么名字。就以想写这个故事的时间命名吧。&lt;/p&gt;</summary>
    
    
    
    
    <category term="日常" scheme="http://example.com/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>梦(监狱)</title>
    <link href="http://example.com/%E6%A2%A6-%E7%9B%91%E7%8B%B1/"/>
    <id>http://example.com/%E6%A2%A6-%E7%9B%91%E7%8B%B1/</id>
    <published>2023-08-02T13:39:28.000Z</published>
    <updated>2023-08-02T14:02:19.728Z</updated>
    
    <content type="html"><![CDATA[<p>今早六点多起来拉屎，拉完回去又睡了一会儿，期间做了个梦。</p><span id="more"></span><p><img src="/%E6%A2%A6-%E7%9B%91%E7%8B%B1/pic.png" alt="pic"></p><p>这是梦里的场景构造，然后前面的黑色方块是一个大楼（具体干什么用的不清楚），然后后面蓝色的是监狱的牢房（类似于一堆小宿舍），牢房里面是上下铺（我在上铺），出牢房之后只能通过两个红色的门出去。两个红色的门有狱警看守。</p><p>我在床上躺着，看起来好像是生病了。然后来了5个人（4男1女，其中一对情侣）看我，寒暄了几句之后他们几个人就要走了，快出门口的时候那个女生拿了许多零食回来说是要给我点吃的，然后他们几个人就走了。那个女生把零食丢给我之后，试图爬到床上来（感觉要发生付费才能看的情节）。爬到一半的时候，我的两个狱友从窗户上翻了进来，然后女生看到了就没再往上爬，羞着脸下去之后就出去了。我的两个狱友和我说了几句话就往后面的牢房里去了（不晓得去干啥）。</p><p>狱友刚离开，进来了一个像是管理者的人，他质问我说为什么还在床上，今天有个活动要强制参加（好像是要听某个讲座）。然后我说我不知道这件事，他就把我赶下了床，让我快点去参加。我下床穿好衣服出去准备参加活动，刚走出房间来到院子里（上图中间空余的那片区域、与三个颜色相邻的那块）看到了刚刚来房间里看我的女生，她问我怎么下床了要去干嘛。我说去参加那个活动，然后她嘲讽我说刚刚不是说不去了吗，怎么又怂了。然后她说要和我一起去参加那个活动。</p><p>我们两个刚要从左边红色区域的那个门走出去，这个时候有一个骑着摩托的女狱警来了。狱警让保安把门锁上，然后说要查人没去参加活动的要受到很严厉的惩罚。狱警把我们两个骂了半天，说了一堆类似于表现恶劣要加刑之类的话。然后这个女生好像犯事太多了濒临一个特别严厉惩罚的点，听完这话之后整个人就蔫了，给人一种失魂落魄的感觉。一遍低着头往前走一遍自言自语。然后走了一会儿，她似乎想到了什么好点子，人看起来也有些兴奋。然后她和我一起转身往回走（女狱警的方向），然后就在快要走到女狱警身边的时候，她突然抬起头，露出了一种特别诡异的笑容。然后，就在她抬着头露着诡异笑容，似乎要袭击女警的那一刻，我醒了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今早六点多起来拉屎，拉完回去又睡了一会儿，期间做了个梦。&lt;/p&gt;</summary>
    
    
    
    
    <category term="日常" scheme="http://example.com/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>租房</title>
    <link href="http://example.com/%E7%A7%9F%E6%88%BF/"/>
    <id>http://example.com/%E7%A7%9F%E6%88%BF/</id>
    <published>2023-07-30T13:41:56.000Z</published>
    <updated>2023-07-30T14:11:38.425Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下这两天的租房经历</p><span id="more"></span><p>距离公司大概三公里的地方有个小区，2、3居室的房大概整租2800-3500左右，然后由于我觉得合租限制比较多，不太自由。再加上本来预期的工作地是北京，东莞这消费水平远低于我的预期，哪怕商水商电也远低于我预期的开销，然后就在附近这一大堆的农村自建房中找了找。</p><p>这些房子大概分为两部分：上面提到的那个小区后面以及公司马路对面人才房后面。由于我周五下午五点培训结束、周六上午八点半就要到组里报道；我周五就打车到人才房附近找了个民宿住了下来，然后逛了逛附近的自建房。就是走到每个自建房的门口问前台或者直接打上面挂着的电话，有一些是直接告诉我哪些房是空着的让我自己上去看，还有一些是带着我进去看。逛了一圈发现这附近普遍是商水商电、50网费，不同的就是室内的空间布局、大小、环境可能不太一样。有些在建筑工地（看样子也是在盖这种自建房）旁的房就直接没看（觉得太吵）。这一圈转下来发现这些门口的电话要么就是中介，要么就是本地房东（显著特点：他会告诉你他在这附近哪里哪里还有要不要过去看看，以及你打电话问的时候他问你是附近的哪一栋他这就过来）</p><p>本来打算周五晚上找几个备选项，要是没有太满意的就周日去那个距离三公里左右的小区附近找，但在最后的时候一个房东大哥让我觉得人不错（当然房子也还不错），最终就在今天上午租了他的房子。事情是这样的，最开始我打电话的那栋就只剩一个几乎没采光的房间了，大哥说旁边不远处还有他的另一个问我要不要去看看，他骑着小电摩载我过去的路上我问他电动车牌照是不是很难上，大哥说不麻烦，正常自己去上的话大概七八十，要是嫌麻烦可以给他二百块钱他直接帮我搞定。然后还告诉我了具体上牌照需要的手续：房东身份证复印件、合同复印件、房产证复印件……我觉得大哥能够告诉我正常价位以及相关手续觉得大哥人应该不会太过于奸诈，最终就租了大哥载我去看的那个房子。</p><p>我租的这个小房子长这样：<a href="https://v.douyin.com/iET799V/">视频链接</a>。今天斥巨资（一千三百多）购买了一大堆生活用品，等我装饰好了再给你们看！</p><p>话说，感觉这个过程有点过于顺利了，总感觉会有坑。不过我觉得就算我深思熟虑之后做出决定，有些坑还是避免不了：比如电器损坏就说是你的责任房东不给修，没空调用的人是你，你也耗不起；再比如退房的时候就是不给你退押金，你也没那个精力和他耗（因为钱并不多，但是选择退房多半是要走了之类的，没时间和他耗下去）。</p><p>明天正式开始打工生活咯，晚安。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录一下这两天的租房经历&lt;/p&gt;</summary>
    
    
    
    
    <category term="社畜养成计划" scheme="http://example.com/tags/%E7%A4%BE%E7%95%9C%E5%85%BB%E6%88%90%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>今日份无语</title>
    <link href="http://example.com/%E4%BB%8A%E6%97%A5%E4%BB%BD%E6%97%A0%E8%AF%AD/"/>
    <id>http://example.com/%E4%BB%8A%E6%97%A5%E4%BB%BD%E6%97%A0%E8%AF%AD/</id>
    <published>2023-07-26T14:26:52.000Z</published>
    <updated>2023-07-26T14:40:55.348Z</updated>
    
    <content type="html"><![CDATA[<p>吐槽一下今天培训时组里的一个同事</p><span id="more"></span><p>故事背景：</p><ul><li>组里有个特别活跃的女生，昨天下午开始就蔫了。（看起来像痛经之类的）</li></ul><p>今天下午有室外的环节，去的时候我背起了我的书包。然后进行到一半的时候突然下起了雨，越下越大。</p><p>刚开始我自己打着伞站在一旁玩，然后发现了那个女生没有伞，就把伞借给她了。然后她有些不好意思就要一起打这个伞，但我的伞特别小就把伞留给她，我自己去一旁玩耍了。然后过了一会儿发现他（要吐槽的人）钻进了伞里。雨越下越大，那个女生好像是看到了她的舍友之类的（一个有伞的女生），然后她就去找她朋友了。雨太大了原地解散了，那个男生就自己打着我的伞走了（每个组都在一起，他是看到我拿出伞、知道伞是我的的），然后我淋着雨走到食堂（比较远，湿透了），排队买饭排了一会儿收到了他的微信，他告诉我伞在他那里。真的好气！！！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;吐槽一下今天培训时组里的一个同事&lt;/p&gt;</summary>
    
    
    
    
    <category term="日常" scheme="http://example.com/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>粤漂第一天</title>
    <link href="http://example.com/%E7%B2%A4%E6%BC%82%E7%AC%AC%E4%B8%80%E5%A4%A9/"/>
    <id>http://example.com/%E7%B2%A4%E6%BC%82%E7%AC%AC%E4%B8%80%E5%A4%A9/</id>
    <published>2023-07-23T12:16:40.000Z</published>
    <updated>2023-07-23T12:47:14.556Z</updated>
    
    <content type="html"><![CDATA[<p>昨天踏上了前往广东的路，正式开启粤漂生活。</p><span id="more"></span><p>前往东莞这一路上我所乘坐过的交通工具几乎都坐了一遍：<strong>开车</strong>前往家附近的公交站牌、坐<strong>公交</strong>前往当地的高铁站、<strong>高铁</strong>前往北京、<strong>地铁</strong>前往机场、<strong>飞机</strong>飞往深圳、<strong>打车</strong>到东莞。</p><p>早晨七点多从家出发，到东莞已经是夜里十一点多。虽然一路上睡了很多次，但每次都没有睡太沉，几乎和没睡着一样。累到直接睡到今天上午十点多，今天中午又睡了两个小时。</p><p>东莞这边的气温比我家那边还低不少，但给我的感觉是更热。在家四十度的中午坐在院子里的太阳下抽烟虽然很热但也只是单纯的觉得热、今天中午和晚上去食堂吃饭回来（大概二十几分钟的路程）全身都是汗，衣服也一股酸臭味。这里给我一种闷热的感觉。而且这边的天气很善变（也许只是今天这样），我吃完晚饭想着在园区内逛一逛，半个多小时下了两次雨。</p><p>明天就开始正式的打工生活了。不对，培训又不需要我做什么东西，也不算正式的打工生活。但确实是可以拿工资的日子了。祝你也祝我，前程似锦。</p><p>还有就是，这是今天吃完饭拍的园区内图书馆的照片。</p><p><img src="/%E7%B2%A4%E6%BC%82%E7%AC%AC%E4%B8%80%E5%A4%A9/pic.jpg" alt="pic"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;昨天踏上了前往广东的路，正式开启粤漂生活。&lt;/p&gt;</summary>
    
    
    
    
    <category term="社畜养成计划" scheme="http://example.com/tags/%E7%A4%BE%E7%95%9C%E5%85%BB%E6%88%90%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>故友重逢</title>
    <link href="http://example.com/%E6%95%85%E5%8F%8B%E9%87%8D%E9%80%A2/"/>
    <id>http://example.com/%E6%95%85%E5%8F%8B%E9%87%8D%E9%80%A2/</id>
    <published>2023-07-07T09:44:58.000Z</published>
    <updated>2023-07-23T12:55:18.367Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个高中时非常非常好的朋友，直到我大学毕业才再次见面。</p><span id="more"></span><p>下面的内容写的有点乱，先梳理一下时间线：看电影 –&gt; 吃饭 –&gt; 画画。</p><p>我是那种对食物接受程度很高的人，基本上没有什么是不喜欢吃或者忌口的。在和别人（包括家人）吃饭时点菜就很随意，无需在意我的喜好，点什么我都能吃很多那种。我不喜欢吃鱼，除了烧烤、油炸其他的各种做法的任何鱼都不吃那种，而我的父母又是非常爱吃鱼的，在家里他们要吃鱼时，我都能够包容到馒头蘸鱼汤吃。久而久之也都没人会在意我的喜好。但是和她一起吃饭就非常照顾我的感受，每一种菜放在什么锅底里都要问一下我，再加上点菜时候她要点的每种都问一下我喜不喜欢吃、每次菜熟了第一筷子都夹给我，和她相处让我有一种被别人关心、非常非常舒服的感觉，很喜欢和她待在一起。她还买好了奶茶、薯条、排骨带我去看电影、骑着小电驴去兜风。这是最后一起画的肌理画。</p><p><img src="/%E6%95%85%E5%8F%8B%E9%87%8D%E9%80%A2/pic.jpg" alt="pic"></p><p>还有就是，今天开始不再是只喝过蜜雪冰城、没吃过海底捞的人了！！！</p><h2 id="续"><a href="#续" class="headerlink" title="续"></a>续</h2><p>前往东莞的前一天家里下着特别大的雨，但这并没有阻止我们再见她一面。今天踩坑了肉蟹煲、电玩城玩了一会儿、看了个电影。还有就是今天也不再是一个连小姑娘的手都没摸过的人了，已经摸过了！虽然只有几十秒没有什么感觉、虽然我不要脸的想多牵一会儿被拒绝了，但是也非常开心！！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是一个高中时非常非常好的朋友，直到我大学毕业才再次见面。&lt;/p&gt;</summary>
    
    
    
    
    <category term="日常" scheme="http://example.com/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>我的大学</title>
    <link href="http://example.com/%E6%88%91%E7%9A%84%E5%A4%A7%E5%AD%A6/"/>
    <id>http://example.com/%E6%88%91%E7%9A%84%E5%A4%A7%E5%AD%A6/</id>
    <published>2023-06-26T07:44:31.000Z</published>
    <updated>2023-07-08T02:16:43.147Z</updated>
    
    <content type="html"><![CDATA[<p>谨以此文纪念我的大学时光</p><span id="more"></span><h2 id="生涯规划"><a href="#生涯规划" class="headerlink" title="生涯规划"></a>生涯规划</h2><p>步入大学没有了之前那种固定的长远目标，似乎未来充满着无限可能，却又无从下手。刚入学的时候，对自己的未来还没有任何规划，但学校里的人、事都在烘托着一种「读研是大学的最好出路」的氛围：保研名校的学长学姐系列讲座；升学率宣传；同学、家长的学历崇拜……似乎大学和之前的阶段一样，目的是拿到下一阶段的入场券。刚入学时，每天都能听到学长学姐的保研、考研、求职的光辉事迹，但其实只是当个故事听，也并没有考虑过将来自己想做什么。刚摆脱高中那种压抑的环境（每天12点睡5点起，还因为午休时间午睡被请过家长），每天都在报复性的玩乐。教务处排课会避开周三下午，每周三下午我都能狂睡3、4个小时。</p><p>开学不久认识了两个学长，也是整个大一关系比较好的唯一的两个。A学长当时大四，他从大二开始就以实验室为家，寒暑假也要泡在实验室里做实验（甚至有一年过年都没回），最终成功保研；B学长当时研一，大学吃喝玩乐三年多，最后考研上岸。我每天接受的熏陶也都是要好好学习，准备考研。这时我的大学目标是<strong>保研</strong>。为了这个目标，大一上学期非常刻苦的学习了一学期。秋季学期结束后，排名大概在20%左右，基本上这样持续下去的话，也能够达到保研的要求。大一下学期疫情爆发，在家里上了一学期的网课，也是这个信念支撑这我每天认真学习。快期末的时候，学校的老师似乎清楚线上教学的问题，许多课程的考核标准降低了很多，这让基础相对比较扎实的我许多课程都取得了相对不错的成绩，排名一路冲到了前5%。大一结束学院进行专业分流，当时学的是机械，唯一的一门专业课是工图（我四年分最低的几门课之一），学不会工图的我对这个学院的专业产生畏惧，觉得自己学不会这个方向。于是，选择了转专业。当时互联网行业很热门，于是选择了软件学院，但是我的排名只是刚触碰到转专业的底线，又怕自己被刷下去被迫留在原学院。于是选择了软件学院的一个冷门的专业——信息安全。</p><p>刚转过去的时候，看到了新的专业排名——50%。此时的我每天都很焦虑，因为我很难再触碰到那个保研的最低排名要求（本身并没有相关基础，而且和要求存在较大差距）。虽然很焦虑但生活还要继续，学习时间更长了，每天都憋在图书馆里学习。这样持续了一年后，排名也并没有提高多少。而且这期间目睹了很多同学混分的事（因为更多的考核是实验，很多排名靠前的实验直接用学长学姐的，然后写一篇特别优质的实验报告），我付出的比他们要多很多，得到的却无法与之比拟。</p><p>大三上学期，虽然大二发生的事动摇了我保研的决心，但我的目标还是读研。因为目标变成了<strong>考研</strong>，不必再在意那些课程的成绩。这也使得我的生活丰富了许多，每天读书、看电影、打游戏（因为疫情封校只能在校园里活动）非常快乐。那段时光是我勉强能算得上真正意义上的大学时光的几个月。</p><p>大三上学期末的时候，开始真正的审视自己的未来问题（以前只是一个思想的萌芽并不清楚为什么要读研，只是大家都在做这件事），这次是真正的思考这个问题：我为什么要读研？思考了好久，发现我只是个俗人，我的目标只有金钱。像什么学术追求、职业方向、技术追求统统没有，<strong>我只在乎钱</strong>，给我一万五的月薪让我扫垃圾我都能干一辈子。想了一下，就算读研出来刚入职时月薪高3k，这三年的差价也很难在三五年内持平，更何况我三年也未必没有涨薪。这时就正式的放弃了读研的想法。此时只想着「打工不仅能致富，还能交友娶媳妇」。调研了一下网络安全行业，发现网安的待遇比起开发要低很多，于是目标就定为了开发岗。这一年半来接触过的也就只有C++，觉得这个还略微有点基础就开始准备C++相关的知识。</p><p>在大三下学期开学前以及大三下前两个月这段时间里都在准备C++后端所需要的知识：C++2.0、算法、网络、操作系统。当时的我觉得自己也就算半个科班（只学过计算机基础课），基础还不是很扎实，能进互联网大厂的唯一机会也就是实习转正。因而在3、4月份开始投实习时就没有投过非互联网行业的开发岗和互联网小厂。可惜心比天高，命比纸薄。最终并没有找到一份互联网大厂C++开发相关的实习，选择了去网安行业一探究竟。实习了一段时间，网安行业也成功的让我觉得当初选择走开发岗是正确的。</p><p>实习结束之后，8月份开始秋招。秋招了大概3个月，结果还算满意。（最近看到了学院的就业数据，对自己更加满意了。）</p><p>现阶段的生涯规划——活过试用期。</p><h2 id="情感"><a href="#情感" class="headerlink" title="情感"></a>情感</h2><p>本来是没打算写的，但是总觉得不写内容不够充实。（毕竟学习和谈恋爱是大学的两大主线任务）</p><p>我本身是一个思想很黑暗的人，就是所有的事情都做很坏（但不至于是最坏）的打算，对任何事情都不抱有多大期望。因而在很多事情发生时并不会有多伤心难过，相反很容易被一些小细节感动。这样的思想使得我并不缺少情感上的依赖（准确点说，是不需要）。爱情方面我总持有一个观点：「如果某天我谈恋爱了，绝对是因为性、因为我馋她身子，不会是因为爱」。然而我的良知又告诉：「即使给不了别人未来也要对别人负责。也许人家小姑娘不介意，但我介意。我怕我的行为导致她将来被男朋友嫌弃。」我知道这样的想法很天真、很傻逼，但是我做不到对明知给不了她未来的女生动手动脚。这样的想法就让我成功的单了四年，有些暧昧的苗头也都被我浇灭了。</p><p>有人喜欢过我吗？也许有但我也没感受到过，那就当没有吧。可是我真的好想体验一下被人爱着的感觉。</p><p>有过喜欢的人吗？还真有过一个，可惜尝试了一年多还没有结果，短时间内也不会有结果。反正我的人生里充满着遗憾和笑话，没和大学喜欢的人在一起过又算什么呢，错过就错过吧，至少还有一些美好的回忆。估计在她眼里我们之间的关系只能止步于友情了，再坚持一段时间没结果就要放弃咯。不过还好她对我还是比较好的嘞（至少对我来说别人身上没有这种感觉）</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>真正意义上的大学时光只有一年半——疫情开始前的大一上、备案进出校的大二下、彻底放开的大四下。</p><p>大一上生活比较充实，平时参加一些文体活动，学累了就到处走走顺便买些零食、水果。这段时间虽然没有太多朋友，但是每天都和那为数不多的几个朋友在一起玩耍，关系维持的也都很好。这期间虽然有着保研的想法，但相对而言有难度的课程也比较少，平时大部分的时间都还是属于自己的。不过当时的思想并没有完全的从高中那个环境中脱离，活动的范围也只限于学校周边，并没有什么太多的娱乐活动。</p><p>大二下虽然是备案制可以较为随意的进出校，但是当时的心思都在为保研做准备上。再加上这一学期开了数据结构、操作系统、数据库、数学建模、密码学等太多的硬核专业课，这学期的大部分时光是泡在图书馆里，并没有太多的娱乐活动。偶尔出校几次，也只是吃个饭便回来，仅此而已。</p><p>大四下彻底放开之后的生活相对自由。大四下分为两个阶段，第一个阶段是毕设还没正式开始做毕设阶段，这期间组会大概在每周五进行，开完组会到下个周二的时光每天都泡在图书馆里看自己喜欢的书籍（大学第一次见图书馆，很享受这种随便翻阅的感觉），然后周三周四完成一下相应的任务。虽然每周都在做毕设相关的工作，但这些工作都没什么价值，更准确点描述是在探索毕设的可能。大概在四月底到五月中旬疯狂的写毕设，每天都会写到精神涣散，怀疑人生。第二阶段是从五月中旬到离校前，这一个月左右的时间是我大学最快乐的时光，这期间没有了那种无用的社交，抽空便和好朋友到处玩耍，探索未知领域以及新店铺，每天都很快乐很充实。</p><p>其实，封校与否并不是限制我生活的因素。因为我本身并没有什么兴趣爱好，唯一喜欢点的就是看书和看电影，这些并不会因为出不了学校而被限制。而且我生活费很少，也支撑不起我出去吃喝玩乐。基本上每周都会看1~2部电影或电视剧，积累了一定的观影量。</p><p>旅游一次都没有，哪怕是毕业旅行也没有；奶茶之类的只喝过蜜雪冰城（如果它算得上的话）；肯德基在实习的时候有幸吃过一次（吃住报销，奢侈了一把）；电子设备除了轻薄本+手机也没有其他的；海底捞之类的各种火锅也都没吃过（只有自己吃火锅时买过海底捞底料吃）……还有好多好多对同龄人很普通的东西都没有体验过。不过在做完毕设到我离校前的那段时间和喜欢的女孩一起玩了好多天，去逛了好多地方，但还是比较幸福的。</p><p>不过值得高兴的是大概有4、5个好朋友，虽然好像对他们大部分来说我的存在并不是完全必要的，但是至少这段关系在我毕业时还是维持的较好的，已经很棒啦。</p><h2 id="记忆碎片"><a href="#记忆碎片" class="headerlink" title="记忆碎片"></a>记忆碎片</h2><p>这部分主要是大学里一些记忆深刻的事。</p><h3 id="军训"><a href="#军训" class="headerlink" title="军训"></a>军训</h3><p>我就是一个土狗，上大学以前连我所在的城市的市区都没去过几次。军训这段时间是我刚来到这座城市、这个学校的时候，一切都充满着未知。这期间的我觉得导员、教官说的话是不可撼动的权威（类似高中反驳老师一句就要被叫家长那种），每天的自由活动期间就自己坐在操场上发呆（不让带手机、不让脱离队伍）。这期间的各种活动非必要不参加，即使是强制参加的那种表现的也像个自闭少年一样。</p><p>有一天依旧像往常一样坐在人群的角落里发呆，这时教官注意到我给我一顿交流+开导。当然，这并没有对我有什么实质的影响，但这件事一直停留在我的记忆里。</p><h3 id="思修最后一课"><a href="#思修最后一课" class="headerlink" title="思修最后一课"></a>思修最后一课</h3><p>大一上学期思修最后一堂课上有一个可以向老师提建议的反馈环节，这种东西放在我过去十几年的学习生涯中无异于走个过场。如果有人真的提出意见，老师不仅不会听取你的意见，还会因此对你存在偏见，无异于钓鱼执法。</p><p>估计大家对这个环节的看法和我的雷同，老师一遍又一遍的重复这个话题也没有人提出意见。过了许久，有一个老哥站起来说了这个事情，然后说他也不怕真受到什么影响就说了相关的建议。（后来了解到这个老哥高中辍学后一直在当围棋老师，段位打不上去了之后复读来上大学的）老师说「大家大可放心，因为政治相关的课程都是轮讲的（每个老师在某个教学班只会上2次课），根本认不清人。虽然她是我们班的负责教师，她也只给我们上学期初和学期末的两堂课，根本认不清任何一个人，而且后续都不会再有什么交集。」老师说完后有许多同学开始发言支持相关的问题和建议，这让我深刻认识到原来大学真的和前面任一阶段都不一样。</p><h3 id="化学老师"><a href="#化学老师" class="headerlink" title="化学老师"></a>化学老师</h3><p>「大学化学」同样是大一上学期的一门课，这门课的期末考试不是在期末考试周，而是在课程结束后一周。在期末考试前的几天，学艺不精的我每天拼命复习遇到问题就像高中那样随时去向老师请教，化学老师每次都特别耐心的为我解答相应的问题，而且有几次还是在晚上九点多。其实当时的我觉得这只是一件很普通的事，直到后面的学习生涯中再也没遇到过这种老师（大家的目标只是完成学校要求的教学任务，仅此而已。）。很荣幸当时能够遇到一位这么好的老师。</p><h3 id="大一舍友"><a href="#大一舍友" class="headerlink" title="大一舍友"></a>大一舍友</h3><p>大一有一个舍友每天吃的都比较好，当时只是觉得他家比较有钱一个月给他的生活费比较多而已。有一次期末考试之后（大概下午4点），他觉得考完试该放松一下，直接买了当晚飞北京的机票，第二天去人民大会堂听了一场俄罗斯某个乐队的演唱会后回来。后来得知他母亲是某个私立学校的校长，父亲做啥我忘了反正也非常厉害。这是我第一次见识到那种即使我再怎么努力也达不到他如今生活水平的人，第一次见识到差距之大。（当时的我还没怎么遭受过社会的毒打，还很天真的觉得能够凭一己之力能从大城市定居。）</p><h3 id="转专业第一天"><a href="#转专业第一天" class="headerlink" title="转专业第一天"></a>转专业第一天</h3><p>这天需要我将行李收拾好搬宿舍到另一个校区。将行李搬到新宿舍之后就在收拾东西，一直收拾到下午一两点。大概在中午十一二点的时候，一个并不怎么熟的朋友（之前只见过一两面，也基本没说过话）问我收拾完了吗并给我带了午饭。这对孤独的我来说无疑是最好的礼物，在这之前我几乎都没有体验过被人关心、在意的感觉。</p><h3 id="大二实训"><a href="#大二实训" class="headerlink" title="大二实训"></a>大二实训</h3><p>实训是在Linux下的C/C++开发，当时觉得在Windows上跑Linux虚拟机会浪费资源就安装了双系统。实训一共是10天左右的时间，在第6、7天的时候电脑突然死机了，然后直接强制关机重启。重启后，Linux系统再也进不去了，而且找不到解决方案。奋斗六七天进度回到原点挺崩溃的，不会好在任务量不是很大，安装虚拟机高强度工作了几天足以完成任务。这是大学期间第一次感受到崩溃。</p><p>大二实训期间，隔壁宿舍一个同学让我见识到了人的潜力是无限的。他是那种deadline临近时才开始的人，至今每一次的任务都能按时完成。第8天下午他才开始工作，第9天时发现时间不够用了开始爆肝，第9天直接肝到第10天下午5、6点（中间没睡觉），然后困到不行了睡了大概2、3个小时，继续通宵爆肝，在第11天（答辩当天）下午两点多时完成任务，答辩完回宿舍睡觉。（两天多睡了2小时）这是我第一次见到他的这种操作，后续的每一次都能震撼到我。</p><h3 id="生日礼物"><a href="#生日礼物" class="headerlink" title="生日礼物"></a>生日礼物</h3><p>说起来没人记得我的生日，准确的说可能有些人知道我的生日是哪一天，但并不在意这件事。印象里过去的二十几年中只有高二那年过了一次生日，其他时间也都没真正的过过。（有时会在当天吃面条、有时会在过后某天想起来补一顿美食，没有吃到过生日蛋糕。）</p><p>故事发生在21年，当时肯德基儿童套餐有个很火的可达鸭玩具。那时的我真的很喜欢看那个可达鸭玩具相关的视频，也分享了好多B站上关于这个玩具的视频。等到我过生日的时候（大概4个月后）很意外的收到了一个和肯德基儿童套餐里一样的可达鸭玩具。</p><p>这一年的我非常幸运，有幸过了记忆里的第二次生日。很难相信我能够收到同一个人送的礼物和蛋糕，点支烟当蜡烛过了一个难忘的生日。礼物是一个抱着枪的悍匪小黄鸭，非常喜欢。那天的我非常开心，被人记在心里的感觉真的很舒服。</p><h3 id="注销公众号"><a href="#注销公众号" class="headerlink" title="注销公众号"></a>注销公众号</h3><p>我是一个分享欲特别特别强烈的人，但是遗憾的是没有朋友可以分享。虽然想分享的东西可以写在日记里分享给未来某天看到日记的自己，但我更希望能有一个较短时间内得到反馈的分享者。当时没有人可以分享的我就自己建了个公众号，里面存了好多我平时觉得有意思想要分享的事以及一些自己拍的风景图。公众号大概存在了两年多，里面记录了好多东西。后来啊它就被我注销了，没有读者的公众号和日记又有什么区别呢。</p><h3 id="数学建模"><a href="#数学建模" class="headerlink" title="数学建模"></a>数学建模</h3><p>大三数模课程时的作业是前一年的数模国赛题按照数模要求完成。（限时三天）当时的我和一对情侣组队，前两天我在疯狂的写，并且汇报我的进度，在第二天晚上我问他进度时，他说刚要开始写。更让我无语的是，当我最后一天看到我们队的论文时，论文和我所做的没有任何关系。完全是复制的去年某一篇论文。后面的几次作业都是讲解相关内容，然后修改论文。我们组也都没再改过。</p><p>数模最后一个作业是单人参加省赛（作为课程作业+校赛选拔），同样的三天限时打法。在第二天下午时，我的电脑给了我一个大惊喜——风扇坏了，电脑一直拖拉机一般的声音。无奈之下，借了个电脑从0开始配环境奋斗到早晨四点才得以完成。在自习室睡了会儿，六点左右回宿舍。这是我唯一一次见到清晨的太阳。（其他时间最早也8点起，大部分时间10点左右）</p><h3 id="北京实习"><a href="#北京实习" class="headerlink" title="北京实习"></a>北京实习</h3><p>更准确的说是去HVV现场的第一天。当时场地在北京市中心（2、3环），提前去附近订了个酒店。但订到的是一个特别破旧的民宿，这间民宿的工作人员只有一对老夫妇，这种环境极差且价格也并不便宜。房间没人打扫、床头柜发霉、没有一次性洗漱用品、没有洗衣机、没有一次性的被罩床单等（已经非常的黄了）。</p><p>让我破防的不是民宿的环境，是京爷的素质。我是第一天晚上入住的，第三天去丢垃圾时民宿对面有个大的垃圾桶。然后恰好有两个人在那丢垃圾，我问他们能否把垃圾丢在这里，结果他们直接骂我，然后说这是他家专属的垃圾桶。我拿着垃圾回去问了下工作人员老大娘才顺利的丢掉。然后回到房间躺了一会儿，发现刚来的时候自己手洗的衣服根本干不了已经有霉味了，然后决定换个地方住。老大娘说她不会弄需要老大爷回来弄，老大爷腿疼去药店了。等了大概两个小时老大爷还没回来，问老大娘要了老大爷的电话，老大爷说他出去买菜了一会儿就回来（下午3点）。又等了大概半个小时，老大爷回来了。老大爷刚开始说系统坏了不能办理退房，过了一段时间又说能退了但是要额外扣200的也不什么费。最终在报警威胁下，才能顺利退钱走人。不得不说，京爷就是京爷。</p><p>当然了，除此之外还有一些琐碎的小事：第一次坐火车、第一次坐地铁……</p><h3 id="分享者"><a href="#分享者" class="headerlink" title="分享者"></a>分享者</h3><p>前面提到过我是一个分享欲特别强烈的人，但一直没有可以分享的人。这个人便是我万事可分享且能得到回应的人，无论是一些炸裂、变态的视频还是我的日常。每天不用担心你分享的自己的糗事被别人当成笑话到处讲、不用担心你看到的有意思的事物发给别人之后被当成骚扰看都不看一眼，想说什么说什么、事事有回应，这种感觉很幸福的嘞。其实这个人是我高中时候就特别好的朋友，但中途发生了一些不愉快的事，不过好在又可以继续每天骚扰了嘞。</p><h3 id="2022-10-18"><a href="#2022-10-18" class="headerlink" title="2022.10.18"></a>2022.10.18</h3><p>秋招最累的一天，这天有4场面试 。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>其实我没有什么故事，也没有什么特别值得回忆的事。说白了就是一个前半生都在为了高考、没有任何方面的喜好及特长（也不被允许有）的很普通的人，尝试着去探索每一种在同龄人中看似很可行的路却又处处碰壁，最终选择了一条现阶段看来最适合自己的路的故事。这种故事很常见，每个试图通过高考谋出路的普通人身上都在上演。</p><p><img src="/%E6%88%91%E7%9A%84%E5%A4%A7%E5%AD%A6/pic.png" alt="pic"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;谨以此文纪念我的大学时光&lt;/p&gt;</summary>
    
    
    
    
    <category term="关于我" scheme="http://example.com/tags/%E5%85%B3%E4%BA%8E%E6%88%91/"/>
    
  </entry>
  
  <entry>
    <title>悖论13</title>
    <link href="http://example.com/%E6%82%96%E8%AE%BA13/"/>
    <id>http://example.com/%E6%82%96%E8%AE%BA13/</id>
    <published>2023-03-17T12:47:23.000Z</published>
    <updated>2023-07-07T09:46:54.550Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是源于前两天在图书馆借的一本小说「悖论13」相关的故事。</p><span id="more"></span><p>大四下学期除了毕设基本没啥事了，每天闲着就去图书馆借几本书读一读。前天晚上看完书，临走的时候在图书馆又借了这本「悖论13」，刚借的时候发现书中有一张折起来的六级成绩单，本来也不是什么大事，毕竟一张没过的六级成绩单随手丢在某本书里也挺常见的。</p><p><img src="/%E6%82%96%E8%AE%BA13/%E5%85%AD%E7%BA%A7.jpg" alt="六级成绩单"></p><p>今天下午在读这本书的时候，在书中发现了张小纸条让我感受到了来自读书人的浪漫。</p><p><img src="/%E6%82%96%E8%AE%BA13/%E6%A0%87%E7%AD%BE.jpg" alt="标签"></p><p>关于书中的细节，在此就不透露了。说起来，大二的时候闲着没事买了一套（大概30张）关于电影台词的明信片，每次都是夹在书里当书签使用，然后在读完这本书时就直接夹在书里还了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要是源于前两天在图书馆借的一本小说「悖论13」相关的故事。&lt;/p&gt;</summary>
    
    
    
    
    <category term="日常" scheme="http://example.com/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>人在梦里死掉的话现实中还会醒过来吗</title>
    <link href="http://example.com/%E4%BA%BA%E5%9C%A8%E6%A2%A6%E9%87%8C%E6%AD%BB%E6%8E%89%E7%9A%84%E8%AF%9D%E7%8E%B0%E5%AE%9E%E4%B8%AD%E8%BF%98%E4%BC%9A%E9%86%92%E8%BF%87%E6%9D%A5%E5%90%97/"/>
    <id>http://example.com/%E4%BA%BA%E5%9C%A8%E6%A2%A6%E9%87%8C%E6%AD%BB%E6%8E%89%E7%9A%84%E8%AF%9D%E7%8E%B0%E5%AE%9E%E4%B8%AD%E8%BF%98%E4%BC%9A%E9%86%92%E8%BF%87%E6%9D%A5%E5%90%97/</id>
    <published>2023-03-10T06:52:08.000Z</published>
    <updated>2023-07-07T09:47:16.124Z</updated>
    
    <content type="html"><![CDATA[<p>昨晚做了个噩梦，每次做噩梦都是逃杀类型的，濒死之际醒来，心跳不止。不禁在想，如果有天我在梦里被杀死了，那现实中的我会醒过来吗。</p><span id="more"></span><h2 id="梦"><a href="#梦" class="headerlink" title="梦"></a>梦</h2><p>昨晚的梦大概是这样的：</p><p>一天晚上突然家里停电了。本来打算睡了，这时候家里来了个老妇人询问一些事。就在我为她解答的时候，她突然掏出了刀想要捅我，我跑到了另一个房间里反锁了门。</p><p>过了一段时间，爷爷来了说他的老年机上的时间不太对，让我给他校对一下。校对完之后送爷爷出去的时候，他突然转身向我丢了一些东西（好像是飞镖之类的暗器）。在我躲的同时，他提着斧子砍了过来，我在地上滚了几圈之后捡起了一根木棍和他打斗在一起，没几个回合我就败下阵来。他骑在我身上掐着我的脖子，在我拼命挣扎的时候，他突然停止了动作，倒在了地上。原来是门口那里有个人丢东西把他杀了。救我的人说，他几年前被我父亲救过一命，因为是在逃命，不知道能去哪就一直在我家后面不远处的一个废弃房屋里住着。他说这里不安全了，等天亮了让我赶紧走他还能拖一点时间。</p><p>他走了，但是我心中充满了疑惑。我决心今晚就要出去寻找一下真相。走着走着，在火车道下面的承重柱旁边有几个邻居。其中一个我称呼他为大伯的人要给其他几个人表演一个魔术，他用了两张贴纸（贴纸上画着箭头）紧挨着贴在了承重柱上（箭头方向这样←→），然后又用导线围着承重柱把箭头的两个指针连接在一起。之后，承重柱疯狂的响（类似于变压器附近那种电流的声音），响了一会儿柱子上开始冒烟，然后他们来追我。我拉起一个愣在原地的人疯狂的跑。（在火车道下面，沿着火车道的方向）跑着跑着，火车道两侧开始往下掉落石头。我以为只要沿着火车道跑就可以，反正石头也砸不到我。这时那个被我拉着的人告诉我不能这么做，用不了多久火车道就会塌掉，我们会被砸死在下面。然后我拉着她跑离火车道，跑着跑着到了一个山坡上，虽然没有悬崖那么陡，但大概也接近七八十度，一脚踩不稳也就滚下去了。这时我俩躺在悬崖的那一侧休息，她像是开玩笑的说，不能被他们抓到，是选择跑回去让石头砸死还是滚下去摔死。我没说话，微微抬头看着来的时候那条路（怕他们追上来），然后她就自言自语的讲着这几天的经历（和我类似，但似乎知道的比我要多很多）。她说着的时候，我看到追我们的那群人要追过来了，然后我就吻了上去想让她闭嘴。她挣扎了一下，似乎听到了那群人的脚步声就停止了反抗。大概是因为我没这方面的经验，大脑想象不出亲吻啥感觉就突然醒了。醒的时候心跳特别特别快，缓了好久才平静下来。</p><h2 id="想"><a href="#想" class="headerlink" title="想"></a>想</h2><p>记得之前看过一篇科幻小说「克莱因瓶」，讲的是一个VR设备可以让人玩游戏时不仅有身临其境般的画面，还有着和游戏角色一样的触觉、嗅觉、疼痛等感觉。（如果换做一个基于现实世界建模的地图的话，很难分清虚拟和现实）小说里面的设定是如果在游戏地图里死亡的话，那种真实的疼痛感会让玩家的大脑觉得玩家真的死亡，将醒不过来。</p><p>其实这个问题挺蠢的，即使在梦里死掉真的醒不过来了，那些人也没办法给我答案。真怕有一天，我在梦里濒死的时候没醒过来，而是死在了梦里。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;昨晚做了个噩梦，每次做噩梦都是逃杀类型的，濒死之际醒来，心跳不止。不禁在想，如果有天我在梦里被杀死了，那现实中的我会醒过来吗。&lt;/p&gt;</summary>
    
    
    
    
    <category term="日常" scheme="http://example.com/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>人不能至少不应该在同一个坑里连续跌倒两次</title>
    <link href="http://example.com/%E4%BA%BA%E4%B8%8D%E8%83%BD%E8%87%B3%E5%B0%91%E4%B8%8D%E5%BA%94%E8%AF%A5%E5%9C%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E5%9D%91%E9%87%8C%E8%B7%8C%E5%80%92%E4%B8%A4%E6%AC%A1/"/>
    <id>http://example.com/%E4%BA%BA%E4%B8%8D%E8%83%BD%E8%87%B3%E5%B0%91%E4%B8%8D%E5%BA%94%E8%AF%A5%E5%9C%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E5%9D%91%E9%87%8C%E8%B7%8C%E5%80%92%E4%B8%A4%E6%AC%A1/</id>
    <published>2022-12-05T06:43:06.000Z</published>
    <updated>2023-07-07T09:47:07.749Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>二〇二二年十二月四日，这天对你来说可能是平平无奇的一天，而这天却给我留下了深刻的记忆。</p></blockquote><p>人不能至少不应该在同一个坑里跌倒两次，而我跌倒了三次。</p><span id="more"></span><p>故事是这样的：</p><p>昨天上午，我骑着我家的1号电动车出去，骑到半路上发现车胎破了无法继续前进，多大点事，推回家换了家里的2号电动车继续出门。</p><p>骑着2号电动车去完超市回到家里发现2号电动车车胎也破了。对比了一下，1号电动车漏气速度较慢，勉强给1号电动车打上气，去村里修补车胎的地方去补胎。发现前面有人换三轮车的电瓶，需要等好一会儿。和老板商量了一下，先骑着老板家的电动车回家，晚上回去换自家的。老板同意了，老板家电动车骑回家了。过了两个小时，骑着老板电动车出门，想去换回自家电动车的时候，老板家的自行车车胎也破了。再次对比了一下，2号电动车漏气速度比老板家的慢，骑着2号电动车去老板家换回了补好胎的1号电动车，并告诉老板有空去我家去补老板家电动车胎。</p><p>车胎破了，很常见的一件事。而我一天见证了三次。</p><p><img src="/%E4%BA%BA%E4%B8%8D%E8%83%BD%E8%87%B3%E5%B0%91%E4%B8%8D%E5%BA%94%E8%AF%A5%E5%9C%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E5%9D%91%E9%87%8C%E8%B7%8C%E5%80%92%E4%B8%A4%E6%AC%A1/000.png" alt="000"></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;二〇二二年十二月四日，这天对你来说可能是平平无奇的一天，而这天却给我留下了深刻的记忆。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;人不能至少不应该在同一个坑里跌倒两次，而我跌倒了三次。&lt;/p&gt;</summary>
    
    
    
    
    <category term="日常" scheme="http://example.com/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>校招之路</title>
    <link href="http://example.com/%E6%B1%82%E8%81%8C/"/>
    <id>http://example.com/%E6%B1%82%E8%81%8C/</id>
    <published>2022-11-28T07:28:42.000Z</published>
    <updated>2023-03-20T10:59:12.843Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍了整个校招过程中走过的路及一些经验</p><span id="more"></span><h2 id="求职之路"><a href="#求职之路" class="headerlink" title="求职之路"></a>求职之路</h2><h3 id="实习"><a href="#实习" class="headerlink" title="实习"></a>实习</h3><p>实习岗位的投递是在三月底，四月初开始的，主要的方向是<strong>CPP软开</strong>和<strong>CPP后端</strong>。选择这个方向主要是因为自己了解到有网络安全方向岗位的互联网大厂比较少，大多是去一些安全厂商做安服、技服等岗位（不太喜欢专业相关岗位），结合自身学过的编程语言只有<code>C/CPP</code>，课程的实验、课设也大多是用<code>C/CPP</code>写的，就选择了<code>CPP</code>这个赛道。再加上当时了解的比较少，没听过一些其他的赛道（测开、嵌入式、客户端都没接触过，也没听说过），就基本上投递的都是后端岗位。</p><p>说来惭愧，刚开始的时候傲气比天高，实习就只投递大厂。当初的我傻傻的以为去一些中小厂实习用处不太大，却没有撒泡尿照照自己几斤几两。当初了解到的企业也不是很多，只投了大概20+的大厂。果然没出意外，没几个面试机会，有也一面凉了。</p><p>当初可能也是脑子有点病，妄想进大厂实习然后转正。投递的全都是暑期实习，一个日常实习也没投。最终秋招落得一个没有相关开发岗位实习经验的下场。</p><p>找实习的结束是在<code>5.15</code>，这一天是学校的实习相关课程提交材料的最后一天。当初也像个憨批一样，没有考虑到七月中旬结束了这两个月的课程再去实习。还有另一个原因，也想去安全厂商看看做安全究竟如何。</p><p>当时学校给的实习单位有3个，选择安恒的原因是只有安恒有和cpp有点关系的实习岗位。（虽然实际上并没有关系）</p><p>整个学校的实习大概分为教学和实战两个阶段。教学阶段就是相关知识的学习；实战阶段是打靶场。然后中间给出了一个<code>重保项目</code>（其实就是HVV），参加了相关的护网，从出发到回家大概一个月的时间，相关的体验可以看另一篇文章。这期间也接触到了一些做安服、技服的人，了解到一些相关的消息，这个时候确定了：除了一些大厂的安全开发相关的岗位，大概是不会考虑网络安全相关的赛道了。</p><h3 id="秋招"><a href="#秋招" class="headerlink" title="秋招"></a>秋招</h3><p>六月底，学校实习课程的教学阶段结束。这个时候开始的投递一些cpp相关的岗位。刚开始的时候眼界还是有点高的，投递的是后端、软开之类的一些岗位，也都是一些比较大的厂。随着时间的推进逐渐的认清现实。又投递了一些<strong>QT客户端</strong>、<strong>嵌入式开发</strong>相关的岗位，关于企业的规模也没有那么多的要求了。（毕竟要没饭吃了）</p><p>7月参加护网，由于工作性质，时间比较阴间，没有办法在白天进行一些面试（要补觉），秋招基本就搁置了。</p><p>整个秋招大批量的笔面试集中在8、9月份，基本上每天都有1+笔面试。10月一共面试了不到10次，其中有一天就面试了4家，身心俱疲。整个秋招过程中有失望，有欣喜。一路摸爬滚打来到了11月底，整个秋招阶段基本接近尾声了，预期的薪资、预期的岗位、预期的企业降了一次又一次，最终也没有选择妥协。截止至写文的今日（十一月底），拿到的offer大概有：东软睿驰、经纬恒润、亚控科技。面试流程已结束，泡池子的大概有：比亚迪(9月底提交了资料审核就没开过奖)、中兴（9月底面完没等来所谓的offer签约会）、同花顺（国庆后一两天面完的HR面也还未开到奖）、华为（京津东北赛道9月底才开始笔试，十月底点亮完六盏灯入池）。想了想，我这一个下棋S6天天赏金，S7天天赌变形重组器的人，不赌一把有点不甘心。（还是已有的offer，薪资不符合预期）今天，拒了最后的保底offer，开启了漫长的泡池子之路，泡不出来就大概要春招了。</p><h3 id="春招"><a href="#春招" class="headerlink" title="春招"></a><del>春招</del></h3><p><del>赌狗一般是不会有好下场的，这个模块迟早要开，先占个坑。</del></p><h3 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h3><ul><li>实习 — 一些较大的厂会有<code>3/6</code>个月的试用期用来培训及做一些简单的任务。对于一些愿意培训的大厂来说，可能实习经历不是那么重要。但是对很多中小厂来说，他们更希望要一个契合度高的、能直接上手的人。如果可以的话，尽早找实习，多找几段日常实习来丰富简历。（虽然很多实习工作并没做一些有意义的工作，但是<del>我猜</del>能让你理解到工程和学习、科研的一些区别）</li><li>八股  —  其实我觉得这是最无聊的部分，他并不能区分出一个应聘者的能力好坏（就看谁背书能力强），但是好多厂的面试会有很多的八股问题，回答不上来还不是很好。（关于八股问题的回答，我的建议是尽量的说的结巴一些，别说那么全。让他觉得是你的知识储备量大，而不是面试前背的面经）</li><li>反问环节  —  很多企业规定，这个阶段不能问面评的。但是我觉得这个阶段可能是我接触一些大厂一线开发人员的不多的机会之一，这个阶段我一般会问对相关岗位的理解及看法、面试官期望的应届生应该具有哪些素质、对职业生涯的建议（基本都会给你讲一些他当年的故事）</li><li>笔试  —  这东西是蛮恶心人的一个环节，因为笔试的结果并没有什么卵用，说这话您可能不信。笔试仅仅是因为HR忙不过来晒选那么多简历，做一个简单的初筛。（当然，雷火那个难度的笔试肯定是有参考价值的）这两个月接触了太多大厂笔试题不太难，九十多分进不了后续环节；一些中厂笔试交白卷照样捞面试（经历了这些让我觉得笔试真就是一个摆设）。</li><li>KPI面  —  这个东西是最恶心人的，而且很多演都不带演的，根据面试官的表现基本上能判断出来。比如某信服的主管面问完问题没有反问直接光速下播反手终止流程、某滴的面试反问环节问基础问题（这个岗位从事什么工作，在企业中属于什么地位）直接不告诉你。</li><li>学历不重要  —  换你是HR，个位数的hc、上万个候选人，你怎么快速的晒选简历。不否认学历证明不了一切，但那些高学历的也不是只有学历。</li></ul><p>最后，</p><blockquote><p>To you and your path, wherever it leads.</p></blockquote><p><img src="/%E6%B1%82%E8%81%8C/000.png" alt="000"></p><hr><h3 id="1224更新"><a href="#1224更新" class="headerlink" title="1224更新"></a>1224更新</h3><p>赌来了华子Offer，准备给华子卖命去了。</p><p>关于我的秋招的时间线及面经，需要自提。</p><table><thead><tr><th align="center">[<a href="https://www.aliyundrive.com/s/GoEqx5J8dGF">下载自解压文件</a>]</th><th align="center">[<a href="https://github.com/ikun7355608/AutumnRecruitment">github在线阅读</a>]</th></tr></thead></table><h3 id="0317更新"><a href="#0317更新" class="headerlink" title="0317更新"></a>0317更新</h3><p>本来20块到付的校招礼盒让我快变成黑粉了，今天突然收到了入职预约附带的机票报销邮件（经济舱、高铁动车一等座、火车软卧 和 市内交通），让我一下子又粉了起来。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍了整个校招过程中走过的路及一些经验&lt;/p&gt;</summary>
    
    
    
    
    <category term="社畜养成计划" scheme="http://example.com/tags/%E7%A4%BE%E7%95%9C%E5%85%BB%E6%88%90%E8%AE%A1%E5%88%92/"/>
    
    <category term="关于我" scheme="http://example.com/tags/%E5%85%B3%E4%BA%8E%E6%88%91/"/>
    
  </entry>
  
  <entry>
    <title>2022-09月度总结</title>
    <link href="http://example.com/2022-09%E6%9C%88%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2022-09%E6%9C%88%E5%BA%A6%E6%80%BB%E7%BB%93/</id>
    <published>2022-09-28T09:03:41.000Z</published>
    <updated>2023-07-07T09:53:07.116Z</updated>
    
    <content type="html"><![CDATA[<p>这个模块已经很久没有更新了，秋招两个月<code>0offer</code>，笔试测评做到吐，面试没几个，面完就泡着。无聊之际，更新一下秋招两个月的历程。</p><blockquote><p>「可以说脏话吗，不可以吗？那我没什么好说的了。」</p></blockquote><span id="more"></span><blockquote><p>山高处看得远，风大雨也大。山脚下条条小路却满目鲜花<br>没有那么多轰轰烈烈与庸庸绿碌，来这世上走上一遭活的其实就是一个好心态。</p></blockquote><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>整个秋招之旅大概开始于六月底，主要进行着C++基础语法、STL相关内容的深入学习。期间在七月初投了一部分简历，然后去参加护网，八月初回来之后开始疯狂投简历。截止至写这篇文章的时候，投了大概100份简历（80+19），感谢信以及官网流程终止的有36家，offer、意向仍然是0。</p><h3 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h3><p>落得如此下场，是环境问题吗？显然，技不如人是真的。本身学安全出身，课程什么的也不会有大型开发的项目，实习也是偏向安全的。虽然有竞赛，但也和互联网没任何关系。在这个hc骤减的环境下，高契合度且有大厂实习的候选人都比hc要多，谁会去考虑一个<strong>没竞赛、没实习、没项目</strong>的<strong>半个科班</strong>的人？</p><p>是眼高手低吗？「<strong>北京</strong>、<strong>千人以上</strong>、<strong>税前20W</strong>」，问了些往届的学长学姐还有一些一起秋招的朋友，「北京、研发」月薪<code>15K</code>上下，虽然不是特别的低，但不至于「<code>100</code>份简历，<code>0offer</code>」吧。我觉得，一个酒吧舞应届生，就算非互联网、不加班的岗位，月薪也有八九千吧。不至于每天被自愿加班的厂都嫌多吧。再者，至今面试了大概二十次左右？好像除了明显的岗位不匹、KPI面外，基本上是没有挂过面试，大多面完疯狂排序泡池子。感觉，也不是能力不行、过不了面试。</p><p>感觉，似乎一路走来，似乎并没有错：认真对待每一门课，哪怕他再水也认真完成作业、准备考试，却落得这<code>0offer</code>的结果；似乎每一步都错了，也许大二结束开始每个寒暑假就该找实习去丰富简历，才会有些竞争力。第一次上大学、一切都靠自己摸索，从机械转安全再转开发，能走到这里感觉已经很不容易了。难道应该收到录取通知书时，就开始了转码之旅？</p><h3 id="心态"><a href="#心态" class="headerlink" title="心态"></a>心态</h3><blockquote><p>每天都在崩溃的边缘，又或者破防后再重建那并不明确的目标。</p></blockquote><p>刚开始的时候，觉得投递自动送测评、海笔的公司还不错，后来发现纯纯浪费时间。性格测评题都没变过，还不能点击过快。辛辛苦苦三四十分钟写完行测、性格测试的题，反手「简历初筛未通过」。</p><p>刚开始的时候确实眼高手低，看很多公司的风评后都觉得「狗都不去」，逐渐的演变为「狗不去，我去」</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>几个等待国庆节后的hr面的企业， 希望能有一个好结果。</p><p>累吗，累。想放弃吗，想。但有的选吗，没有。还能咋办，继续投继续面呗。</p><blockquote><p>我不后悔学、准备C++，只能怪技不如人。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;这个模块已经很久没有更新了，秋招两个月&lt;code&gt;0offer&lt;/code&gt;，笔试测评做到吐，面试没几个，面完就泡着。无聊之际，更新一下秋招两个月的历程。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;「可以说脏话吗，不可以吗？那我没什么好说的了。」&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="周报" scheme="http://example.com/tags/%E5%91%A8%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>虚函数</title>
    <link href="http://example.com/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    <id>http://example.com/%E8%99%9A%E5%87%BD%E6%95%B0/</id>
    <published>2022-09-25T08:38:28.000Z</published>
    <updated>2022-09-30T08:54:19.722Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，动态多态是借助虚函数实现的，下面是关于虚函数的一些介绍。</p><span id="more"></span><h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><p>通俗来讲，虚函数是在编译时，并不能确定的类函数，而是在运行时确定的。<br>独特功能：<strong>基类对象访问派生类的函数</strong>。<br>步骤</p><ol><li>定义基类时，函数声明为虚（virtual）</li><li>派生类中，重写基类中定义为虚的函数。</li><li>声明基类指针指向派生类对象。调用虚函数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">          cout&lt;&lt;<span class="string">&quot;A::foo() is called&quot;</span>&lt;&lt;endl;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">          cout&lt;&lt;<span class="string">&quot;B::foo() is called&quot;</span>&lt;&lt;endl;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A *a = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">    a-&gt;<span class="built_in">foo</span>();   <span class="comment">// 在这里，a虽然是指向A的指针，但是被调用的函数(foo)却是B的!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>纯虚函数可使当前类变成<strong style="color:red;">抽象类</strong>，<mark>禁止该类被实例化</mark>，并要求其非抽象类的派生类<mark>必须重写</mark>该纯虚函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>定义纯虚函数时，不需要定义函数的实现部分。「= 0」 表明程序员将不定义该函数，函数声明是为派生类保留一个位置。「= 0」 的本质是将指向函数体的指针定为$nullptr$</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li>类中一旦出现纯虚函数，就不可实例化了（抽象类）；</li><li>纯虚函数有函数体，但最终还是要被派生类重写，在派生类的函数中可以调用基类中有函数体的纯虚函数；</li><li>为使派生类能完全释放资源，基类析构函数必须声明为虚函数。否则，在用基类指针new一个派生类对象后，delete该指针就只能回收与基类相关的资源，造成内存泄漏；</li><li>纯虚析构函数必须要有函数体。</li></ol><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>存在纯虚函数的类，叫抽象类。</p><ol><li>抽象类不能用作参数类型、函数返回类型或显式转换的类型。</li><li>可以定义指向抽象类的指针和引用，此指针可以指向它的派生类，进而实现多态性。</li><li>抽象类只能用作其他类的基类，不能建立抽象类对象。</li></ol><h3 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h3><p>对象创建时,编译器对<code>vptr</code>进行初始化，只有当对象构造完全结束后<code>vptr</code>的指向才最终确定。<br>使用虚函数时，对象会多出4字节的虚指针，指针指向类的虚函数表。<strong>对象不包含虚函数表，只有虚指针，类才包含虚函数表。</strong><br>虚表中的指针顺序，取决于类中虚函数的<strong style="color:rgb(0, 191, 166);">声明顺序</strong>。<br>虚函数表在实例化对象创建时创建。</p><h3 id="虚指针-amp-虚表"><a href="#虚指针-amp-虚表" class="headerlink" title="虚指针&amp;虚表"></a>虚指针&amp;虚表</h3><p>vptr &amp; vtbl。只要类中有虚函数，类对象内部就会有出现<mark>一个</mark>指针。虚指针用来指向虚表中的<mark>函数指针</mark>指向虚函数的地址。未重写的虚函数，基类和派生类共用。重写了的，各自虚表中指向重写后的地址。<br>通过指针，向上转型，指向虚函数。<code>(*p-&gt;vptr[n])(p)</code></p><h3 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h3><blockquote><p>动态分配堆上内存的时候，析构函数必须是虚函数。</p></blockquote><p>动态的去分配堆区的空间时，无法在程序运行结束自动释放内存。若基类指针指向派生类，然后基类指针调用delete方法，只能释放基类的内存，进而导致内存泄露。<br>析构函数定义成虚函数，基类指针调用delete方法，会先调用派生类的析构函数，然后自动调用基类的析构函数。</p><blockquote><p>友元函数不能为虚函数</p></blockquote><p>友元函数，<mark>不属于</mark>这个类的成员函数。而且虚函数的目的是通过基类对象访问派生类实现的函数，友元函数不是不是成员函数，更无继承关系。</p><blockquote><p>多继承</p></blockquote><p>多继承下有多个虚表。多个基类之间（类内部按声明顺序）的虚函数，按照继承的顺序，存放虚函数指针。<br>虚函数表中，派生类<mark>重写</mark>的虚函数<strong style="color:orange;">替换了基类虚函数指针</strong>，并指向了派生类的函数实现。</p><blockquote><p>哪些函数不支持声明为虚函数</p></blockquote><p>非成员函数、静态成员函数、内联成员函数、构造函数、友元函数。</p><ul><li>非成员函数：非成员函数只能重载，不能重写。编译器会在编译时绑定函数。</li><li>构造函数：构造函数用来创建一个新的对象,而虚函数的运行是建立在对象的基础上,在构造函数执行时,对象尚未形成,所以不能将构造函数定义为虚函数。</li><li>内联函数：内联函数就是为了在代码中直接展开，减少函数调用花费的代价，虚函数是为了在继承后对象能够准确的执行自己的动作，这是不可能统一的。</li><li>静态成员函数： 静态成员函数对于每个类来说只有一份代码，所有的对象都共享这一份代码，他也没有要动态绑定的必要性。</li><li>友元函数： C++不支持友元函数的继承，对于没有继承特性的函数没有虚函数的说法。</li></ul><blockquote><p>为什么构造函数调用虚函数不能实现多态？</p></blockquote><p>子类构造函数要先调用父类构造函数，虚函数实现重载靠的是动态绑定。<br>如果构造函数中的虚函数为动态绑定(多态)，则子类在构造时，子类的构造函数先调用父类构造函数，而此时父类构造函数不能调用子类的重载函数（子类还未创建，没有虚表。）</p><blockquote><p>怎么通过虚函数实现的多态？(内存、寻址等)</p></blockquote><p>通过对象内存中的vptr找到虚函数表vtbl，接着通过vtbl找到对应虚函数的实现区域并进行调用。<br>类的成员函数存在于<code>.text segment</code>段，为类的所有对象公有。(不管创建多少个对象)成员变量存在于<code>.stack/.heap</code>中供类对象独有。<br>含有虚函数的类对象除了存储成员变量外，还存储一个虚指针<code>vptr</code>，这个虚指针指向一张虚表<code>vtbl</code>。<code>vtbl</code>中存的数据为<strong>函数指针</strong>，存储着虚函数调用的具体函数所在的地址。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们知道，动态多态是借助虚函数实现的，下面是关于虚函数的一些介绍。&lt;/p&gt;</summary>
    
    
    
    
    <category term="八股" scheme="http://example.com/tags/%E5%85%AB%E8%82%A1/"/>
    
    <category term="CPP" scheme="http://example.com/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>TCP连接的建立与断开</title>
    <link href="http://example.com/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%BA%E7%AB%8B%E4%B8%8E%E6%96%AD%E5%BC%80/"/>
    <id>http://example.com/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%BA%E7%AB%8B%E4%B8%8E%E6%96%AD%E5%BC%80/</id>
    <published>2022-09-20T06:41:57.000Z</published>
    <updated>2023-07-07T09:48:12.897Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是「三次握手与四次挥手」相关的一些问题</p><span id="more"></span><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><ul><li>初始，客户端处于<code>close</code>状态，服务器处于<code>listen</code>状态</li><li>第一次握手  —  客户端向服务器端发送一个<code>SYN</code>位，切换状态至<code>SYN_SENT</code>。</li><li>第二次握手  —  服务器收到<code>SYN</code>报文，向客户端回一个确认报文<code>ACK</code>，切换状态至<code>SYN_REVD</code>；同时，发送自己的<code>SYN</code>报文进行应答。</li><li>第三次握手  —  客户端收到<code>SYN</code>报文后，发送<code>ACK</code>报文给服务器。同时，自身状态切换至<code>established</code></li><li>服务器端收到<code>ACK</code>报文后，切换自身状态为<code>established</code></li></ul><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><ul><li>客户端、服务器都处于<code>established</code>状态，进行数据传输。</li><li>第一次挥手  —  客户端发送一个<code>FIN</code>位，表示不再发送请求。同时，状态切换至<code>FIN_WAIT_1</code></li><li>第二次挥手  —  服务器收到客户端的结束请求，发送一个<code>ACK</code>位，表示已收到客户端报文。同时，服务器切换状态为<code>CLOSE_WAIT</code></li><li>客户端收到第二次挥手的报文后，切换自身状态为<code>FIN_WAIT_2</code></li><li>第三次挥手  —  服务器传完数据后，向客户端发送结束报文<code>FIN</code>位，进入<code>LAST_ACK</code>状态。</li><li>第四次挥手  —  客户端收到报文后，发送<code>ACK</code>进行应答。同时切换自身状态为<code>TIME_WAIT</code></li><li>服务器收到<code>ACK</code>报文后，关闭连接。切换为<code>CLOSE</code>状态</li><li>客户端在发送第四次握手后等待<code>2MSL</code>切换为<code>CLOSE</code>状态，关闭连接。</li></ul><h3 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h3><h4 id="为什么握手三次"><a href="#为什么握手三次" class="headerlink" title="为什么握手三次"></a>为什么握手三次</h4><blockquote><p>确认双方都能发送、接收数据。</p></blockquote><ul><li>第一次握手  —  服务器端知道客户端可以发送数据</li><li>第二次握手  —  客户端知道服务器端可以发送数据、可以接受数据。</li><li>第三次握手  — 服务器端知道客户端可以接收数据</li></ul><h4 id="FYN泛洪"><a href="#FYN泛洪" class="headerlink" title="FYN泛洪"></a>FYN泛洪</h4><p>利用三次握手的特性，攻击者疯狂发送第一次握手的数据包，收到服务器第二次握手数据包后，并<strong>不会回</strong>第三次握手数据包。服务器收不到相应的ACK位一直重发第二次握手的数据包，最终导致服务器资源耗尽。</p><h4 id="SYN-Cookie"><a href="#SYN-Cookie" class="headerlink" title="SYN Cookie"></a>SYN Cookie</h4><p>为了防止服务器拥有过多上述的半连接状态，在服务器收到第一次握手的数据后，并不会分配资源。而是利用客户端的<code>SYN</code>值计算一个<code>Cookie</code>保存在第二次握手的报文中，返回给客户端，等服务器收到第三次握手的数据包后，根据<code>Cookie</code>值检查报文的合法性。如果合法再分配资源</p><h4 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME_WAIT"></a>TIME_WAIT</h4><blockquote><p>防止第四次挥手丢包。</p></blockquote><p>如果客户端发送完第四次挥手数据后，直接切换至<code>CLOSE</code>状态，第四次挥手数据包丢包时，服务器超时重传第三次挥手数据包。此时如果有新的TCP连接重启这个地址信息的话，处于三次握手阶段，客户端发起的是<code>SYN</code>请求，而服务器所等待的是<code>ACK</code>应答。此时会导致发送<code>RST</code>重建连接。</p><h4 id="2MSL"><a href="#2MSL" class="headerlink" title="2MSL"></a>2MSL</h4><p>在<code>TIME_WAIT</code>防止丢包时，客户端从<code>TIME_WAIT</code>切换至<code>CLOSE</code>需要等待<code>2MSL</code></p><blockquote><p>MSL  报文的最大生存时间</p></blockquote><p>如果第三次挥手的包丢包，则第三次挥手从发送到重发，经过<code>2MSL</code>，此时对于客户端来说，已经过去的时间小于等于<code>1MSL</code>（发送第四次挥手数据包，过程中丢包），而后接收到重发的第三次握手数据包的时间小于等于<code>1MSL</code>。即，客户端等待<code>2MSL</code>未收到<code>FIN</code>（第三次挥手）则能够确认服务器已经收到第四次挥手数据包。</p><p>此外，经过<code>2MSL</code>后，与该次连接相关的所有报文，都会超过生命周期。防止提前关闭客户端时，部分报文还存活，从而影响新的连接。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要是「三次握手与四次挥手」相关的一些问题&lt;/p&gt;</summary>
    
    
    
    
    <category term="八股" scheme="http://example.com/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>图算法</title>
    <link href="http://example.com/%E5%9B%BE%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/%E5%9B%BE%E7%AE%97%E6%B3%95/</id>
    <published>2022-09-12T00:42:30.000Z</published>
    <updated>2023-07-07T09:47:22.719Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍<code>Floyd、Dijkstra、Prim</code>等图算法的代码实现</p><span id="more"></span><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> cost;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;edge&gt; graph[MAX];</span><br><span class="line"><span class="keyword">int</span> v, e;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 顶点数，边数</span></span><br><span class="line">    cin &gt;&gt; v &gt;&gt; e;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e; ++i ) &#123;</span><br><span class="line">        <span class="keyword">int</span> to;</span><br><span class="line">        <span class="keyword">int</span> from;</span><br><span class="line">        <span class="keyword">int</span> cost;</span><br><span class="line">        cin &gt;&gt; from &gt;&gt; to &gt;&gt; cost;</span><br><span class="line">        graph[from].<span class="built_in">push_back</span>(&#123;to, cost&#125;);</span><br><span class="line">        <span class="comment">// 有向图，则是单向 没有to--&gt;from链路</span></span><br><span class="line">        graph[to].<span class="built_in">push_back</span>(&#123;from, cost&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">graph</span>(MAX, vector&lt;<span class="keyword">int</span>&gt;(MAX, INF));</span><br><span class="line"><span class="keyword">int</span> v, e;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; v &gt;&gt; e;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e; ++i) &#123;</span><br><span class="line">        <span class="comment">// 对角线初始化</span></span><br><span class="line">        graph[i][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> to,</span><br><span class="line">            from,</span><br><span class="line">            cost;</span><br><span class="line">        cin &gt;&gt; from &gt;&gt; to &gt;&gt; cost;</span><br><span class="line">        graph[from][to] = cost;</span><br><span class="line">        <span class="comment">// 有向图 </span></span><br><span class="line">        graph[to][from] = cost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h3><p>Floyd算法的核心在于</p><ul><li>想求<code>start ===&gt; finish</code>的最小距离</li><li>考虑借助中间节点<code>k</code>来实现<code>start ===&gt; k ===&gt; finish</code>间接抵达</li><li>此时<code>cost[start][finish] = cost[start][k] + cost[k][finish]</code>（<code>cost[i][j]</code>以表示<code>i ===&gt; j</code>的花费）</li><li>遍历所有节点，找出最小权值和</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//graph：邻接矩阵</span></span><br><span class="line"><span class="comment">// INF：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">Floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; v; ++k) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v;++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; v;++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(graph[i][k] &lt; INF &amp;&amp; graph[k][j] &lt; INF) &#123; <span class="comment">//节点均畅通</span></span><br><span class="line">                    graph[i][j] = <span class="built_in">min</span>(graph[i][j], graph[i][k] + graph[k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h3><p>Dijkstra算法的核心是贪心</p><ul><li>想求<code>start ===&gt; finish</code>的最小距离</li><li>从<code>start</code>开始，考虑剩余（未到达）的可达节点中最小花费。</li><li>最小花费点作为下一个节点，更新花费表。</li><li>依次寻找最小花费，直至抵达目标点</li></ul><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">      0     1     2     3</span><br><span class="line">   -------------------------</span><br><span class="line">  0|<span class="string">  0  </span>|<span class="string">  2  </span>|<span class="string">  6  </span>|<span class="string">  4  </span>|</span><br><span class="line">   |<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|</span><br><span class="line">  1|<span class="string"> INF </span>|<span class="string">  0  </span>|<span class="string">  3  </span>|<span class="string"> INF </span>|</span><br><span class="line">   |<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|</span><br><span class="line">  2|<span class="string">  7  </span>|<span class="string"> INF </span>|<span class="string">  0  </span>|<span class="string">  1  </span>|</span><br><span class="line">   |<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|</span><br><span class="line">  3|<span class="string">  5  </span>|<span class="string"> INF </span>|<span class="string">  9  </span>|<span class="string">  0  </span>|</span><br><span class="line">   -------------------------</span><br><span class="line">从0号节点开始，此时达到其余各点的花费</span><br><span class="line">dist = [0, 2, 6, 4]</span><br><span class="line">此时1、2、3节点均未达，1节点花费最小 前往1节点</span><br><span class="line">dist = [0, 2, 5, 4]</span><br><span class="line">借助1节点到达2节点比直接到达2节点花费小，更新距离表</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//graph：邻接矩阵</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">Dijkstr_visited</span><span class="params">(MAX, <span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">Dijkstra_dist</span><span class="params">(MAX, INF)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = val;</span><br><span class="line">    Dijkstr_visited[start] = <span class="literal">true</span>; <span class="comment">//到达过</span></span><br><span class="line">    Dijkstra_dist = graph[start];      <span class="comment">//初始化为初始行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; v; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = INF; <span class="comment">//最近点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; v; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!Dijkstr_visited[j] &amp;&amp; Dijkstra_dist[j] &lt; tmp) &#123; <span class="comment">//未访问过，最小值</span></span><br><span class="line">                start = j;<span class="comment">//下次访问这个数组</span></span><br><span class="line">                tmp = Dijkstra_dist[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Dijkstr_visited[start] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; v; ++j) &#123;</span><br><span class="line">            Dijkstra_dist[j] = <span class="built_in">min</span>(Dijkstra_dist[j], Dijkstra_dist[start] + graph[start][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h3><p>Prim算法的核心在于</p><ul><li>选择一个节点（生成树内部）开始，考虑到达其他节点的最小花费</li><li>寻找未抵达节点中最小花费（生成树外的节点），将该路径及点加入生成树内</li><li>遍历所有节点，直至全部节点加入生成树</li></ul><blockquote><p>在保证不成环的基础下，依次寻找抵达生成树外节点的最小花费</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * graph：邻接矩阵</span></span><br><span class="line"><span class="comment"> * visited：存放节点是否访问过（最小生成树内部，外部）</span></span><br><span class="line"><span class="comment"> * lowcost：用于寻找靠近角标点的最小权值（扩展）</span></span><br><span class="line"><span class="comment"> * closecost：保存最靠近角标点的元素</span></span><br><span class="line"><span class="comment"> * lowcost[i]：closecost[i]是一对。</span></span><br><span class="line"><span class="comment"> * ***/</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">Prim_visited</span><span class="params">(MAX, <span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">Prim_lowcost</span><span class="params">(MAX, INF)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">Prim_closecost</span><span class="params">(MAX, INF)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Prim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 初始化为从0节点开始</span></span><br><span class="line">    Prim_visited[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    Prim_lowcost = graph[<span class="number">0</span>];</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;0 ----&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v;++i) &#123;</span><br><span class="line">        <span class="comment">// 最小权值，对应的角标</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">-1</span>,</span><br><span class="line">            tmp = INF;</span><br><span class="line">        <span class="comment">// 寻找lowcost的最小值（下一个目标）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; v; ++j) &#123;   <span class="comment">//0已经访问过了 visited[0]一定不成立 故从1开始</span></span><br><span class="line">            <span class="keyword">if</span> (!Prim_visited[j] &amp;&amp; Prim_lowcost[j] &lt; tmp) &#123;</span><br><span class="line">                index = j;</span><br><span class="line">                tmp = Prim_lowcost[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不可达</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">-1</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;cost:&quot;</span> &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">//找不到节点 不可达</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; index &lt;&lt; <span class="string">&quot; ----&gt;&quot;</span>;</span><br><span class="line">        Prim_visited[index] = <span class="literal">true</span>;</span><br><span class="line">        res += Prim_lowcost[index];</span><br><span class="line">        <span class="comment">// 更新最小权值表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; v;++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!Prim_visited[j] &amp;&amp; graph[index][j] != INF &amp;&amp; graph[index][j] &lt; Prim_lowcost[j]) &#123;</span><br><span class="line">                Prim_lowcost[j] = graph[index][j];</span><br><span class="line">                Prim_closecost[j] = index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要介绍&lt;code&gt;Floyd、Dijkstra、Prim&lt;/code&gt;等图算法的代码实现&lt;/p&gt;</summary>
    
    
    
    
    <category term="八股" scheme="http://example.com/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>力扣二叉树</title>
    <link href="http://example.com/%E5%8A%9B%E6%89%A3%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://example.com/%E5%8A%9B%E6%89%A3%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2022-09-11T08:03:45.000Z</published>
    <updated>2023-07-07T09:49:23.783Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是介绍力扣二叉树的构造</p><p>即，从<code>[x, x, x, x, x]</code>为层序遍历的结果来构造一颗二叉树</p><span id="more"></span><h3 id="数据结构定义"><a href="#数据结构定义" class="headerlink" title="数据结构定义"></a>数据结构定义</h3><p>树节点数据结构包括  —  值、左指针、右指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据结构定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="keyword">int</span> val) : <span class="built_in">val</span>(val), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="keyword">int</span> val, TreeNode *left, TreeNode *right) : <span class="built_in">val</span>(val), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right)&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="力扣输入形式构造数组"><a href="#力扣输入形式构造数组" class="headerlink" title="力扣输入形式构造数组"></a>力扣输入形式构造数组</h3><p>根据<code>[x, x, x, x, x]</code>的形式创建数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">string str;</span><br><span class="line"><span class="built_in">getline</span>(cin, str);</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ch:str) &#123;</span><br><span class="line">    <span class="keyword">if</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        val = val * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;,&#x27;</span> || ch == <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(val);</span><br><span class="line">        val = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用层序遍历结果建树"><a href="#用层序遍历结果建树" class="headerlink" title="用层序遍历结果建树"></a>用层序遍历结果建树</h3><p>根据树用数组表示的特点（根节点角标与左右子树角标的关系）来递归构造二叉树</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建树</span></span><br><span class="line"><span class="function">TreeNode *<span class="title">CreateTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= nums.<span class="built_in">size</span>() || nums[index] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode *node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[index]);</span><br><span class="line">    node-&gt;left = <span class="built_in">CreateTree</span>(nums, <span class="number">2</span> * index + <span class="number">1</span>);</span><br><span class="line">    node-&gt;right = <span class="built_in">CreateTree</span>(nums, <span class="number">2</span> * index + <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>层序遍历，验证与输入是否一致</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 层序遍历</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">printTree</span><span class="params">(TreeNode * root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">    queue&lt;TreeNode *&gt; que;</span><br><span class="line">    que.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode *node = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        temp.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left) &#123;</span><br><span class="line">            que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;right) &#123;</span><br><span class="line">            que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="释放内存"><a href="#释放内存" class="headerlink" title="释放内存"></a>释放内存</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteTree</span><span class="params">(TreeNode * root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DeleteTree</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">DeleteTree</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">delete</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 数据结构定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="keyword">int</span> val) : <span class="built_in">val</span>(val), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="keyword">int</span> val, TreeNode *left, TreeNode *right) : <span class="built_in">val</span>(val), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 建树</span></span><br><span class="line"><span class="function">TreeNode *<span class="title">CreateTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= nums.<span class="built_in">size</span>() || nums[index] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode *node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[index]);</span><br><span class="line">    node-&gt;left = <span class="built_in">CreateTree</span>(nums, <span class="number">2</span> * index + <span class="number">1</span>);</span><br><span class="line">    node-&gt;right = <span class="built_in">CreateTree</span>(nums, <span class="number">2</span> * index + <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 释放</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteTree</span><span class="params">(TreeNode * root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DeleteTree</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">DeleteTree</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">delete</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 层序遍历</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">printTree</span><span class="params">(TreeNode * root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">    queue&lt;TreeNode *&gt; que;</span><br><span class="line">    que.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode *node = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        temp.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left) &#123;</span><br><span class="line">            que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;right) &#123;</span><br><span class="line">            que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    string str;</span><br><span class="line">    <span class="built_in">getline</span>(cin, str);</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ch:str) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            val = val * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;,&#x27;</span> || ch == <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(val);</span><br><span class="line">            val = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode *root = <span class="built_in">CreateTree</span>(vec, <span class="number">0</span>);</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    res = <span class="built_in">printTree</span>(root);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        cout &lt;&lt; res[i];</span><br><span class="line">        <span class="keyword">if</span>(i != res.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    <span class="built_in">DeleteTree</span>(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要是介绍力扣二叉树的构造&lt;/p&gt;
&lt;p&gt;即，从&lt;code&gt;[x, x, x, x, x]&lt;/code&gt;为层序遍历的结果来构造一颗二叉树&lt;/p&gt;</summary>
    
    
    
    
    <category term="八股" scheme="http://example.com/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>海量数据问题</title>
    <link href="http://example.com/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98/</id>
    <published>2022-09-11T08:00:46.000Z</published>
    <updated>2022-11-09T02:01:22.110Z</updated>
    
    <content type="html"><![CDATA[<p>高频八股之海量数据问题 </p><blockquote><p>本文参考自<a href="https://blog.csdn.net/v_JULY_v/article/details/7382693">教你如何迅速秒杀掉：99%的海量数据面试题</a></p></blockquote><span id="more"></span><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>数据量过大，而内存空间不足或短时间内无法迅速求解的问题</p><ul><li>内存空间不足  —  分治，存入多个小文件中操作</li><li>短时间不可解  —  数据结构+算法</li></ul><h4 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h4><p><code>分治  ===&gt;  hash  ===&gt;  求解子问题  ===&gt;  归并</code></p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><blockquote><p>现有海量日志数据，要提取出某日访问百度次数最多的那个IPv4地址<br>内存空间有限，不足以全部加载。</p></blockquote><ul><li>分治  —  IP地址范围<code>0.0.0.0 --- 255.255.255.255</code>共$2^{32}$个，根据其规律将其按地址划分(类似子网划分，在此根据掩码来划分为多个文件，以$2^8$为例，划分到$2^8$个子文件中，每个文件$2^{24} = 16M$个不同的IP地址)</li><li>hash  —  将<code>unsigned int32</code>类型的IP地址，做<code>hash(IP)%256</code>处理，划分到256个子文件中(哈希函数一定，某特定IP的多次计算得到的值一定相同，一定在同一个文件)</li><li>求解子问题  —  所求问题为最大值，如果我们对每个子问题（子文件）求最大值，则全局最大值一定在这些子问题最大值中。对每个小文件构建map，统计出现次数的最大值。</li><li>归并  —  得到多个子文件中的最大值（局部最优解）进行比较，得到全局最优解。$ File_i{Max} &gt; File_{else}Max &gt; File_{else}else$（子文件最大值中的最值 &gt; 其他子文件的最值 &gt; 其他子文件所有值）</li></ul><blockquote><p>有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，返回频数最高的100个词。<br>内存限制大小1M</p></blockquote><p>解题思路与上述基本相同，此外</p><ul><li>内存限制为1M，则至少需要<code>1G/1M = 1024</code>个文件(考虑分布不均，应至少为4、5倍，合理即可)</li><li>由于返回的是最大的100个词，同样防止分布不均（高频词都在一个文件），应每个子文件都要求<code>TOP100</code></li><li>如若子文件划分过多，每个的TOP100在内存中放不下（无法直接排序）可以：<ul><li>重复上述步骤</li><li>维持一个堆，记录高频词及出现次数。依次读不同文件来维持这个堆。</li></ul></li></ul><blockquote><p>海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。<br>海量数据中找出重复次数最多的一个<br>上千万或上亿数据（有重复），统计其中出现次数最多的前N个数据。</p></blockquote><p>同上</p><blockquote><p>给定a、b两个文件，各存放50亿个url，每个url各占64字节，找出a、b文件共同的url。<br>内存限制是4G</p></blockquote><ul><li>分治  —  $2^8\times 5G = 5\times2^{40} = 320G &gt; 4G$，将文件划分到多个子文件中（防止分布不均应多划分几个区间，如500个）</li><li>hash  —  文件a、b分别<code>hash(url)%500</code>存入各自子文件中（采用相同的hash函数，则相同的url存在于同一类子文件，如某url在a的子文件$a_{13}$中，则如果b中也有,则一定在$b_{13}$中）</li><li>求解子问题  —  分别读子文件$a_i\qquad b_i$，对比hash值得到相同url（如先将$a_i$中的值存入hash表，然后遍历$b_i$中的值和hash表比对，相同则存在重复元素）</li><li>归并</li></ul><blockquote><p>2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。</p></blockquote><ul><li>方案1  —  上述解决方案仍可行。</li><li>方案2  —  <code>bitmap</code> <ul><li>观察要求，数据分为三类：没出现过、出现一次（所求）、出现多次。我们可以用<code>2bit</code>来反应其出现情况，<code>00 ===&gt;没出现过  01 ===&gt; 出现1次  10 ===&gt; 出现多次</code></li><li>我们只需要人为规定一种映射来对应其关系即可，无需存储具体数字。由于，我们可以用2bit来表示出现情况，则1Bytes大小我们可以表示四个数字的出现情况。比如<code>100</code>即第<code>[100/4]</code>Bytes的第<code>[100%4 * 2]</code>和 <code>[100%4  * 2 + 1]</code>两位。利用<code>移位</code>及<code>&amp;</code>操作即可得到其值。（<code>bitmap[25] &gt;&gt; 6</code>）</li><li>理论原值存储使用空间<code>0.25G*4Bytes = 1GB</code>，实际使用空间<code>0.25G * 2bit = 64MB</code></li></ul></li></ul><blockquote><p>5亿个int型整数，找中位数</p></blockquote><p>按照前面的方案，我们可以将这些数据划分为多个子区域，然后再去寻找中位数。关于<strong>如何划分子区域</strong>，还能够让其保持一个相对顺序：</p><ul><li><p>首先，我们判断最高位，根据最高位为<code>1 or 0</code>可以分为两个子数组</p></li><li><p>再此基础上判断次高位为<code>1 or 0</code>再次划分</p></li><li><p>至此，我们有4个区间<code>0b11XXXXX  0b10XXXXX  0b01XXXXX  0b00XXXXX</code>，分组间的大小关系显而易见。</p></li><li><p>借此思路，我们可以直接根据前<code>X</code>位的值，将其划分为$2^X$个子文件，然后根据中位数（第K顺序统计量）所在的角标来判断其应该处于哪个子文件，然后在子文件中去排序、查找。</p></li></ul><blockquote><p>给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中</p></blockquote><ul><li>方案1  —  上述<code>bitmap</code>方案，每个数字仅需要一位即可（只需判断存在不存在）</li><li>方案2  —  上述子区域划分方案</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;高频八股之海量数据问题 &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文参考自&lt;a href=&quot;https://blog.csdn.net/v_JULY_v/article/details/7382693&quot;&gt;教你如何迅速秒杀掉：99%的海量数据面试题&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="八股" scheme="http://example.com/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>static</title>
    <link href="http://example.com/static/"/>
    <id>http://example.com/static/</id>
    <published>2022-09-07T08:59:23.000Z</published>
    <updated>2022-09-07T09:00:44.836Z</updated>
    
    <content type="html"><![CDATA[<p><code>static</code>关键字相关知识点</p><span id="more"></span><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>函数内部定义的变量，当程序执行到它的定义处时，编译器为它在栈上分配空间，函数执行结束时会释放掉他的内存。为保持变量的持久性，我们可以声明其为全局变量、全局函数。但全局函数又破坏了变量的访问范围，为了控制变量的存储方式和可见性，引入<code>static</code>关键字。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol><li>修饰局部变量  —  延长生命周期</li></ol><p>局部变量一般创建在栈区，将其声明为<code>static</code>会导致变量创建在全局区。全局区的变量只会在程序运行前初始化一次，其生命周期会一直延续到整个程序执行结束。</p><blockquote><p>生命周期以及存储空间发生了变化，但其作用域并没变。</p></blockquote><ol start="2"><li>修饰全局变量、函数  —  信息隐藏，对其他文件不可见。</li></ol><p>当同时编译多个文件时，所有未加 static 前缀的全局变量和函数都具有全局可见性。（可被其他文件访问）</p><p>声明为<code>static</code>后，该变量/函数仅在该文件中可见，不能被其他文件访问。</p><blockquote><p>同一工程下，不能被其他文件引用；文件外可定义同名变量/函数。</p></blockquote><ol start="3"><li>修饰类成员</li></ol><p>被<code>static</code>修饰的类成员函数、类成员变量，统一属于类的静态资源，是类实例之间共享的，不是属于此类的任何特定对象。</p><p>静态非常量数据成员在类内仅声明，只能在类外定义和初始化。</p><p><code>static</code>函数不接受<code>this</code>指针只能访问类的 <code>static </code>成员变量。(因为不属于某个具体对象)</p><blockquote><p>static 成员函数不能被 virtual 修饰(同样，因为不属于具体的某个对象)<br>虚函数的重写是通过每个对象内的虚指针去调用，而虚指针调用需要用到<code>this</code>。(<code>this</code>指针 –&gt; <code>vptr</code> –&gt;<code>vtable</code> –&gt; <code>virtual function</code>)</p></blockquote><blockquote><p>静态成员函数中不能引用非静态成员。类的非静态成员函数可以调用用静态成员函数。<br>静态的资源属于类，并没有实例化对象，没办法知道该类具体有哪些非静态的资源。而对象创建时，类有哪些成员是已知的，均可访问。</p></blockquote><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化只有一次，但是可以多次赋值，在主程序之前，编译器已经为其分配好了内存。</p><blockquote><p>在静态数据区，内存中所有的字节默认值都是 <code>0x00</code>，可以不用人为的初始化。</p></blockquote><p>在 C++中，初始化时在<strong>执行相关代码时才会进行初始化</strong>，主要是由于 C++引入对象后，要进行初始化必须执行相应构造函数和析构函数，在构造函数或析构函数中经常会需要进行某些程序中需要进行的特定操作，并非简单地分配内存。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;static&lt;/code&gt;关键字相关知识点&lt;/p&gt;</summary>
    
    
    
    
    <category term="八股" scheme="http://example.com/tags/%E5%85%AB%E8%82%A1/"/>
    
    <category term="CPP" scheme="http://example.com/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>内存分区</title>
    <link href="http://example.com/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/"/>
    <id>http://example.com/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/</id>
    <published>2022-09-05T08:25:22.000Z</published>
    <updated>2023-07-07T09:49:14.760Z</updated>
    
    <content type="html"><![CDATA[<p>本文基于笔试时遇到的简答题「内存空间分为哪几类」以及面试时遇到的问题「用户态/内核态，了解多少」</p><span id="more"></span><h3 id="Kernal-Space"><a href="#Kernal-Space" class="headerlink" title="Kernal Space"></a><code>Kernal Space</code></h3><p>内核空间。由于开发和维护内核的复杂性，只有最重要的和最关键的代码放置在内核中。其他内容通常是作为用户空间应用程序编程的。（避免一些敏感操作）</p><h3 id="User-Space"><a href="#User-Space" class="headerlink" title="User Space"></a><code>User Space</code></h3><blockquote><p>用户态的程序不能随意操作内核空间，这样对操作系统具有一定的安全保护作用。</p></blockquote><p>用户空间从高地址到低地址依次分为如下五个区：</p><h4 id="stack"><a href="#stack" class="headerlink" title=".stack"></a><code>.stack</code></h4><p>栈区。<strong>编译器</strong>在需要的时候分配，不需要时自动清除的变量所在的储存区。</p><ul><li>由编译器自动管理</li><li>程序运行时分配内存</li><li>使用效率高、但空间有限。</li><li>从高地址向低地址扩展，内存连续。</li><li>先进后出</li><li>存放：函数的入口参数、局部变量等</li></ul><h4 id="heap"><a href="#heap" class="headerlink" title=".heap"></a><code>.heap</code></h4><p>堆区。由程序员手动分配释放的储存区。忘记释放会造成内存泄漏。</p><ul><li>程序员手动管理(手动申请、释放)</li><li>程序运行时分配内存</li><li>空间大，可以是不连续的。</li><li>从低地址向高地址扩展</li><li>先进先出</li><li><code>malloc、realloc</code>等开辟的空间即堆区的空间</li></ul><h4 id="bss-segment"><a href="#bss-segment" class="headerlink" title=".bss segment"></a><code>.bss segment</code></h4><p>全局/静态区。用来存放全局变量、静态变量的区域；当程序运行结束后由系统释放。</p><ul><li>由编译器自动管理</li><li>编译时分配内存</li><li>存放全局变量、静态变量</li></ul><h4 id="data-segment"><a href="#data-segment" class="headerlink" title=".data segment"></a><code>.data segment</code></h4><p>常量区。用来存放字符串字面量、<code>const</code>修饰的全局变量、静态变量。</p><ul><li>由编译器自动管理</li><li>编译时分配内存</li><li>存放<code>const</code>全局变量、<code>const</code>静态变量、字符串字面量。</li></ul><h4 id="text-segment"><a href="#text-segment" class="headerlink" title=".text segment"></a><code>.text segment</code></h4><p>代码区。用于存放CPU指令</p><ul><li>由编译器自动管理</li><li>编译时分配内存</li><li>存放CPU指令</li></ul><h3 id="用户态-内核态"><a href="#用户态-内核态" class="headerlink" title="用户态/内核态"></a>用户态/内核态</h3><blockquote><p>用户态  —  进程运行在用户空间<br>内核态  —  进程运行在内核空间</p></blockquote><p>在<strong>内核态</strong>下，CPU 可以<strong>执行任何指令</strong>。运行的<strong>代码也不受任何的限制</strong>，可以<strong>自由地访问任何有效地址</strong>，也可以直接进行端口的访问。</p><p>在用户态下，被执行的代码要受到 CPU 的很多检查。</p><h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><p>磁盘上文件的读写、内存空间的分配、网络接口读写数据等，都是在内核态完成的。平时使用时，借助操作系统提供的<strong>系统调用接口</strong>来进行使用。</p><blockquote><p>应用程序读取文件大致步骤</p></blockquote><ol><li>应用程序向内核发起系统调用，将进程从用户态切换为内核态。</li><li>CPU把数据读取到内核空间</li><li>数据拷贝到用户空间，并将进程切换为用户态。</li><li>应用程序得到相应的数据，执行其他命令。</li></ol><p>库函数、Shell指令等就是利用操作系统提供的调用接口来实现用户态的程序向操作系统申请更高权限的服务。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文基于笔试时遇到的简答题「内存空间分为哪几类」以及面试时遇到的问题「用户态/内核态，了解多少」&lt;/p&gt;</summary>
    
    
    
    
    <category term="八股" scheme="http://example.com/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>线程同步</title>
    <link href="http://example.com/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    <id>http://example.com/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</id>
    <published>2022-08-24T14:15:25.000Z</published>
    <updated>2023-07-07T09:47:31.438Z</updated>
    
    <content type="html"><![CDATA[<p>程序执行结果依赖于不同线程执行的先后顺序，那么就会形成「竞争条件」，由于竞争条件下计算结果是非预期的，因此我们应该尽量避免竞争条件的形成。</p><p>解决竞争条件的方式，除原子操作外，还有线程同步。</p><span id="more"></span><h3 id="同步-amp-amp-互斥"><a href="#同步-amp-amp-互斥" class="headerlink" title="同步 &amp;&amp; 互斥"></a>同步 &amp;&amp; 互斥</h3><p>多个线程之间协调同步，按照预定的先后次序进行运行（非同时）</p><p>对于线程共享的线程资源，在各个线程访问时具有排它性。当有若干个线程要访问同一共享资源时，任何时刻只允许一个线程进行访问，直到占有资源者放弃使用该资源。</p><h3 id="同步方式"><a href="#同步方式" class="headerlink" title="同步方式"></a>同步方式</h3><h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><p>每个线程在对共享资源操作前都会尝试先加锁，加锁成功才能操作，操作结束之后解锁。</p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul><li>当线程抢互斥锁失败的时候，线程会陷入休眠。</li><li>节省CPU资源，消耗等待时间</li></ul><h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><p>条件变量用来锁定一个线程，直到某个特殊的条件发生才继续执行。</p><h5 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h5><ul><li>创建条件变量</li><li>某线程因等待条件变量成立而挂起</li><li>一段时间后，另一个线程激活了条件变量</li><li>条件变量清楚，线程继续执行。</li></ul><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>信号量，分匿名信号量和命名信号量。</p><ul><li><p>临界资源  —  同一时刻只允许一个线程（或进程）访问的资源</p></li><li><p>临界区  —  访问临界资源的代码段。</p></li><li><p>P操作  —  申请资源 </p></li><li><p>V操作  —  释放资源</p></li></ul><blockquote><p>信号量允许多个线程同时进入临界区，而互斥量只允许一个线程进入临界区。</p></blockquote><h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><p>读写锁和互斥锁类似，但允许更高的并行性，有一定的性能提升。</p><p>一次只有一个线程可以占有写模式下的读写锁，但是可以有多个线程占有读模式下的读写锁。</p><ul><li>写独占  —  写锁占用时，其他线程加读锁或者写锁时都会阻塞（并非失败）</li><li>读共享  —  读锁占用时，其他线程加写锁时会阻塞，加读锁会成功</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;程序执行结果依赖于不同线程执行的先后顺序，那么就会形成「竞争条件」，由于竞争条件下计算结果是非预期的，因此我们应该尽量避免竞争条件的形成。&lt;/p&gt;
&lt;p&gt;解决竞争条件的方式，除原子操作外，还有线程同步。&lt;/p&gt;</summary>
    
    
    
    
    <category term="八股" scheme="http://example.com/tags/%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
</feed>
