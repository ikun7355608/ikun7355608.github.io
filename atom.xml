<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>残局</title>
  
  <subtitle>一个混子的自我救赎</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-01-21T06:34:08.339Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>东北某卑微大学生</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>动态规划</title>
    <link href="http://example.com/2022/01/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://example.com/2022/01/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2022-01-13T06:08:01.000Z</published>
    <updated>2022-01-21T06:34:08.339Z</updated>
    
    <content type="html"><![CDATA[<p>虽然，Carl的<a href="https://programmercarl.com/">《代码随想录》</a>和labuladong的<a href="https://labuladong.gitee.io/algo/">《算法小抄》</a>对“动态规划”类问题有着详尽且优质的解答，但仍然想在这里简单啰嗦一下<strong>动态规划</strong>。在这里，并不想以《算法导论》中较为晦涩且难懂的<code>「矩阵连乘」</code>、<code>「最优二叉搜索树」</code>等为样例进行讲解。</p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>动态规划，英文名：Dynamic Programming，简称DP。其算法的基本思想是：将待求解的问题<strong>分解成若干个子问题</strong>，先求解子问题，再<strong>由子问题的解得到原问题的解</strong>。换句话说，将一个复杂的问题，分解为多个相互联系的较为简单的子问题，对每个子问题进行求解，复杂问题的答案蕴含在子问题中（<strong>具备「最优子结构」</strong>）。</p><span id="more"></span><p>通常，可以用动态规划求解的问题也可以用<strong style="color:red;">穷举</strong>来解决问题。但在穷举的过程中会<strong>存在「重叠子问题」</strong>。即，在暴力穷举求解时，一些中间值会进行多次的重复计算，严重影响效率。以斐波那契数列为例:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fib</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">2</span>) ? n: <span class="built_in">Fib</span>(n - <span class="number">1</span>) + <span class="built_in">Fib</span>(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归树如下:</p><p><img src="/2022/01/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/DPFib.png" alt="斐波那契数列"></p><center>随着递归的进行，$Fib(n)\quad n \in \left[ 2,18\right]$均计算了多次</center><p>我们知道，这些进行<strong style="color:red;">重复计算的值</strong>如果<strong style="color:red;">只计算一次</strong>的话，求解问题的<strong style="color:red;">效率</strong>会有一定的<strong style="color:red;">提高</strong>。</p><p>为解决该问题，引入了「备忘录方法」。即，其在<strong style="color:red;">自顶向下</strong>递归过程中<strong style="color:#e67c86;">用一个表来保存已解决问题的答案</strong>，在求解时先查表，表中有的直接用，没有的再递归。上述斐波那契数列在每次递归求解$Fib(n-1)+Fib(n-2)$时，$Fib(n-2)$的值在求解$Fib(n-1)$时已经求过，直接从表中引用。</p><p>我们发现，在利用「备忘录方法」进行求解时，我们是每求解一个问题记录一次，当<strong>并非所有子问题都需要求解时</strong>，「备忘录方法」可以严格的只求解需要的问题，而当所有子问题都需要求解一次或多次时，考虑使用动态规划。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N &lt;= <span class="number">1</span>) <span class="keyword">return</span> N;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(N + <span class="number">1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基本要素"><a href="#基本要素" class="headerlink" title="基本要素"></a>基本要素</h1><p>动态规划三个基本要素分别为：最优子结构、重叠子问题、状态转移方程。</p><ol><li>最优子结构：当<strong>问题的最优解包含了其子问题的最优解</strong>时，称该问题具有最优子结构性质。分析最优子结构性质时，一般假设由问题的最优解导出的子问题不是最优的，然后再设法说明在这个假设下可以构造出一个比原问题更优解更好的解，从而导出矛盾。</li><li>重叠子问题：在用递归算法自顶向下解此问题时，每次产生的子问题并不总是新问题，<strong>有些子问题被反复计算多次</strong>。动态规划算法对每个问题只解一次，而后将其解保存在一个表格中，当再次需要解此问题时，用常数时间查看一下结果。因此，用动态规划算法通常只需要多项式时间。</li><li>状态转移方程：动态规划中，一个状态向另一个状态转变时的规则。实际的算法问题中，列出状态转移方程往往较为困难。在列相应的状态转移方程时，我们需要注意：确定状态数组<code>dp</code>中角标的含义、初始化时已确定的状态及递归公式。</li></ol><h1 id="求解步骤"><a href="#求解步骤" class="headerlink" title="求解步骤"></a>求解步骤</h1><ol><li>找出最优解的性质，并刻划最优解的结构特征。</li><li> 递归地定义最优值。</li><li> 以自底向上的方式计算出最优值。</li><li> 根据计算最优值时得到的信息，构造最优解。</li></ol><h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><p>首先，<strong style="color:red;">动态规划和分治法</strong>都是分解成子问题，由子问题的解得到原问题的解。但需要将二者进行区分：动态规划中除了有诸多的重叠子问题外，各子问题之间还存在着一定的关联(通过状态转移方程递推其他状态)。而分治法中，各子问题相对独立。</p><p>再者，<strong style="color:red;">贪心算法和动态规划</strong>也同样的都需要分解子问题来求解。二者所不同的是：<strong style="color:#9b2ebd;">动态规划</strong>在求解问题时需要<strong style="color:#9b2ebd;">遍历所有的可能</strong>情况。而<strong style="color:rgb(0, 191, 166);">贪心算法</strong>在每个子问题求解时<strong style="color:rgb(0, 191, 166);">只考虑局部最优解</strong>的情况。语言介绍较为苍白无力，接下来用<strong style="color:#e67c86;">「拼凑面额问题」</strong>来对比二者的区别。在此，我们将会引入一些面额的纸币以方便举例。</p><h2 id="能否凑出面额"><a href="#能否凑出面额" class="headerlink" title="能否凑出面额"></a>能否凑出面额</h2><p>假设，我们去商店买东西。已知，口袋里有如下几种面额的纸币各<strong>一张</strong>：<code>1</code>,<code>2</code>,<code>5</code>,<code>10</code>,<code>13</code>，我们需要支付的金额为<code>17</code>。而由于种种原因，商店并没有零钱。即，我们需要用上述五个数字中的部分进行加和，让值恰好为17。</p><ul><li><strong style="color:#c04851;">贪心算法</strong><ol><li>首先拿出面值为<code>13</code>的纸币。由于<code>13&lt;17</code>，面值<code>13</code>的纸币<strong>一定要使用</strong>。接下来，我们需要用<code>1</code>,<code>2</code>,<code>5</code>,<code>10</code>四张纸币支付<code>4</code>。</li><li>面值为<code>10</code>的纸币超过了要支付的金额，不予使用。</li><li>面值为<code>5</code>的纸币超过了要支付的金额，不予使用。</li><li>由于<code>2 &lt; 4</code>，面值为<code>2</code>的纸币也一定使用。</li><li>最后，剩下一张面值为<code>1</code>的纸币，不足以支付剩余的金额<code>2</code>。则贪心算法的结果是不能支付。</li></ol></li><li><strong>动态规划</strong><ol><li>我们假设在此按照自顶向下(最大面值开始)求解该问题时，同样的也会经历上述步骤。但，上述步骤执行完时并不直接返回<code>false</code>，而是继续考虑。</li><li>这一次，我们将考虑不需要面值为<code>13</code>的纸币。而是使用面值为<code>10</code>的纸币。这一次，我们需要利用剩下的面值为<code>1</code>,<code>2</code>,<code>5</code>面值的纸币凑出<code>7</code>。</li><li>由于<code>5 &lt; 7</code>，使用面值为<code>5</code>的纸币，我们需要利用剩下的面值为<code>1</code>和<code>2</code>的纸币凑够金额2。显然这是可以的。因此利用动态规划得到的结果是可以支付。</li></ol></li></ul><h2 id="最少纸币数量"><a href="#最少纸币数量" class="headerlink" title="最少纸币数量"></a>最少纸币数量</h2><p>这一次，我们有面值为<code>2</code>,<code>8</code>,<code>10</code>的纸币，假设每种纸币的数量<strong>足够多</strong>。我们需要做的是拼凑出金额<code>16</code>。我们所做的是怎么用较少的纸币数量拼凑出相应的金额。</p><ul><li><strong>贪心算法</strong><ol><li>首先，我们拿出面值为<code>10</code>的纸币，一张即可（<code>10 &lt; 16 &lt; 2 * 10</code>）。接下来，需要利用面值为<code>2</code>和<code>8</code>的纸币凑够金额<code>6</code></li><li>面值为<code>8</code>的纸币超过了要支付的金额，不予使用。</li><li><code>3 * 2 = 6</code>。故需要4张纸币。</li></ol></li><li><strong>动态规划</strong><ul><li>在上述基础上，动态规划还会去考虑不使用面值为<code>10</code>时候的其他情况，分别<code>2 * 8</code>，<code>8 + 4 * 2</code>，<code>8 * 2</code>三种方案，最终确定为使用2张面值<code>8</code>的纸币所用纸币数量最少。</li></ul></li></ul><p>最后，需要声明的是，以上样例中动态规划的解法是为方便理解，效率上有着改进的空间。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;虽然，Carl的&lt;a href=&quot;https://programmercarl.com/&quot;&gt;《代码随想录》&lt;/a&gt;和labuladong的&lt;a href=&quot;https://labuladong.gitee.io/algo/&quot;&gt;《算法小抄》&lt;/a&gt;对“动态规划”类问题有着详尽且优质的解答，但仍然想在这里简单啰嗦一下&lt;strong&gt;动态规划&lt;/strong&gt;。在这里，并不想以《算法导论》中较为晦涩且难懂的&lt;code&gt;「矩阵连乘」&lt;/code&gt;、&lt;code&gt;「最优二叉搜索树」&lt;/code&gt;等为样例进行讲解。&lt;/p&gt;
&lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;动态规划，英文名：Dynamic Programming，简称DP。其算法的基本思想是：将待求解的问题&lt;strong&gt;分解成若干个子问题&lt;/strong&gt;，先求解子问题，再&lt;strong&gt;由子问题的解得到原问题的解&lt;/strong&gt;。换句话说，将一个复杂的问题，分解为多个相互联系的较为简单的子问题，对每个子问题进行求解，复杂问题的答案蕴含在子问题中（&lt;strong&gt;具备「最优子结构」&lt;/strong&gt;）。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数据结构&amp;算法" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>红黑树</title>
    <link href="http://example.com/2022/01/05/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>http://example.com/2022/01/05/%E7%BA%A2%E9%BB%91%E6%A0%91/</id>
    <published>2022-01-05T12:37:45.000Z</published>
    <updated>2022-01-21T06:33:59.079Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>由于二叉搜索树很不平衡，很容易退化为一条类似链表的结构，从而造成时间复杂度从$O(lgN)$降低为$O(N)$。</p><p>为解决这一问题，引入了<strong>“平衡”二叉搜索树</strong>，红黑树就是其中的一种。红黑树在树的基础上，为每个节点增加了一个<strong>颜色位</strong>，可以是<code>RED</code>，也可以是<code>BLACK</code>。通过对每条路径的颜色进行约束，保证红黑树处于<strong style="color:#e67c86;">近似平衡</strong>的状态，从而保证了查找最坏情况为$O(lgN)$。</p><span id="more"></span><h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p>红黑树除了本身是<strong style="color:rgb(0, 191, 166);">二叉搜索树</strong>外，还满足以下条件：</p><ol><li>每个节点<strong style="color:red;">要么是红色</strong>的，<strong style="color:red;">要么是黑色</strong>的。</li><li><strong style="color:red;">根节点</strong>是<strong style="color:red;">黑色</strong>的。</li><li>每个空节点(<strong style="color:red;">NIL</strong>)都是<strong style="color:red;">黑色</strong>的。</li><li><strong style="color:red;">红色节点</strong>的两个<strong style="color:red;">子节点</strong>都是<strong style="color:red;">黑色</strong>的。</li><li><strong style="color:red;">每个节点</strong><strong>到</strong>其后代<strong style="color:red;">叶子节点</strong>的路径上包含的<strong style="color:red;">黑色节点数目相同</strong>。</li></ol><p>红黑树的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">RBTColor</span>&#123;</span>RED, BLACK&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RBTNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    T key;</span><br><span class="line">        RBTColor color;</span><br><span class="line">        RBTNode *left;</span><br><span class="line">        RBTNode *right;</span><br><span class="line">        RBTNode *parent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>样例如图：</p><p><img src="/2022/01/05/%E7%BA%A2%E9%BB%91%E6%A0%91/RedBlackTree.png" alt="红黑树样例"></p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>由于结点的插入、删除操作对树进行了修改。修改后的红黑树可能<strong style="color:red;">不再满足</strong>上面所列出的<strong style="color:red;">红黑性质</strong>，故需要对树的某些结点进行<strong style="color:pink;">旋转</strong>或<strong style="color:pink;">变色</strong>使其自平衡。</p><p>忽略红黑特性，以一个二叉搜索树为例进行演示旋转。样例如下：</p><p><img src="/2022/01/05/%E7%BA%A2%E9%BB%91%E6%A0%91/RBTreeRotate.png" alt="红黑树旋转"></p><p>图中<code>x y</code>是两个节点，<code>a b c</code>表示任意子树。</p><p>不难看出，图中的旋转仍然保持了二叉搜索树的性质：a子树所有节点的key值小于<code>x.key</code>;c子树所有节点的key值大于<code>y.key</code>;b子树key值介于<code>x.key</code>与<code>y.key</code>之间。伪代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左旋</span></span><br><span class="line">LEFT-<span class="built_in">ROTATE</span>(T, x)</span><br><span class="line">y = x.right</span><br><span class="line">x.right = y.left<span class="comment">//上图中，b子树的移动</span></span><br><span class="line"><span class="keyword">if</span> y.left != <span class="literal">nullptr</span></span><br><span class="line">    y.left.parent = x<span class="comment">//过继过去的b子树父节点改变</span></span><br><span class="line">y.parent = x.parent</span><br><span class="line">    <span class="comment">//改变x的父节点的指向</span></span><br><span class="line"><span class="keyword">if</span> x.parent == <span class="literal">nullptr</span></span><br><span class="line">    T.root = y<span class="comment">//x父节点为空，证明x为根节点 即左旋后的y节点变为根节点</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> x == x.parent.left</span><br><span class="line">    x.parent.left = x</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    x.parent.right = y</span><br><span class="line">y.left = x<span class="comment">//将x链接在y的左侧</span></span><br><span class="line">x.parent = y</span><br><span class="line"></span><br><span class="line"><span class="comment">//右旋</span></span><br><span class="line">RIGHT-<span class="built_in">ROTATE</span>(T, y)</span><br><span class="line">x = y.left</span><br><span class="line">y.left = x.right</span><br><span class="line"><span class="keyword">if</span> x.right != <span class="literal">nullptr</span></span><br><span class="line">    x.right.parent = y</span><br><span class="line">x.parent = y.parent</span><br><span class="line"><span class="keyword">if</span> y.parent == <span class="literal">nullptr</span></span><br><span class="line">    T.root = x</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> y == y.parent.left</span><br><span class="line">    y.parent.left = x</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    y.parent.right = x</span><br><span class="line">x.right = y</span><br><span class="line">y.parent = x</span><br></pre></td></tr></table></figure><p>旋转操作只改变所旋转元素附近的指针，其他属性均未改变。可以在常数时间$O(1)$内完成。</p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>由于红黑树对黑色节点的要求较为苛刻，新插入的节点<strong>默认为红色</strong>。</p><p>将某个节点插入到红黑树，详细过程如下：</p><ol><li>首先，红黑树本身是一个<strong>二叉搜索树</strong>，依据其性质可以找到相应的插入位置，保证节点<strong>插入后</strong>key仍<strong>有序</strong>。</li><li>插入后，进行一系列的<strong style="color:red;">旋转</strong>、<strong style="color:red;">着色</strong>使其继续<strong style="color:red;">保持红黑特性</strong>。</li></ol><p>正常情况下(排除红黑树从0开始构建的情况)，当我们插入一个节点后如果违反了红黑树的红黑特性，那么所违反的应该为特性4(红节点的两个子节点均为黑色)。我们需要<strong>从当前节点向根节点</strong>逐层向上判断是否调整并作出相应的<strong>调整</strong>。相关调整方案如下：</p><p><img src="/2022/01/05/%E7%BA%A2%E9%BB%91%E6%A0%91/RBTreeInsert.png" alt="RBTreeInsert"></p><p>最后，<strong style="color:red;">根节点</strong>恒<strong style="color:red;">染为黑色</strong>。</p><p>下面给出一个范例，显示一个红黑树上的调整操作。</p><p><img src="/2022/01/05/%E7%BA%A2%E9%BB%91%E6%A0%91/RBTreeInsertExp.png" alt="RBTreeInsertExp"></p><p>在上图中，初始状态<code>x</code>为插入的节点，其父节点(<code>key = 5</code>)违背红黑规则4，需要进行调整：</p><ol><li>由于<code>x</code>的父节点和叔节点都是红色（调整方案1.2），调整时需要将其父节点(<code>key = 5</code>)和叔节点(<code>key = 8</code>)染成黑色，将其祖父节点(<code>key = 7</code>)染成红色，然后考虑其祖父节点。<code>x节点</code>上移为其祖父节点(<code>key = 7</code>)，此时<code>x节点</code>的父节点(<code>key = 2</code>)违背红黑规则4</li><li>叔节点不为红色，调整策略对应为1.1。观察到<strong style="color:pink;">父节点是祖父节点的左子树，自己是父节点的右节点</strong>(1.1.1.1)。当前节点上移为其父节点(<code>key = 2</code>)然后左旋。左旋后的<code>x节点</code>执行调整方案1.1.1.2</li><li>父节点(<code>key = 7</code>)染成黑色，祖父节点(<code>key = 11</code>)染成红色，将祖父节点右旋。<code>x节点</code>的父节点(<code>key = 11</code>)不再是红色，退出循环。此时当前红黑树不再违背红黑规则。</li><li>循环退出后，将其<strong style="color:red;">根节点染成黑色</strong>。</li></ol><p>调整方案对应的伪代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> x.parent.color == RED<span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> x.parent == x.parent.parent.left</span><br><span class="line">        y = x.parent.parent.right<span class="comment">//叔节点</span></span><br><span class="line">        <span class="keyword">if</span> y.color == RED<span class="comment">//1.2</span></span><br><span class="line">            x.parent.color = BLACK</span><br><span class="line">            y.color = BLACK</span><br><span class="line">            x.parent.parent.color = RED</span><br><span class="line">            x = x.parent.parent</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span> x == x.parent.right<span class="comment">//1.1.1.1</span></span><br><span class="line">                <span class="comment">//父节点左旋并置为当前</span></span><br><span class="line">                x = x.parent</span><br><span class="line">                LEFT-<span class="built_in">ROTATE</span>(T, x)</span><br><span class="line">            <span class="comment">//1.1.1.2</span></span><br><span class="line">            x.parent.color = BLACK</span><br><span class="line">            x.parent.parent.color = RED</span><br><span class="line">            RIGHT-<span class="built_in">ROTATE</span>(T, x.parent.parent)</span><br><span class="line">    <span class="comment">//父节点为右</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        y = x.parent.parent.left</span><br><span class="line">        <span class="keyword">if</span> y.color == RED</span><br><span class="line">            x.parent.color = BLACK</span><br><span class="line">            y.color = BLACK</span><br><span class="line">            x.parent.parent.color = RED</span><br><span class="line">            x = x.parent.parent</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span> x == x.parent.left <span class="comment">//1.1.2.2</span></span><br><span class="line">                x = x.parent</span><br><span class="line">                RIGHT-<span class="built_in">ROTATE</span>(T, x)</span><br><span class="line">            <span class="comment">//1.1.2.1</span></span><br><span class="line">            x.parent.color = BLACK</span><br><span class="line">            x.parent.parent.color = RED</span><br><span class="line">            LEFT-<span class="built_in">ROTATE</span>(T, x.parent.parent)</span><br><span class="line">T.root.color = BLACK</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除和插入操作类似，也分为两个步骤：</p><ol><li>红黑树本身是一个<strong>二叉搜索树</strong>，根据其性质<strong style="color:red;">寻找到对应节点并删除</strong>掉。删除的情况如下<ul><li>若该节点是<strong style="color:red;">叶子节点</strong>，则<strong>直接删除</strong>。</li><li>若<strong style="color:red;">只有一个子树</strong>，则用子树<strong>替代当前节点</strong>。</li><li>若<strong style="color:red;">有两个子树</strong>，则用<strong>右子树的最小值</strong>(大于被删除元素的最小值)替代当前节点。</li></ul></li><li>通过旋转、着色等操作将红黑树修正，使之成为新的红黑树。</li></ol><p>根据所替代节点的相关信息来进行调整：</p><p><img src="/2022/01/05/%E7%BA%A2%E9%BB%91%E6%A0%91/RBTreeDelete.png" alt="RBTreeDelete"></p><p>同样的，在循环结束之后，将<strong style="color:red;">当前节点染成黑色</strong>。</p><p>下面给出几个具体样例进行分析：</p><ul><li><p>例一</p><p><img src="/2022/01/05/%E7%BA%A2%E9%BB%91%E6%A0%91/RBTreeDeleteExp1.png" alt="RBTreeDeleteExp1"></p><p>在该样例中，A<strong>节点为黑色</strong>，且是其<strong>父节点的左节点</strong>，<strong>兄弟节点D为红色</strong>，满足调整方案1.1.1。所做出的调整为将其父节点<code>B</code>染成红色，兄弟节点<code>D</code>染成黑色。然后将其父节点<code>B</code>进行左旋。此后均满足条件。</p></li><li><p>例二</p><p><img src="/2022/01/05/%E7%BA%A2%E9%BB%91%E6%A0%91/RBTreeDeleteExp2.png" alt="RBTreeDeleteExp2"></p><p>在该样例中，A<strong>节点为黑色</strong>，且是其<strong>父节点的左节点</strong>，<strong>兄弟节点D为黑色</strong>，两个<strong>侄子节点</strong><code>C</code>和<code>E</code><strong>均为黑色</strong>，满足调整方案1.1.2.1。调整时，将其兄弟结点<code>D</code>染成红色，<code>x</code>已上移为根节点<code>B</code>，循环结束。需要特别注意的是，此刻应再将节点<code>B</code>染成黑色。</p></li><li><p>例三</p><p><img src="/2022/01/05/%E7%BA%A2%E9%BB%91%E6%A0%91/RBTreeDeleteExp3.png" alt="RBTreeDeleteExp3"></p><p>在该样例中，A<strong>节点为黑色</strong>，且是其<strong>父节点的左节点</strong>，<strong>兄弟节点D为黑色</strong>，左侄子<code>C</code>为红色,右侄子<code>E</code>为黑色，满足调整方案1.1.2.2。调整时，将其左侄子<code>C</code>染成黑色，兄弟节点<code>D</code>染成红色，并将兄弟节点D右旋，然后再按照调整方案1.1.2.3进行调整，在此略过。</p></li><li><p>例四</p><p><img src="/2022/01/05/%E7%BA%A2%E9%BB%91%E6%A0%91/RBTreeDeleteExp4.png" alt="RBTreeDeleteExp4"></p><p>在该样例中，A<strong>节点为黑色</strong>，且是其<strong>父节点的左节点</strong>，<strong>兄弟节点D为黑色</strong>，右侄子<code>E</code>为红色，满足调整方案1.1.2.3。调整时，兄弟节点<code>D</code>颜色随父节点<code>B</code>，右侄子<code>E</code>和父节点<code>B</code>染成黑色，将父节点<code>B</code>左旋。</p></li></ul><p>调整方案对应伪代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> x != T.root <span class="keyword">and</span> x.color == BLACK</span><br><span class="line">    <span class="keyword">if</span> x == x.parent.left</span><br><span class="line">w = x.parent.right<span class="comment">//兄弟节点</span></span><br><span class="line">        <span class="keyword">if</span> w.color == RED<span class="comment">// 1.1.1</span></span><br><span class="line">            w.color = BLACK</span><br><span class="line">            x.parent.color = RED</span><br><span class="line">            LEFT-<span class="built_in">ROTATE</span>(T, x.parent)</span><br><span class="line">            w = x.parent.right</span><br><span class="line">        <span class="keyword">if</span> w.left.color == BLACK <span class="keyword">and</span> w.right.color == BLACK<span class="comment">//1.1.2.1</span></span><br><span class="line">            w.color = RED</span><br><span class="line">            x = x.parent</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span> w.right.color == BLACK<span class="comment">//1.1.2.2</span></span><br><span class="line">            w.left.color = BLACK</span><br><span class="line">                w.color = RED</span><br><span class="line">                RIGHT-<span class="built_in">ROTATE</span>(T, w)</span><br><span class="line">               w = x.parent.right</span><br><span class="line">            w.color = x.parent.color<span class="comment">//1.1.2.3</span></span><br><span class="line">            x.parent.color = BLACK</span><br><span class="line">            w.right.color = BLACK</span><br><span class="line">            LEFT-<span class="built_in">ROTATE</span>(T, x.parent)</span><br><span class="line">            x = T.root</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        w = x.parent.left</span><br><span class="line">        <span class="keyword">if</span> w.color == RED<span class="comment">//1.2.2</span></span><br><span class="line">            w.color = BLACK</span><br><span class="line">            x.parent.color = RED</span><br><span class="line">            RIGHT-<span class="built_in">ROTATE</span>(T, x.parent)</span><br><span class="line">            w = x.parent.left</span><br><span class="line">        <span class="keyword">if</span> w.right.color == BLACK <span class="keyword">and</span> w.left.color == BLACK<span class="comment">//1.2.1.1</span></span><br><span class="line">            w.color =RED</span><br><span class="line">            x = x.parent</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span> w.left.color == BLACK<span class="comment">//1.2.1.2</span></span><br><span class="line">                w.right.color = BLACK</span><br><span class="line">                w.color = RED</span><br><span class="line">                LEFT-<span class="built_in">ROTATE</span>(T, w)</span><br><span class="line">            w.color = x.parent.color<span class="comment">//1.2.1.3</span></span><br><span class="line">            x.parent.color = BLACK</span><br><span class="line">            w.left.color = BLACK</span><br><span class="line">   RIGHT-<span class="built_in">ROTATE</span>(T, x.parent)</span><br><span class="line">            x = T.root</span><br><span class="line">x.color = BLACK</span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>红黑树插入、删除节点的情况虽然复杂，但基本处于<strong>对称</strong>情况，且有一个模型通过拼凑其他模型来实现。本文中的伪代码、样例均选自《算法导论》，红黑树的图采用<a href="https://draw.io/">drawio</a>绘制。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h1&gt;&lt;p&gt;由于二叉搜索树很不平衡，很容易退化为一条类似链表的结构，从而造成时间复杂度从$O(lgN)$降低为$O(N)$。&lt;/p&gt;
&lt;p&gt;为解决这一问题，引入了&lt;strong&gt;“平衡”二叉搜索树&lt;/strong&gt;，红黑树就是其中的一种。红黑树在树的基础上，为每个节点增加了一个&lt;strong&gt;颜色位&lt;/strong&gt;，可以是&lt;code&gt;RED&lt;/code&gt;，也可以是&lt;code&gt;BLACK&lt;/code&gt;。通过对每条路径的颜色进行约束，保证红黑树处于&lt;strong style=&quot;color:#e67c86;&quot;&gt;近似平衡&lt;/strong&gt;的状态，从而保证了查找最坏情况为$O(lgN)$。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数据结构&amp;算法" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>左孩子右兄弟树</title>
    <link href="http://example.com/2022/01/04/%E5%B7%A6%E5%AD%A9%E5%AD%90%E5%8F%B3%E5%85%84%E5%BC%9F%E6%A0%91/"/>
    <id>http://example.com/2022/01/04/%E5%B7%A6%E5%AD%A9%E5%AD%90%E5%8F%B3%E5%85%84%E5%BC%9F%E6%A0%91/</id>
    <published>2022-01-04T12:46:21.000Z</published>
    <updated>2022-01-21T06:34:02.982Z</updated>
    
    <content type="html"><![CDATA[<p>在二叉树的基础上，我们可以扩展出任意多个叉的树。即，多叉树。然而，此时又面临着另外一个问题：</p><ul><li>当孩子结点无限制时，我们并不知道<strong>预先要分配多少个属性</strong>，且当<strong>仅有少数元素拥有多个子节点</strong>时，将会造成大量的空间浪费。</li></ul><p>此时，提出了一种新的表示形式:</p><p>$left-child \quad right-sibling \quad representation$。</p><span id="more"></span><h1 id="左孩子右兄弟表示法"><a href="#左孩子右兄弟表示法" class="headerlink" title="左孩子右兄弟表示法"></a>左孩子右兄弟表示法</h1><p>对于任意一个结点T，其仅包含两个指针：</p><ol><li><code>T.left-child</code>，指向T结点的最左侧子节点。</li><li><code>T.right-sibling</code>，指向T右侧最邻近的兄弟结点。</li></ol><p>特别的，当二者不存在时，相应的指针皆为空，即<code>NIL</code>。该方法只需要$O(n)$空间来存储含$n$个结点的树。</p><p>由于其与二叉树的相似性，故又叫<code>树的二叉树表示法</code>。</p><p>在此，给出一个样例：</p><p><img src="/2022/01/04/%E5%B7%A6%E5%AD%A9%E5%AD%90%E5%8F%B3%E5%85%84%E5%BC%9F%E6%A0%91/LchildRsiblingTree.png" alt="LchildRsiblingTree"></p><p>该样例旨在为下述算法提供一个参考。</p><h1 id="相关算法"><a href="#相关算法" class="headerlink" title="相关算法"></a>相关算法</h1><h2 id="深度"><a href="#深度" class="headerlink" title="深度"></a>深度</h2><p>对于该种树而言，任意一个节点和其右节点的深度相同。也就意味着对于一个节点T，其高度为要么<strong>和右子树高度相同</strong>，要么<strong>比左子树低一层</strong>。从叶子节点向上递归，即可得出最大深度。即：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Height</span><span class="params">(Tree&amp; t)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(t == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Height</span>(t-&gt;left) + <span class="number">1</span> &gt; <span class="built_in">Height</span>(t-&gt;right) ? <span class="built_in">Height</span>(t-&gt;left) + <span class="number">1</span> : <span class="built_in">Height</span>(t-&gt;right);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="叶子节点数"><a href="#叶子节点数" class="headerlink" title="叶子节点数"></a>叶子节点数</h2><p>基于二叉树中的定义，<strong>叶子节点</strong>是没有子节点的节点。在该种表示方法中，即<strong>左指针为空</strong>的节点（某一层的最后一个叶子节点右子树也为空，故只看左指针就行）。对于一个节点的叶子节点数，即：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Count</span><span class="params">(Tree&amp; t)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(t == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(t-&gt;left == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Count</span>(t-&gt;left) + <span class="built_in">Count</span>(t-&gt;right); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><p>先序遍历，对于某个节点而言，其<strong>左指针</strong>为<strong>第一个子节点</strong>。向左指针递归即寻找孩子，回溯时输出右指针的兄弟。与二叉树的先序遍历完全一致。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Tree&amp; t)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(t == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">cout&lt;&lt;t-&gt;val&lt;&lt;<span class="string">&quot; &quot;</span>;<span class="comment">//输出值</span></span><br><span class="line">TreeNode* p = t-&gt;left;</span><br><span class="line"><span class="keyword">while</span>(p != <span class="literal">nullptr</span>)&#123;</span><br><span class="line"><span class="built_in">preOrder</span>(p);</span><br><span class="line">p = p-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>后序遍历过程中，对于一个节点，应该打印其左指针和全部右侧的节点后才打印该节点，即回溯时才打印当前节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(Tree&amp; t)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(t == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">TreeNode* p = t-&gt;left;</span><br><span class="line"><span class="keyword">while</span>(p != <span class="literal">nullptr</span>)&#123;</span><br><span class="line"><span class="built_in">PostOrder</span>(p); <span class="comment">//递归找“根”</span></span><br><span class="line">p = p-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;t-&gt;val&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>层序遍历，即类似于广度优先算法。对于一个节点，当打印左节点时，应将其右侧所有兄弟节点都打印再去下一层。打印其兄弟节点时，保留其左节点，即其子节点的兄弟。基于此，也可统计出每层的<strong>宽度</strong>。有注释的几行即为相应的宽度统计。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(Tree&amp; t)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(t == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">queue&lt;TreeNode*&gt; q;</span><br><span class="line">TreeNode* p;</span><br><span class="line">    <span class="keyword">int</span> max = INT_MIN; <span class="comment">//宽度</span></span><br><span class="line">q.<span class="built_in">push</span>(t);</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line"><span class="keyword">int</span> width = q.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; width;i ++)&#123;</span><br><span class="line">p = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">cout&lt;&lt;p-&gt;val&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">p = p-&gt;left;</span><br><span class="line"><span class="keyword">while</span>(p != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">q.<span class="built_in">push</span>(p);</span><br><span class="line">p = p-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        max = max &gt; width ? max: width;        <span class="comment">//一层遍历结束 统计宽度</span></span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> max;<span class="comment">//返回宽度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在二叉树的基础上，我们可以扩展出任意多个叉的树。即，多叉树。然而，此时又面临着另外一个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当孩子结点无限制时，我们并不知道&lt;strong&gt;预先要分配多少个属性&lt;/strong&gt;，且当&lt;strong&gt;仅有少数元素拥有多个子节点&lt;/strong&gt;时，将会造成大量的空间浪费。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此时，提出了一种新的表示形式:&lt;/p&gt;
&lt;p&gt;$left-child \quad right-sibling \quad representation$。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数据结构&amp;算法" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2021/12/29/hello-world/"/>
    <id>http://example.com/2021/12/29/hello-world/</id>
    <published>2021-12-29T04:53:28.888Z</published>
    <updated>2022-01-11T11:15:16.243Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>正如学编程语言时首个程序是<code>Hello World!</code>一样，本blog亦是如此。</p><p>该网站旨在分享一些生活的点滴及秋招的经历。最初是在微信公众号分享，奈何修改、发表过于繁琐。后来尝试过csdn，但一些不可描述的原因又将我劝退，最终决定自己搭建网站。</p><p>当然了，建站还有一个很重要的原因是——装逼。</p><span id="more"></span><h1 id="残局"><a href="#残局" class="headerlink" title="残局"></a>残局</h1><p>endgame,残局。</p><p>csgo可谓是电子竞技中最精彩的赛事之一，他的精彩就表现在残局众多。残局，是一场比赛中最精彩、最充满期待同时也是有着最多遗憾的时刻。精彩在会有一个力挽狂澜、扭转乾坤的人出现；遗憾在纵使他的某次发挥再流传千古，可终究改变不了逆局。而此时此刻，恰如彼时彼刻。</p><h1 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h1><p>钱都花了，也该有点相应的规划。预想着在本网站发布一些算法刷题的经历、八股、面经以及将来实习、工作的经历，还有一些日常生活中的点滴（许久没学习的时候，水个内容）。当然了，还有另外一种可能——几天之后，<strong style="color:#e67c86;">删库跑路</strong>。</p><p>另外，还建了个<a href="https://qm.qq.com/cgi-bin/qm/qr?k=s6ItnVGSSFQaS53il_Oc3490nQvfrs6S&jump_from=webapi">QQ群</a>来分享一些相关的书籍，有兴趣的话可以来逛逛。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>奈何，本人才疏学浅，能力有限再加上语言表达能力不是很好，文章中难免会有些地方表达欠缺难以理解，甚至与事实相悖。遇到这种情况时，还望您能轻点骂，骂完能帮忙指出错误，避免我这一己之见误导了他人。网站里，留下了我的<a href="mailto:lyong000919@163.com">邮箱</a>及<a href="tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=1992018857&website=www.oicqzone.com">QQ</a>，如果您在阅读时有疑问、发现了错误又或者觉得这个人写的还可以，想交个朋友，欢迎联系我。</p><p>最后，为给您带来的不良阅读体验致歉。(本人亲测在<code>DARK REDAER</code>插件下图片阅读感极差，代码块的兼容性也较差)</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;正如学编程语言时首个程序是&lt;code&gt;Hello World!&lt;/code&gt;一样，本blog亦是如此。&lt;/p&gt;
&lt;p&gt;该网站旨在分享一些生活的点滴及秋招的经历。最初是在微信公众号分享，奈何修改、发表过于繁琐。后来尝试过csdn，但一些不可描述的原因又将我劝退，最终决定自己搭建网站。&lt;/p&gt;
&lt;p&gt;当然了，建站还有一个很重要的原因是——装逼。&lt;/p&gt;</summary>
    
    
    
    
    <category term="关于我" scheme="http://example.com/tags/%E5%85%B3%E4%BA%8E%E6%88%91/"/>
    
  </entry>
  
</feed>
