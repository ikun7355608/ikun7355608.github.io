<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="本文是我在学习候捷《面向对象高级开发》课程时所做的笔记，在此分享给大家。">
<meta property="og:type" content="article">
<meta property="og:title" content="面向对象">
<meta property="og:url" content="http://example.com/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/index.html">
<meta property="og:site_name" content="残局">
<meta property="og:description" content="本文是我在学习候捷《面向对象高级开发》课程时所做的笔记，在此分享给大家。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20220611144047216.png">
<meta property="og:image" content="http://example.com/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/malloc+new.png">
<meta property="og:image" content="http://example.com/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/free+delete.png">
<meta property="og:image" content="http://example.com/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/delete.png">
<meta property="article:published_time" content="2022-05-05T11:00:12.000Z">
<meta property="article:modified_time" content="2023-07-07T09:49:19.609Z">
<meta property="article:author" content="某卑微社畜">
<meta property="article:tag" content="八股">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20220611144047216.png">

<link rel="canonical" href="http://example.com/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>面向对象 | 残局</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="残局" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">残局</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">没有故事，不会喝酒。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="某卑微社畜">
      <meta itemprop="description" content="爱过">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="残局">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面向对象
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-05 19:00:12" itemprop="dateCreated datePublished" datetime="2022-05-05T19:00:12+08:00">2022-05-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-07 17:49:19" itemprop="dateModified" datetime="2023-07-07T17:49:19+08:00">2023-07-07</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本文是我在学习候捷《面向对象高级开发》课程时所做的笔记，在此分享给大家。</p>
<span id="more"></span>

<h2 id="基于对象"><a href="#基于对象" class="headerlink" title="基于对象"></a>基于对象</h2><p>类从思考方式上大致分为两类</p>
<ul>
<li>不带指针。（complex）复数。内容在创建的时候已经是确定的（实部、虚部及相关的函数）</li>
<li>带指针。（string）字符串。只存了指针，当需要添加内容时，需要额外的创建空间。</li>
</ul>
<h3 id="设计重点"><a href="#设计重点" class="headerlink" title="设计重点"></a>设计重点</h3><ol>
<li>成员变量必须为private</li>
<li>参数尽可能的使用<mark>引用传递</mark>（const与否看情况）</li>
<li>尽可能的将<mark>返回值以引用形式</mark>传递</li>
<li>类本体里面注意应该加const的地方</li>
<li>尽量使用构造函数的初始化形式。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> _a,<span class="keyword">int</span> _b) : <span class="built_in">a</span>(_a),<span class="built_in">b</span>(_b) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基于对象-amp-amp-面向对象"><a href="#基于对象-amp-amp-面向对象" class="headerlink" title="基于对象 &amp;&amp; 面向对象"></a>基于对象 &amp;&amp; 面向对象</h3><p>Object-Based。设计<mark>单一</mark>的class。<br>Object-Oriented。面对多个class，涉及class与class的关系。</p>
<h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p>防卫式声明（guard）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __xxxx__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __xxxx__</span></span><br><span class="line">.......</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>只有再第一次包含头文件时，才会导入库。</p>
<h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p>在头文件里，大致分为三个部分。</p>
<ol>
<li>前置声明</li>
<li>类-声明</li>
<li>类-定义</li>
</ol>
<h3 id="私有构造函数"><a href="#私有构造函数" class="headerlink" title="私有构造函数"></a>私有构造函数</h3><p>当把构造函数设置在private区域时，表示该类不允许被创建对象。（设计模式-Singleton）</p>
<h3 id="function-const"><a href="#function-const" class="headerlink" title="function() const {}"></a>function() const {}</h3><p>设计不会改变数据内容的成员函数时（如：打印private成员变量），声明为const</p>
<h3 id="同一class的各个object互为friend"><a href="#同一class的各个object互为friend" class="headerlink" title="同一class的各个object互为friend"></a>同一class的各个object互为friend</h3><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>在实现运算符重载时，可以按照<code>(int)(30+10.5)</code>的形式，来强制转成类的临时对象。（该行运行结束即销毁）<code>Complex(5,4)</code></p>
<h3 id="拷贝构造"><a href="#拷贝构造" class="headerlink" title="拷贝构造"></a>拷贝构造</h3><p>类不写拷贝构造函数及拷贝赋值的话，会默认按bit进行拷贝。（带指针的类，需要自己去写）<br>如果没有写，只是复制了个指针（指针才是类内部的东西，字符数组是动态分配的）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用默认拷贝</span></span><br><span class="line">    <span class="function">String <span class="title">a</span><span class="params">(<span class="string">&quot;HELLO&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">b</span><span class="params">(<span class="string">&quot;WORLD&quot;</span>)</span></span>;</span><br><span class="line">    b = a;</span><br></pre></td></tr></table></figure>

<p>上述代码中，对象a的指针指向<code>HELLO</code>，对象b的指针指向<code>WORLD</code>，当执行b=a时，对象b拷贝对象a，两个对象的指针都指向原来对象a所指向的<code>HELLO</code>地址（浅拷贝），而<code>WORLD</code>所在地址已经造成内存泄漏。</p>
<h3 id="拷贝赋值"><a href="#拷贝赋值" class="headerlink" title="拷贝赋值"></a>拷贝赋值</h3><p>拷贝赋值时，要加上自我赋值检测（自我赋值delete-&gt;new时，delete删掉了相应的数据，无法new相同空间及拷贝内容）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span> == &amp;str)</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br></pre></td></tr></table></figure>

<h3 id="new-delete"><a href="#new-delete" class="headerlink" title="new/delete"></a>new/delete</h3><p>有<code>[]</code>的new要搭配有<code>[]</code>的delete使用。中括号表示的是数组(array)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * ptr = <span class="keyword">new</span> <span class="keyword">int</span>[];</span><br><span class="line"><span class="keyword">delete</span>[] ptr;</span><br></pre></td></tr></table></figure>

<p>有没有[]不影响这一个对象数组在内存中的删除，而是 有[]是表示删除整个数组，根据元素个数，调用多次分别释放各自动态分配的内存。而是数组中后面的指针所分配的内存没有被释放。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String* p = <span class="keyword">new</span> String[<span class="number">3</span>];</span><br><span class="line">......</span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure>

<p>上述代码中，有无[].3个String所占的内存都会被释放，而有[]会调用3次析构函数，即3个String对象中指针所指向的内存都会被释放，而delete只会调用一次析构函数，String[1],String[2]这两个对象中的指针所指向的内存并没有被释放。</p>
<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>静态变量要在类外进行定义（类内的static进行声明，不属于对象）。<br>多个对象的成员函数<mark>只有一份</mark><br>加在数据成员、成员函数前，表示为静态。所有对象<mark>共用</mark>一个<strong>静态</strong>成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt;c1.<span class="built_in">real</span>();</span><br><span class="line">cout &lt;&lt;c2.<span class="built_in">real</span>();</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">cout &lt;&lt;Complex::<span class="built_in">real</span>(&amp;c1);</span><br><span class="line">cout &lt;&lt;Complex::<span class="built_in">real</span>(&amp;c2);</span><br></pre></td></tr></table></figure>

<p>非静态的成员，以<code>this pointer</code>的形式去传，指针地址不同，调用不同的对象。<br>而静态的成员，属于类，是类负责存储。<mark>没有</mark><code>this pointer</code><br>e.g:银行系统，利率设置为静态。利息结算函数去处理静态的变量（利率）。<br>可以通过对象去调用静态变量，也可以通过类名直接调用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> m_rate;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set_rate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; x)</span> </span>&#123;m_rate = x;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> Account::m_rate = <span class="number">5</span>; <span class="comment">//类外进行初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Account::<span class="built_in">set_rate</span>(<span class="number">3</span>); <span class="comment">//通过类名调用</span></span><br><span class="line">    Account a; a.<span class="built_in">set_rate</span>(<span class="number">6</span>); <span class="comment">//通过对象调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复合（Composition）"><a href="#复合（Composition）" class="headerlink" title="复合（Composition）"></a>复合（Composition）</h3><p>比如 队列、栈是基于双端队列来设计的。故队列、栈内部会包含双端队列这个类（内部存有其他数据结构）这个概念叫做复合。一些共用的功能，可以直接返回其底层容器的东西（empty()、size()函数），不需要的功能可以不开放，不引入进来（设计模式–Adapter）<br> Adapter是改装后的，不是被改装者。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">queue</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    deque&lt;T&gt; deq;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        deq.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="container-amp-component"><a href="#container-amp-component" class="headerlink" title="container &amp;component"></a>container &amp;component</h4><p>在上述过程中，container为队列（继承者），component为双端队列（被继承者）<br>Container构造时，先构造Component的构造函数，再构造自己的。析构时则相反。先调用自己的析构函数，再调用Component的析构函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Container::<span class="built_in">Container</span>(...):<span class="built_in">Component</span>()(......)</span><br><span class="line">Container::~<span class="built_in">Container</span>(...)&#123;......~<span class="built_in">Component</span>()&#125;</span><br><span class="line"><span class="comment">//上述代码中 六个点表示Container相应函数的实现</span></span><br></pre></td></tr></table></figure>

<h3 id="委托（Delegation）"><a href="#委托（Delegation）" class="headerlink" title="委托（Delegation）"></a>委托（Delegation）</h3><p>又叫 Composition by reference。<br>某个类的内部，成员变量中含有另一个类的对象的指针。（想用那个类的函数时，可以直接通过指针调用另一个类的函数，即将该功能委托给另一个类）。</p>
<p>Handle/Body<br>衍生设计模式：<br>    * 类的对外接口在该类内部实现，类的底层在被委托者里具体实现。</p>
<p>好处：对外接口不变，内部通过指针指向不同的实现类，从而改变底层。（底层变动不影响接口，从而不影响客户端。）即，底层改变时，编译时候只需要编译底层，不需要编译对外接口等。（节省时间）<br>而且可以多个不同的对外接口文件共用同一份底层代码。</p>
<h3 id="Composition-amp-Delegation"><a href="#Composition-amp-Delegation" class="headerlink" title="Composition &amp; Delegation"></a>Composition &amp; Delegation</h3><ul>
<li>生命周期不同<ul>
<li>Composition直接涵盖另一个类的源码，二者同生共死。</li>
<li>Delegation中另一个类对象的指针，只有调用时才创建。</li>
</ul>
</li>
</ul>
<h3 id="继承-amp-amp-虚函数"><a href="#继承-amp-amp-虚函数" class="headerlink" title="继承&amp;&amp;虚函数"></a>继承&amp;&amp;虚函数</h3><p>成员函数+virtual关键字。继承函数是继承的<mark>调用权</mark><br>设计模式（Template Method)。比如 各种软件打开文件功能，其打开步骤都是相似的（打开对话框、选择文件、检查文件是否存在、在磁盘里读取）这些基础动作基本相同，不同的是以什么形式读取。可以直接封装一个类实现这些基础功能，读取的具体实现，取决于软件继承这个类后去重写。这个东西也叫作Application framework。（应用框架），微软MFC是一个典型例子。</p>
<h3 id="继承-复合构造析构的顺序"><a href="#继承-复合构造析构的顺序" class="headerlink" title="继承+复合构造析构的顺序"></a>继承+复合构造析构的顺序</h3><p>派生类Component其余类对象时，派生类的构造/析构次序：<code>基类构造-&gt;复合类构造-&gt;自身构造</code>， <code>自身析构-&gt;复合类析构-&gt;基类析构。</code></p>
<h3 id="继承-委托"><a href="#继承-委托" class="headerlink" title="继承+委托"></a>继承+委托</h3><p>设计模式（Observer)某个文件内部包括多个查看操作的委托，该文件支持多个人同时查看。（内部可以增加注册、注销等功能以便于管理。）</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="实现对象和非对象的运算"><a href="#实现对象和非对象的运算" class="headerlink" title="实现对象和非对象的运算"></a>实现对象和非对象的运算</h3><h4 id="conversion-function"><a href="#conversion-function" class="headerlink" title="conversion function"></a>conversion function</h4><p>类对象—&gt;非类的对象<br>转换函数conversion function。（比如分数类，实现分数和小数的转换）<br>以<code>operator</code>开头，函数名为返回值类型。不需要写返回值类型。也不需要参数。通常加上<code>const</code>(因为不需要改变内容)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Frac</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Frac</span>(<span class="keyword">double</span> _y, <span class="keyword">double</span> _x) : <span class="built_in">x</span>(_x), <span class="built_in">y</span>(_y)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>)y / x;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>至此，可以用一个数字去这个分数类进行运算。（无需重载运算符）</p>
<h4 id="non-explicit-one-argument-ctor"><a href="#non-explicit-one-argument-ctor" class="headerlink" title="non-explicit-one-argument ctor"></a>non-explicit-one-argument ctor</h4><p>非类的对象—&gt;类对象<br>non-explicit-one-argument ctor。要重载运算符。（整数默认分母是1，可以使得分母默认为1，只输入一个实参便可以）如果只写了分数间加法时，当调用分数+小数（整数）时，会调用相应的构造函数转换成分数再加。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Frac</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Frac</span>(<span class="keyword">double</span> _y, <span class="keyword">double</span> _x = <span class="number">1</span>) : <span class="built_in">x</span>(_x), <span class="built_in">y</span>(_y) &#123;&#125;</span><br><span class="line">    Frac <span class="keyword">operator</span>+(<span class="keyword">const</span> Frac &amp;f) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Frac</span>(...);</span><br><span class="line">        <span class="comment">//...为具体实现的方式</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>non-explicit-one-argument ctor与转换函数并存会产生二义性，报错。</li>
</ul>
<h4 id="explicit-one-argument-ctor"><a href="#explicit-one-argument-ctor" class="headerlink" title="explicit-one-argument ctor"></a>explicit-one-argument ctor</h4><p>explicit关键字放在<mark>构造函数前</mark>，告诉编译器，不会将非对象的参数转换为对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Frac</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Frac</span><span class="params">(<span class="keyword">double</span> _y, <span class="keyword">double</span> _x = <span class="number">1</span>)</span> : x(_x), y(_y) &#123;</span>&#125;</span><br><span class="line">    Frac <span class="keyword">operator</span>+(<span class="keyword">const</span> Frac &amp;f) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Frac</span>(...);</span><br><span class="line">        <span class="comment">//...为具体实现的方式</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//运行会报错。</span></span><br></pre></td></tr></table></figure>

<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>cpp的类大致分为两类，类的对象长得像指针的，长得像函数的。</p>
<h4 id="pointer-like-class"><a href="#pointer-like-class" class="headerlink" title="pointer-like class"></a>pointer-like class</h4><p>像指针的类。内部一定含有指针，实现一些比指针更高级的功能(智能指针)。作用在指针上的运算符(<code>*</code> 、 <code>-&gt;</code>等)要进行重载。<br>shared_ptr(智能指针)、 iterator(迭代器)</p>
<ul>
<li>shared_ptr。在不同类中，实现基本一致。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shared_ptr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T &amp;<span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> *px;</span><br><span class="line">    &#125;</span><br><span class="line">    T &amp;<span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> px;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">shared_ptr</span>(T *ptr) : <span class="built_in">px</span>(ptr)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *px;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">shared_ptr&lt;Foo&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> Foo)</span></span>;</span><br><span class="line"><span class="function">Foo <span class="title">f</span><span class="params">(*sp)</span></span>;</span><br><span class="line">sp-&gt;<span class="built_in">function</span>(); <span class="comment">// &lt;==&gt;  px-&gt;function();</span></span><br></pre></td></tr></table></figure>

<ul>
<li>iterator。根据功能不同会改动，且会重载其他运算符（如 自增、自减）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Ref</span>, <span class="keyword">class</span> <span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">list_iterator</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> __list_iterator&lt;T, Ref, Ptr&gt; self;</span><br><span class="line">    <span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">    <span class="keyword">typedef</span> Ref reference;</span><br><span class="line">    <span class="keyword">typedef</span> __list_node&lt;T&gt; *link_type;</span><br><span class="line">    link_type node;</span><br><span class="line">    ... </span><br><span class="line">    reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> (*node).data; &#125;</span><br><span class="line">    pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">list&lt;Foo&gt;::iterator iter;</span><br><span class="line">*iter; <span class="comment">//获取Foo对象</span></span><br><span class="line">iter-&gt;<span class="built_in">function</span>();    <span class="comment">//调用Foo::function();</span></span><br><span class="line"><span class="comment">// iter-&gt;function() &lt;==&gt; *(iter).function() &lt;==&gt; (&amp;(*iter))-&gt;function()</span></span><br></pre></td></tr></table></figure>


<h4 id="function-like-class"><a href="#function-like-class" class="headerlink" title="function-like class"></a>function-like class</h4><p>像函数的类。仿函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">identity</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> T &amp;<span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T &amp;x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">select1st</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">typename</span> Pair::first_type &amp;<span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Pair &amp;x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x.first; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">select2nd</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">typename</span> Pair::second_type &amp;<span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Pair &amp;x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x.second; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h3><p>命名空间。用于分隔开不同开发团队的成果（防止名字冲突，具有二义性）</p>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><h4 id="class-template"><a href="#class-template" class="headerlink" title="class template"></a>class template</h4><p>类模板。参考复数类。成员变量类型、成员函数的返回值类型可以用模板替换。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="keyword">double</span> x, <span class="keyword">double</span> y) : <span class="built_in">re</span>(x), <span class="built_in">im</span>(y)&#123;&#125;</span><br><span class="line">    <span class="built_in">Complex</span>() : <span class="built_in">re</span>(<span class="number">0</span>), <span class="built_in">im</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="function">T <span class="title">real</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> re; &#125;</span><br><span class="line">    <span class="function">T <span class="title">imag</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> im; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T re, im;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Complex&lt;<span class="keyword">int</span>&gt; <span class="title">c</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="function-template"><a href="#function-template" class="headerlink" title="function template"></a>function template</h4><p>函数模板。有一些函数，所实现的功能很通用。可以直接封装成函数模板。（一些其他类重载运算符）编译器会根据传入值自动推导相应的类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">const</span> T&amp; <span class="title">min</span> <span class="params">(cosntT&amp; a,constT&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? b : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="member-function"><a href="#member-function" class="headerlink" title="member function"></a>member function</h4><p>成员模板。模板里面嵌套模板。常用于标准库中，用某一个数据类型的变量来初始化另一个数据类型的变量。<br>比如，现在封装了一个鱼类，以及一个鲫鱼类。<br>我们声明了一个鲫鱼对象，用他去初始化一个鱼类对象。（构造函数更有弹性）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pair</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T1 first_type;</span><br><span class="line">    <span class="keyword">typedef</span> T2 second_type;</span><br><span class="line">    T1 first;</span><br><span class="line">    T2 second;</span><br><span class="line">    <span class="built_in">pair</span>() : <span class="built_in">first</span>(<span class="built_in">T1</span>()), <span class="built_in">second</span>(<span class="built_in">T2</span>())&#123;&#125;</span><br><span class="line">    <span class="built_in">pair</span>(<span class="keyword">const</span> T1 &amp;a, <span class="keyword">const</span> T2 &amp;b) : <span class="built_in">first</span>(a), <span class="built_in">second</span>(b)&#123;&#125;</span><br><span class="line">    <span class="function">temppalte&lt;class U1, classU2&gt;</span></span><br><span class="line"><span class="function">    <span class="title">pair</span><span class="params">(<span class="keyword">const</span> pair&lt;U1, U2&gt; &amp;p)</span> : first(p.first), second(p.second)&#123;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="模板特化"><a href="#模板特化" class="headerlink" title="模板特化"></a>模板特化</h3><p>specialization。通过模板实现了泛化，而其中一些东西可能并不太适用，会有些不同，需要特殊处理（特化）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过模板泛化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&#123;</span>&#125;;</span><br><span class="line"><span class="comment">//当输入类型为指定类型时，进行特化处理</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;</span><span class="keyword">char</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">char</span> x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;</span><span class="keyword">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span> * x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="偏特化"><a href="#偏特化" class="headerlink" title="偏特化"></a>偏特化</h3><p>局部特化，可以从个数、范围上产生差异。</p>
<ul>
<li>个数。比如模板的参数有2个，可以绑定部分参数。（bool类型用特定的底层做容器容易浪费，偏特化处理）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> Alloc=...&gt;</span><br><span class="line">class vector</span><br><span class="line">&#123;</span><br><span class="line">    ...<span class="comment">//具体实现略</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Alloc=...&gt;</span><br><span class="line">class vector&lt;<span class="keyword">bool</span>,Alloc&gt;</span><br><span class="line">&#123;</span><br><span class="line">    ...<span class="comment">//具体实现略</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>范围。模板支持任意类型，偏特化为 任意指针类型。（其余类型使用泛化模板，指针使用偏特化）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...<span class="comment">//具体实现略</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>&lt;</span>T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">    ...<span class="comment">//具体实现略</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="模板模板参数"><a href="#模板模板参数" class="headerlink" title="模板模板参数"></a>模板模板参数</h3><p>模板的一个参数也为模板。用来初始化时，容器实现底层所采用的数据类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Container</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="variadic-templates"><a href="#variadic-templates" class="headerlink" title="variadic templates"></a>variadic templates</h3><p>模板参数可变化。允许写任意个数的模板参数(用<code>...</code>来省略)(每次都分为<code>1 + n</code>进行运行)通过<code>sizeof...()</code>函数获取<code>n</code>值。</p>
<p>以下代码调用时，可以一直递归为<code>1 + n</code>直至运行<code>1 + 0</code>全部运行完，程序结束。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//最后的0个参数时调用的函数，用来退出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Types&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> T&amp; firstArg,<span class="keyword">const</span> Types&amp;...args)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; firstArg &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">print</span>(args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><p>自动推导相应的数据类型。比如容器的迭代器，写起来过长可以直接<code>auto</code>让编译器<mark>根据返回值类型</mark>自动推导相应的类型。再比如lambda表达式返回值比较复杂，可以auto推导。</p>
<h3 id="for-decl-coll"><a href="#for-decl-coll" class="headerlink" title="for(decl:coll)"></a>for(decl:coll)</h3><p>另一种遍历的形式。每次从右边的容器中取出值赋给左边的变量。默认为值传递，不会改变原来值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;::iterator iter = vec.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">auto</span> iter = vec.<span class="built_in">begin</span>();</span><br></pre></td></tr></table></figure>

<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用，给变量取一个别名，取出后可以去修改。<br>变量和其引用大小相同，地址相同。<br>指针可以重新指向其他元素，而引用一旦确定不能变。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;x;</span><br><span class="line"><span class="keyword">int</span> &amp;r = x;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">5</span>;</span><br><span class="line">p = y;    <span class="comment">//指针p指向了y 再赋值改变的是y值，不会影响x。</span></span><br><span class="line">r = y;    <span class="comment">//用y的值给r赋值 r = 5 x  = 5;</span></span><br></pre></td></tr></table></figure>

<p>指针传递、值传递、引用传递中，指针和引用可以改原始值，三者调用对象的方式有些差异。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(Cls *pobj)</span> </span>&#123; pobj-&gt;<span class="built_in">function</span>(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(Cls obj)</span> </span>&#123; obj.<span class="built_in">function</span>(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">(Cls &amp;obj)</span> </span>&#123; obj.<span class="built_in">function</span>(); &#125;</span><br></pre></td></tr></table></figure>

<p>同名同类型一个值传递、一个引用传递的函数不能重载。（二义性）但一个<code>const</code>一个非const可以并存。</p>
<h3 id="虚指针-amp-虚表"><a href="#虚指针-amp-虚表" class="headerlink" title="虚指针&amp;虚表"></a>虚指针&amp;虚表</h3><p>vptr &amp; vtbl。只要有虚函数，类内部就会有出现<mark>一个</mark>指针。虚指针用来指向虚表中的<mark>函数指针</mark>指向虚函数的地址。未重写的虚函数，基类和派生类共用。重写了的，各自虚表中指向重写后的地址。<br>下列代码中存在一些问题，可以不必纠结。（为了方便理解）。<br>通过指针，向上转型，指向虚函数。<code>(*p-&gt;vptr[n])(p)</code><br><img src="/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20220611144047216.png" alt="vptr+vtbl"></p>
<h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p>通过对象调用函数时，对象的地址传<code>this</code>指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">&#125;;</span><br><span class="line">B b;</span><br><span class="line">A::<span class="built_in">func</span>(&amp;b); </span><br><span class="line">b.<span class="built_in">func</span>(); <span class="comment">//等价 </span></span><br><span class="line"><span class="comment">//this指针为&amp;b</span></span><br></pre></td></tr></table></figure>

<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>非const对象可以调用所有的成员函数，const对象只能调用const成员函数。当成语函数const和非cosnt同时存在时，const对象只能调用const函数，非const对象只能调用非const函数。</p>
<h3 id="operator-new-delete"><a href="#operator-new-delete" class="headerlink" title="operator new/delete"></a>operator new/delete</h3><p>是运算符，可以重载。（全局，类内部 都可以）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span> size);</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* ptr)</span></span>;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> *<span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span>* ptr);</span><br></pre></td></tr></table></figure>

<h3 id="重载new-delete"><a href="#重载new-delete" class="headerlink" title="重载new/delete"></a>重载new/delete</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> _id;</span><br><span class="line">    <span class="keyword">long</span> _data;</span><br><span class="line">    string _str;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>() : _id(<span class="number">0</span>) &#123; cout &lt;&lt; <span class="string">&quot;default ctor.this&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;id=&quot;</span> &lt;&lt; _id &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="keyword">int</span> i):_id(i) &#123; cout &lt;&lt; <span class="string">&quot;ctor.this&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;id=&quot;</span> &lt;&lt; _id &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">Foo</span>() &#123; cout &lt;&lt; <span class="string">&quot;dtor.this&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;id=&quot;</span> &lt;&lt; _id &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span> size);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* Foo::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    Foo *p = (Foo *)<span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> Foo::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span>* Foo::<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span> size) &#123;</span><br><span class="line">    Foo *p = (Foo *)<span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Foo::<span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size) &#123;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 优先从类成员函数调用，如果没有就用全局。</span></span><br><span class="line">Foo *pf = <span class="keyword">new</span> Foo;</span><br><span class="line"><span class="keyword">delete</span> pf;</span><br><span class="line"><span class="comment">//默认使用全局函数</span></span><br><span class="line">Foo *pf = ::<span class="keyword">new</span> Foo;</span><br><span class="line">::<span class="keyword">delete</span> pf;</span><br></pre></td></tr></table></figure>

<h3 id="重载new-delete-1"><a href="#重载new-delete-1" class="headerlink" title="重载new(),delete()"></a>重载new(),delete()</h3><p>new()可以重载出多个版本，但第一参数必须为<code>size_t</code>。同时也可以重载对应的delete()，但其不会被调用。只有在new()抛出异常才会调用delete()</p>
<h3 id="new-amp-amp-delete"><a href="#new-amp-amp-delete" class="headerlink" title="new &amp;&amp; delete"></a>new &amp;&amp; delete</h3><p>二者对于基本数据类型的操作基本没有差异，而当为类的对象分配空间时，会有一些区别。<br>以下是候捷老师课程中关于malloc/new区别的代码以更好的区分二者。<br><img src="/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/malloc+new.png" alt="malloc+new"><br>假设我们现在已经有一个复数类，当我们用new进行分配时，首先自动获取对象所占空间，执行<code>operator new</code>，在其内部调用malloc分配相应的大小。然后调用<code>static_cast</code>显式的进行强制类型转换。最终再执行类的构造函数。<br>从图中，我们可以看出二者的一些区别：</p>
<ol>
<li>new无需强制类型转换和指定分配的大小，而malloc需要。</li>
<li>new为一个对象开辟空间时，会调用构造函数，而malloc不会。(故，malloc为对象申请空间时，一些在构造函数里的初始化操作无法执行。)</li>
</ol>
<h3 id="free-amp-amp-delete"><a href="#free-amp-amp-delete" class="headerlink" title="free &amp;&amp; delete"></a>free &amp;&amp; delete</h3><p>下面是关于free/delete的区别<br><img src="/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/free+delete.png" alt="free+delete"><br>可以看出，当我们对一个对象执行<code>delete</code>操作时，首先要调用析构函数再通过<code>operator delete</code>执行<code>free</code>操作。<br>由此，我们可以知道</p>
<ul>
<li>free使用不当会造成内存泄漏。</li>
</ul>
<p>如果该类是不带指针的类（比如复数类，成员变量只有实部和虚部），不调用类的析构函数也没有任何问题，也会正常的释放掉为对象所分配的内存空间。而如果这个类<mark>带有指针</mark>（比如 string），free时虽然会释放掉对象所占的空间，但由于<code>string</code>存储的只是个指针，我们对字符串进行修改时，对象内部会为指针分配相应的空间来存储内容。我们执行free时，内存中为其具体内容分配的空间没有得到释放。（指针消亡，但指向的内存空间并没有被释放）。</p>
<h3 id="delete-amp-amp-delete"><a href="#delete-amp-amp-delete" class="headerlink" title="delete &amp;&amp; delete[]"></a>delete &amp;&amp; delete[]</h3><p>当我们为一个数组new相应的空间时，使用<code>delete</code>释放也会造成内存泄漏。<br><img src="/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/delete.png" alt="delete"><br>从图中可以看出，使用delete释放为数组开辟的空间时，我们会释放掉所分配的空间，同样的也会调用析构函数。这对于不带指针的类来说可能没有太大的区别，当我们的类带指针时，由于只能够调用一次析构函数。数组<code>array</code>中，只有<code>array[0]</code>所指向的内存空间被释放掉了，其余的几个指针指向的空间并没有被释放。<br>由此可以知道，当我们为数组new一片内存时（<code>new xxx[]</code>)，也要使用相应的<code>delete[] xxx</code>。</p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h3><p>通过<strong>复合</strong>。某个类内部含有另一个类的对象，一些可复用的功能直接通过对象去调用。<br>实例：栈、队列从双端队列改写代码。已实现的功能直接调用，其余自己再写。</p>
<h3 id="Handle-Body"><a href="#Handle-Body" class="headerlink" title="Handle/Body"></a>Handle/Body</h3><p>通过<strong>委托</strong>。某个类内部含有另一个类 对象的指针。这个类可以用来提供对外借口，而底层具体实现在指针指向的对象内实现。（接口改变、底层改变可以只编译一部分）</p>
<h3 id="Template-Method"><a href="#Template-Method" class="headerlink" title="Template Method"></a>Template Method</h3><p>通过<strong>继承</strong>。有些东西在每个软件中所展示出的操作没有太大区别，我们可以将其相似的功能进行编写，细微差异部分以虚函数的形式留给所继承到具体的类中去实现。<br>实例：打开文件操作。各个软件打开文件的次序基本一致：选择文件，检查文件是否存在，在磁盘中进行读取，xxx，关闭文件。我们可以将其余功能都封装好，对外提供一个具体读取方式的接口。</p>
<h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><p>通过<strong>继承+委托</strong>。文件类内部包括多个查看操作的委托，具体到某个文件时，支持多个人同时查看。（文件内部可以增加注册、注销等功能以便于管理。）</p>
<h3 id="Composite"><a href="#Composite" class="headerlink" title="Composite"></a>Composite</h3><p>通过<strong>继承+委托</strong>。当某个类内部可以包含多种不同内容时（自身+其余的类），我们可以将自身及 要包含的类继承自同一个父类。然后该类的内部包含基类的委托。<br>e.g. 类A内部要可以包含A的指针也可以包含B的指针。我们可以将A B都继承自父类C（功能多少不重要，重要的是A中可以包含B的委托），A中包含父类的委托。</p>
<h3 id="Prototype"><a href="#Prototype" class="headerlink" title="Prototype"></a>Prototype</h3><p>通过<strong>继承+委托</strong>。父类可以创建未来将要出现的子类。（父类是发行商自己写的，子类是客户买回去自己写的相应的类）。<br>派生类构造函数设置为私有，构造函数内部实现将自身的指针返回给基类，保存在基类的容器中。派生类中含有一个clone()函数，以让基类调用，生成一个副本提供给父类。还需要另外一个的构造函数（以便clone函数构造自己时调用，防止再次调用上次的私有构造 陷入死循环）</p>

    </div>

    
    
    
<div>
  
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------感谢阅读<i class="fa fa-heart"></i>有缘再见-------------</div>
    
</div>
  
</div>

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%85%AB%E8%82%A1/" rel="tag"><i class="fa fa-tag"></i> 八股</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022-04%E6%9C%88%E5%BA%A6%E6%80%BB%E7%BB%93/" rel="prev" title="2022-04月度总结">
      <i class="fa fa-chevron-left"></i> 2022-04月度总结
    </a></div>
      <div class="post-nav-item">
    <a href="/%E5%A4%8D%E6%95%B0%E7%B1%BB/" rel="next" title="复数类">
      复数类 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E5%AF%B9%E8%B1%A1"><span class="nav-text">基于对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E9%87%8D%E7%82%B9"><span class="nav-text">设计重点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E5%AF%B9%E8%B1%A1-amp-amp-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-text">基于对象 &amp;&amp; 面向对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="nav-text">头文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%83%E5%B1%80"><span class="nav-text">布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%81%E6%9C%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">私有构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#function-const"><span class="nav-text">function() const {}</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E4%B8%80class%E7%9A%84%E5%90%84%E4%B8%AAobject%E4%BA%92%E4%B8%BAfriend"><span class="nav-text">同一class的各个object互为friend</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-text">强制类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0"><span class="nav-text">拷贝构造</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC"><span class="nav-text">拷贝赋值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#new-delete"><span class="nav-text">new&#x2F;delete</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#static"><span class="nav-text">static</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E5%90%88%EF%BC%88Composition%EF%BC%89"><span class="nav-text">复合（Composition）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#container-amp-component"><span class="nav-text">container &amp;component</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A7%94%E6%89%98%EF%BC%88Delegation%EF%BC%89"><span class="nav-text">委托（Delegation）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Composition-amp-Delegation"><span class="nav-text">Composition &amp; Delegation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF-amp-amp-%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-text">继承&amp;&amp;虚函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF-%E5%A4%8D%E5%90%88%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="nav-text">继承+复合构造析构的顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF-%E5%A7%94%E6%89%98"><span class="nav-text">继承+委托</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-text">面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%9E%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%90%E7%AE%97"><span class="nav-text">实现对象和非对象的运算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#conversion-function"><span class="nav-text">conversion function</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#non-explicit-one-argument-ctor"><span class="nav-text">non-explicit-one-argument ctor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#explicit-one-argument-ctor"><span class="nav-text">explicit-one-argument ctor</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB"><span class="nav-text">类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#pointer-like-class"><span class="nav-text">pointer-like class</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#function-like-class"><span class="nav-text">function-like class</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#namespace"><span class="nav-text">namespace</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF"><span class="nav-text">模板</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#class-template"><span class="nav-text">class template</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#function-template"><span class="nav-text">function template</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#member-function"><span class="nav-text">member function</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%8C%96"><span class="nav-text">模板特化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%81%8F%E7%89%B9%E5%8C%96"><span class="nav-text">偏特化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0"><span class="nav-text">模板模板参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#variadic-templates"><span class="nav-text">variadic templates</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#auto"><span class="nav-text">auto</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for-decl-coll"><span class="nav-text">for(decl:coll)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8"><span class="nav-text">引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8C%87%E9%92%88-amp-%E8%99%9A%E8%A1%A8"><span class="nav-text">虚指针&amp;虚表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#this%E6%8C%87%E9%92%88"><span class="nav-text">this指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const"><span class="nav-text">const</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#operator-new-delete"><span class="nav-text">operator new&#x2F;delete</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E8%BD%BDnew-delete"><span class="nav-text">重载new&#x2F;delete</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E8%BD%BDnew-delete-1"><span class="nav-text">重载new(),delete()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#new-amp-amp-delete"><span class="nav-text">new &amp;&amp; delete</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#free-amp-amp-delete"><span class="nav-text">free &amp;&amp; delete</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#delete-amp-amp-delete"><span class="nav-text">delete &amp;&amp; delete[]</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-text">设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Adapter"><span class="nav-text">Adapter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Handle-Body"><span class="nav-text">Handle&#x2F;Body</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Template-Method"><span class="nav-text">Template Method</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Observer"><span class="nav-text">Observer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Composite"><span class="nav-text">Composite</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Prototype"><span class="nav-text">Prototype</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">某卑微社畜</p>
  <div class="site-description" itemprop="description">爱过</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">38</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/ikun7355608" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ikun7355608" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:goudan.wang@outlook.com" title="邮箱 → mailto:goudan.wang@outlook.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>邮箱</a>
      </span>
      <span class="links-of-author-item">
        <a href="tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=1992018857&website=www.oicqzone.com" title="QQ → tencent:&#x2F;&#x2F;AddContact&#x2F;?fromId&#x3D;45&amp;fromSubId&#x3D;1&amp;subcmd&#x3D;all&amp;uin&#x3D;1992018857&amp;website&#x3D;www.oicqzone.com" rel="noopener" target="_blank"><i class="fab fa-qq fa-fw"></i>QQ</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2021 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">某卑微社畜</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">232k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:31</span>
<div>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv" style='display:none'>
    有<span id="busuanzi_value_site_uv"></span>人看过我的博客啦
</span>
</div>
</div>
<div>
<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
    var now = new Date(); 
    function createtime() { 
        var grt= new Date("12/29/2021 12:00:00");//在此处修改你的建站时间
        now.setTime(now.getTime()+250); 
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
        document.getElementById("timeDate").innerHTML = "已运行 "+dnum+" 天 "; 
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
    } 
setInterval("createtime()",250);
</script>
</div>
<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>
-->
        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
