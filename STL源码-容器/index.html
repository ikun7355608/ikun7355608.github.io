<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="本文是在阅读SGI STL v3.3源码中关于container部分，遇到的一些问题及有意思的点。 此外，本文建立在已经观看过侯捷老师STL源码剖析课程的基础上。是在阅读源码过程中，对其中的内容进行补充、修饰。">
<meta property="og:type" content="article">
<meta property="og:title" content="STL源码-容器">
<meta property="og:url" content="http://example.com/STL%E6%BA%90%E7%A0%81-%E5%AE%B9%E5%99%A8/index.html">
<meta property="og:site_name" content="残局">
<meta property="og:description" content="本文是在阅读SGI STL v3.3源码中关于container部分，遇到的一些问题及有意思的点。 此外，本文建立在已经观看过侯捷老师STL源码剖析课程的基础上。是在阅读源码过程中，对其中的内容进行补充、修饰。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/STL%E6%BA%90%E7%A0%81-%E5%AE%B9%E5%99%A8/transfer.png">
<meta property="og:image" content="http://example.com/STL%E6%BA%90%E7%A0%81-%E5%AE%B9%E5%99%A8/deque.png">
<meta property="article:published_time" content="2022-06-30T12:22:53.000Z">
<meta property="article:modified_time" content="2022-08-24T14:08:34.352Z">
<meta property="article:author" content="某卑微社畜">
<meta property="article:tag" content="CPP">
<meta property="article:tag" content="SGI_STL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/STL%E6%BA%90%E7%A0%81-%E5%AE%B9%E5%99%A8/transfer.png">

<link rel="canonical" href="http://example.com/STL%E6%BA%90%E7%A0%81-%E5%AE%B9%E5%99%A8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>STL源码-容器 | 残局</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="残局" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">残局</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">没有故事，不会喝酒。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/STL%E6%BA%90%E7%A0%81-%E5%AE%B9%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="某卑微社畜">
      <meta itemprop="description" content="爱过">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="残局">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          STL源码-容器
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-30 20:22:53" itemprop="dateCreated datePublished" datetime="2022-06-30T20:22:53+08:00">2022-06-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-24 22:08:34" itemprop="dateModified" datetime="2022-08-24T22:08:34+08:00">2022-08-24</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>25k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>23 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本文是在阅读SGI STL v3.3源码中关于<code>container</code>部分，遇到的一些问题及有意思的点。</p>
<p>此外，本文建立在已经观看过<a target="_blank" rel="noopener" href="https://endgame.cc/2022/06/23/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">侯捷老师STL源码剖析课程</a>的基础上。是在阅读源码过程中，对其中的内容进行补充、修饰。</p>
<span id="more"></span>

<h2 id="顺序型容器"><a href="#顺序型容器" class="headerlink" title="顺序型容器"></a>顺序型容器</h2><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><h4 id="pragma-set-woff-XXX"><a href="#pragma-set-woff-XXX" class="headerlink" title="#pragma set woff XXX"></a>#pragma set woff XXX</h4><ul>
<li><code>#pragma set woff xxx</code>    —-    关闭/抑制 名为<code>xxx</code>的编译器警告</li>
<li><code>#pragma reset woff xxx</code>    —-    重置命令行中指定的状态的警告（取消set状态）</li>
</ul>
<h4 id="static-assert"><a href="#static-assert" class="headerlink" title="static_assert"></a>static_assert</h4><p>C++11 静态断言static_assert，编译期断言。</p>
<blockquote>
<p><strong>static_assert</strong>(常量表达式，提示信息)</p>
</blockquote>
<p>与断言的区别是，静态断言如果为假，则编译不通过。</p>
<h4 id="noexcept"><a href="#noexcept" class="headerlink" title="noexcept"></a>noexcept</h4><p><code>noexcept</code> 是C++11中的特性，既是一个说明符，也是一个运算符。<code>noexcept</code>指示函数<strong>不会抛出异常</strong>，编译器可以优化代码。</p>
<p><code>noexcept</code> 用法：</p>
<ol>
<li><code>return_type function() noexcept</code>不会抛出异常</li>
<li><code>return_type function() noexcept(常量表达式)</code>常量表达式为<code>true</code>，则不会抛出异常。</li>
</ol>
<blockquote>
<p>使用场景：移动构造函数、移动赋值、swap()、析构函数。</p>
</blockquote>
<ul>
<li>==默认==的构造函数、拷贝构造函数、赋值、移动构造、移动赋值均为<code>noexcept</code>。</li>
<li>c++11仍保留throw()，实现和<code>noexcept</code>类似功能（但throw不会针对编译器优化），但在c++20已删除。</li>
</ul>
<h4 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h4><p><code>explicit</code>关键字用于构造函数之前，默认关闭了隐式类型转换。</p>
<blockquote>
<p>通过构造函数将相应的数据类型转换成为C++类的对象，给编码带来了方便，但并不是每次都正确，为了避免这种情况引入explicit。</p>
</blockquote>
<p>explicit 关键字只能用于修饰<mark>只有一个参数的类构造函数</mark></p>
<h4 id="const-iterator"><a href="#const-iterator" class="headerlink" title="const_iterator"></a>const_iterator</h4><p><code>const_iterator</code>可以改变<code>iterator</code>的值，但不能通过<code>iterator</code>修改指向元素内容的值。(指向常量的指针)</p>
<h4 id="max-size"><a href="#max-size" class="headerlink" title="max_size()"></a>max_size()</h4><p><code>max_size()</code>函数如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span>(<span class="number">-1</span>) / <span class="built_in"><span class="keyword">sizeof</span></span>(_Tp); &#125;</span><br></pre></td></tr></table></figure>

<p>由源码可以知道，size_type为无符号整形。而<code>-1</code>我们知道其二进制补码为==全1==。<code>size_type(-1)</code>将其强制类型转换为无符号整形的最大值(==全1==)，即表示最大值$2^{32/64}$。然后对应的除以一个元素所占大小，即得出最大存放元素数量。</p>
<p>根据操作系统的位数自由推断所能存储的最大元素数量。</p>
<h4 id="copy"><a href="#copy" class="headerlink" title="copy()"></a>copy()</h4><p>这里所写的<code>copy(iter it1,iter it2,iter it3)</code>函数是将<code>vector</code>的拷贝赋值<code>=</code>，目的地址所存在的元素数多于要插入的元素时的状况：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;_Tp,_Alloc&gt;::<span class="keyword">operator</span>=(<span class="keyword">const</span> vector&lt;_Tp, _Alloc&gt;&amp; __x)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (&amp;__x != <span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> size_type __xlen = __x.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (__xlen &gt; <span class="built_in">capacity</span>()) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">size</span>() &gt;= __xlen) &#123;</span><br><span class="line">      iterator __i = <span class="built_in">copy</span>(__x.<span class="built_in">begin</span>(), __x.<span class="built_in">end</span>(), <span class="built_in">begin</span>());</span><br><span class="line">      <span class="built_in">destroy</span>(__i, _M_finish);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    _M_finish = _M_start + __xlen;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该<code>copy()</code>函数最终调用的函数如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> _Tp*</span><br><span class="line">__copy_trivial(<span class="keyword">const</span> _Tp* __first, <span class="keyword">const</span> _Tp* __last, _Tp* __result) &#123;</span><br><span class="line">  <span class="built_in">memmove</span>(__result, __first, <span class="built_in"><span class="keyword">sizeof</span></span>(_Tp) * (__last - __first));</span><br><span class="line">  <span class="keyword">return</span> __result + (__last - __first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="construct"><a href="#construct" class="headerlink" title="construct()"></a>construct()</h4><p>该函数存在于<code>stl_construct</code>头文件中，是分配器的一部分。源码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">T1</span>, <span class="keyword">class</span> _<span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">(_T1* __p, <span class="keyword">const</span> _T2&amp; __value)</span> </span>&#123;</span><br><span class="line">  _Construct(__p, __value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">T1</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">(_T1* __p)</span> </span>&#123;</span><br><span class="line">  _Construct(__p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">T1</span>, <span class="keyword">class</span> _<span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Construct(_T1* __p, <span class="keyword">const</span> _T2&amp; __value) &#123;</span><br><span class="line">  <span class="keyword">new</span> ((<span class="keyword">void</span>*) __p) _T1(__value);   <span class="comment">// placement new，调用 _T1::_T1(__value);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">T1</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Construct(_T1* __p) &#123;</span><br><span class="line">  <span class="keyword">new</span> ((<span class="keyword">void</span>*) __p) _T1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>__p  —- 指针</li>
<li>__value —- 初值</li>
<li>函数功能 —- 将初值<code> __value</code> 设定到指针<code>__p</code>所指的空间上</li>
</ul>
<p>函数的作用在于调用相应的构造函数，将地址进行类型转换。</p>
<h4 id="copy-backward"><a href="#copy-backward" class="headerlink" title="copy_backward()"></a>copy_backward()</h4><p>copy_backward(iter1 first,iter1 end, iter2 res)将元素$\left[first,end\right)$复制到以res为尾迭代器的位置$\left[res-\left(end -first\right),res\right)$。（当在中间插入元素时，后续部分移动<code>copy_backward(*__position*, _M_finish - 2, _M_finish - 1);</code>）样例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt;v1&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">copy_backward</span>(v1.<span class="built_in">begin</span>()+<span class="number">1</span>,v1.<span class="built_in">begin</span>()+<span class="number">3</span>,v1.<span class="built_in">end</span>());<span class="comment">//1~3号元素的值赋给x~_finish。</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> iter=v1.<span class="built_in">begin</span>();iter!=v1.<span class="built_in">end</span>();++iter)&#123;</span><br><span class="line">    cout&lt;&lt;*iter&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;	<span class="comment">//1 2 3 2 3 </span></span><br></pre></td></tr></table></figure>

<h3 id="bit-vector"><a href="#bit-vector" class="headerlink" title="bit_vector"></a>bit_vector</h3><p>由于<code>bool</code>类型只用<code>1bit</code>就可以表示，不需要<code>1Bytes</code>，因此对<code>vector</code>提供相应的偏特化版本。虽然一个元素只占<code>1bit</code>，但地址空间是按照<code>unsigned int</code>进行分配。</p>
<p>我们知道，vector由<code>start,finish,end_of_storage</code>三个迭代器组成，大小为<code>12</code>字节。而bit_vector与<code>vector</code>存在着一定的差异：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//与大小无关的代码已省略</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">Bvector_base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _Bit_iterator _M_start;</span><br><span class="line">  _Bit_iterator _M_finish;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>* _M_end_of_storage;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Bit_iterator</span> :</span> <span class="keyword">public</span> _Bit_iterator_base</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Bit_iterator_base</span> :</span> <span class="keyword">public</span> random_access_iterator&lt;<span class="keyword">bool</span>, <span class="keyword">ptrdiff_t</span>&gt; </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>* _M_p;	<span class="comment">//指向具体实体</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> _M_offset;	<span class="comment">//偏移量(从0开始 用于找到具体bit位)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Bit_reference</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>* _M_p;	<span class="comment">//指向具体实体</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> _M_mask;	<span class="comment">//vaule(true or false)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>__WORD_BIT</code> —- 由于不同位数的操作系统下<code>unsigned int</code>大小并不固定，因此用来确认具体大小。</li>
</ul>
<p>可以看出，每个<code>bit_vector</code>由一个<code>unsigned int*</code>和两个<code>iterator</code>组成，而一个<code>bit_iterator</code>由<code>unsigned int*</code>和<code>unsigned int</code>组成，占大小<code>20Bytes</code></p>
<p>与<code>bit_iterator</code>相关联的两个函数<code>_M_bump_down</code>和<code>_M_bump_up</code>用来进行移位。基于这两个函数还重写了<code>++ --</code>运算符</p>
<h4 id="flip"><a href="#flip" class="headerlink" title="flip()"></a>flip()</h4><p>所有元素取反。(<code>true-&gt;false</code>,<code>false-&gt;true</code>)</p>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><h4 id="begin-end"><a href="#begin-end" class="headerlink" title="begin()/end()"></a>begin()/end()</h4><p>双向链表底层存放的是虚拟头部(<code>_M_head</code>)，begin()函数返回的是<code>_M_head-&gt;_M_next</code>。而双向链表涉及的是==循环==结构，尾结点的next指针指向虚拟头部。end()函数返回尾结点的下一个元素，即<code>_M_head</code>。</p>
<h4 id="transfer"><a href="#transfer" class="headerlink" title="transfer()"></a>transfer()</h4><p>list中存在一个<code>transfer(iter postion,iter first,iter last)</code>函数。用于将$\left[first,last\right)$元素移动到<code>position</code>之前。</p>
<p>源码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(iterator __position, iterator __first, iterator __last)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (__position != __last) &#123;</span><br><span class="line">    <span class="comment">// Remove [first, last) from its old position.</span></span><br><span class="line">      <span class="comment">//改正序遍历指针</span></span><br><span class="line">    __last._M_node-&gt;_M_prev-&gt;_M_next     = __position._M_node;</span><br><span class="line">    __first._M_node-&gt;_M_prev-&gt;_M_next    = __last._M_node;</span><br><span class="line">    __position._M_node-&gt;_M_prev-&gt;_M_next = __first._M_node; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Splice [first, last) into its new position.</span></span><br><span class="line">      <span class="comment">//改逆序遍历指针</span></span><br><span class="line">    _List_node_base* __tmp      = __position._M_node-&gt;_M_prev;</span><br><span class="line">    __position._M_node-&gt;_M_prev = __last._M_node-&gt;_M_prev;</span><br><span class="line">    __last._M_node-&gt;_M_prev     = __first._M_node-&gt;_M_prev; </span><br><span class="line">    __first._M_node-&gt;_M_prev    = __tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以1~7节点中移动[4,6)为例</p>
</blockquote>
<p><img src="/STL%E6%BA%90%E7%A0%81-%E5%AE%B9%E5%99%A8/transfer.png" alt="transfer"></p>
<h4 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h4><p><code>splice()</code>底层是调用<code>transfer()</code>，将元素(结点、<code>list</code>、起止迭代器)插入到指定位置(<code>position</code>)之前。</p>
<h4 id="unique"><a href="#unique" class="headerlink" title="unique()"></a>unique()</h4><p>删除==连续==的相同元素（保证唯一）。</p>
<h4 id="merge"><a href="#merge" class="headerlink" title="merge()"></a>merge()</h4><ul>
<li><p>将另一个链表<code>list2</code>合并到该链表上。</p>
</li>
<li><p>合并有序链表，合并后仍有序。</p>
</li>
<li><p>两个指针分别指向两个链表头。以调用函数的list为基准，比较大小决定<code>list2</code>结点插入的位置。</p>
</li>
</ul>
<h4 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h4><p>list::sort本质上是<strong>归并排序</strong>。依次从源链表中取值，放入<code>__counter</code>数组中。<code>__counter</code>数组第$i$层至多存放$2^i$个元素(共可以存放$2^{64}-1$个元素)。在递归过程中，先在第0层插入，然后该层元素满时，向上传递该层的数组，并找到恰当的位置。当一层的元素进入下一层是该层元素构成的数组是有序的，被插入的深层里的元素也是有序的（归并排序）。当所有元素都读取出之后<code>while(!empty())</code>跳出，然后递归遍历，每一层都向上传输并进行归并排序。最终将得到的结果回写给源链表。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> list&lt;T, Alloc&gt;::<span class="built_in">sort</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next == node || <span class="built_in">link_type</span>(node-&gt;next)-&gt;next == node) <span class="keyword">return</span>;</span><br><span class="line">    list&lt;T, Alloc&gt; carry;       <span class="comment">//辅助链表，相当与tmp</span></span><br><span class="line">    list&lt;T, Alloc&gt; counter[<span class="number">64</span>]; <span class="comment">//保存当前递归层次的结果，第i链表保存的元素个数为2的i次方或0</span></span><br><span class="line">    <span class="keyword">int</span> fill = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        carry.<span class="built_in">splice</span>(carry.<span class="built_in">begin</span>(), *<span class="keyword">this</span>, <span class="built_in">begin</span>());  <span class="comment">//将链表的第一个元素移动至carry开头</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//从小到大不断合并非空归并层次直至遇到空层或者到达当前最大归并层次</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; fill &amp;&amp; !counter[i].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            counter[i].<span class="built_in">merge</span>(carry);  <span class="comment">//合并链表，结果链表是有序的，必须保证合并前两链表有序</span></span><br><span class="line">            carry.<span class="built_in">swap</span>(counter[i++]); <span class="comment">//链表元素互换</span></span><br><span class="line">            <span class="comment">//将某一层的元素换出到carry中，去和下一层比对</span></span><br><span class="line">        &#125;</span><br><span class="line">        carry.<span class="built_in">swap</span>(counter[i]);  <span class="comment">//将carry元素放到counter[i]中，相当于将carry情况，带下一次循环使用</span></span><br><span class="line">        <span class="comment">//将carry中的数据换回最深层</span></span><br><span class="line">        <span class="keyword">if</span> (i == fill) ++fill;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将所有归并层次的结果合并得到最终结果counter[fill-1]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; fill; ++i) counter[i].<span class="built_in">merge</span>(counter[i<span class="number">-1</span>]);</span><br><span class="line">    <span class="built_in">swap</span>(counter[fill<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li> fill —- counter数组中最深层的层数</li>
</ul>
<h3 id="slist"><a href="#slist" class="headerlink" title="slist"></a>slist</h3><p>slist、forward_list。单向链表。仅有一个虚拟头部，指向实际链表头</p>
<h4 id="slist-splice-after"><a href="#slist-splice-after" class="headerlink" title="__slist_splice_after()"></a>__slist_splice_after()</h4><p>_Slist_node_base == A</p>
<ul>
<li><code>__slist_splice_after(A* pos,A* first,A*last)</code>将$\left(first,last\right]$中的数据移动到<code>pos</code>之后</li>
<li><code>__slist_splice_after(A* pos,A* node)</code>将$\left(node,\infty\right)$移动到<code>pos</code>之后。（node之后所有元素）</li>
</ul>
<h4 id="M-erase-after"><a href="#M-erase-after" class="headerlink" title="_M_erase_after()"></a>_M_erase_after()</h4><ul>
<li><code>_M_erase_after(A* pos)</code>删除<code>pos</code>位置后的第一个元素</li>
<li><code>_M_erase_after(A* pos, A* last)</code>删除$\left(post,last\right)$之间全部元素</li>
</ul>
<h4 id="begin-end-1"><a href="#begin-end-1" class="headerlink" title="begin()/end()"></a>begin()/end()</h4><ul>
<li>单向链表的底层仅存在一个虚拟头部(<code>_M_head</code>)指向真正链表的头，begin()函数返回的是<code>_M_head-&gt;_M_next</code></li>
<li>由于end()应指向最后一个元素的下一个元素(<code>nullptr</code>)，而单链表只能单向访问，直接<code>return nullptr</code></li>
</ul>
<h4 id="push-pop"><a href="#push-pop" class="headerlink" title="push/pop"></a>push/pop</h4><p>单链表插入/删除元素是在==头部==进行操作。故，push/pop函数为<code>push_front()/pop_front()</code>，插入/弹出虚拟头部的后一个位置。</p>
<h4 id="previous"><a href="#previous" class="headerlink" title="previous()"></a>previous()</h4><p><code>previous(iterator pos)</code>返回<code>pos</code>位置的前一个元素。</p>
<h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p><img src="/STL%E6%BA%90%E7%A0%81-%E5%AE%B9%E5%99%A8/deque.png" alt="deque"></p>
<h5 id="Deque-iterator"><a href="#Deque-iterator" class="headerlink" title="_Deque_iterator"></a>_Deque_iterator</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Ref</span>, <span class="keyword">class</span> _<span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Deque_iterator</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> _Tp** _Map_pointer;</span><br><span class="line">  _Tp* _M_cur;   <span class="comment">// 迭代器指向缓冲区的当前元素</span></span><br><span class="line">  _Tp* _M_first; <span class="comment">// 迭代器指向缓冲区的头部</span></span><br><span class="line">  _Tp* _M_last;  <span class="comment">// 迭代器指向缓冲区的尾部</span></span><br><span class="line">  _Map_pointer _M_node;  <span class="comment">// 迭代器指向 map 的 node</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="operator"><a href="#operator" class="headerlink" title="operator-"></a>operator-</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">difference_type <span class="keyword">operator</span>-(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()) *(node - x.node - <span class="number">1</span>) + (cur - first) + (x.last - x.cur);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    node - x.node - 1     map中的完整缓冲区个数</span></span><br><span class="line"><span class="comment">    cur - first 尾迭代器buffer元素个数</span></span><br><span class="line"><span class="comment">    x.last - x.cur 头迭代器buffer元素个数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>enum { _S_initial_map_size = 8 };        //默认map大小</p>
</blockquote>
<h4 id="M-initialize-map"><a href="#M-initialize-map" class="headerlink" title="_M_initialize_map()"></a>_M_initialize_map()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">_Deque_base&lt;_Tp,_Alloc&gt;::_M_initialize_map(<span class="keyword">size_t</span> __num_elements)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 所需节点数</span></span><br><span class="line">  <span class="keyword">size_t</span> __num_nodes = </span><br><span class="line">    __num_elements / __deque_buf_size(<span class="built_in"><span class="keyword">sizeof</span></span>(_Tp)) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// __num_elements / __deque_buf_size(sizeof(_Tp))满结点个数 + 1未满（或空）</span></span><br><span class="line">  <span class="comment">// 一个 map 要管理几个节点，最少 8 个，最多是所需节点数加 2（首尾两个虚拟节点）</span></span><br><span class="line">  _M_map_size = <span class="built_in">max</span>((<span class="keyword">size_t</span>) _S_initial_map_size, __num_nodes + <span class="number">2</span>);</span><br><span class="line">  _M_map = _M_allocate_map(_M_map_size);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// __nstart、__nfinish 指向 map 的中间位置。方便两端扩充（减少加结点的次数）</span></span><br><span class="line">  _Tp** __nstart = _M_map + (_M_map_size - __num_nodes) / <span class="number">2</span>;</span><br><span class="line">  _Tp** __nfinish = __nstart + __num_nodes;</span><br><span class="line">    </span><br><span class="line">  __STL_TRY &#123;</span><br><span class="line">    _M_create_nodes(__nstart, __nfinish);</span><br><span class="line">  &#125;</span><br><span class="line">  __STL_UNWIND((_M_deallocate_map(_M_map, _M_map_size), </span><br><span class="line">                _M_map = <span class="number">0</span>, _M_map_size = <span class="number">0</span>));</span><br><span class="line">  <span class="comment">// 为 deque 内的两个迭代器 start 和 finish 指向正确位置</span></span><br><span class="line">  _M_start._M_set_node(__nstart);</span><br><span class="line">  _M_finish._M_set_node(__nfinish - <span class="number">1</span>);</span><br><span class="line">  _M_start._M_cur = _M_start._M_first;</span><br><span class="line">  _M_finish._M_cur = _M_finish._M_first +</span><br><span class="line">               __num_elements % __deque_buf_size(<span class="built_in"><span class="keyword">sizeof</span></span>(_Tp));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="erase-iterator-pos"><a href="#erase-iterator-pos" class="headerlink" title="erase(iterator __pos)"></a>erase(iterator __pos)</h4><p>删除指定位置的元素。该函数的有趣之处在于，先判断距离哪一端更近，从近的一侧去移动元素。</p>
<blockquote>
<p>insert底层函数insert_aux函数亦然</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator __pos)</span> </span>&#123;</span><br><span class="line">  iterator __next = __pos;</span><br><span class="line">  ++__next;</span><br><span class="line">  difference_type __index = __pos - _M_start; 	<span class="comment">//与头距离</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">size_type</span>(__index) &lt; (<span class="keyword">this</span>-&gt;<span class="built_in">size</span>() &gt;&gt; <span class="number">1</span>)) &#123;		<span class="comment">//距离与总元素个数比较</span></span><br><span class="line">    <span class="built_in">copy_backward</span>(_M_start, __pos, __next);	</span><br><span class="line">      <span class="comment">//离头近，将头~pos元素整体向后赋值（覆盖pos），再弹出头</span></span><br><span class="line">    <span class="built_in">pop_front</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">copy</span>(__next, _M_finish, __pos);</span><br><span class="line">      <span class="comment">//离尾部近，</span></span><br><span class="line">    <span class="built_in">pop_back</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _M_start + __index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="M-reserve-map-at-back"><a href="#M-reserve-map-at-back" class="headerlink" title="_M_reserve_map_at_back()"></a>_M_reserve_map_at_back()</h4><p>共有两组函数：</p>
<ul>
<li><code>_M_reserve_map_at_back()</code>和<code>_M_reserve_map_at_front()</code>。表示<code>map</code>的一端不够用时，扩充</li>
<li><code>_M_reserve_element_at_back()</code>和<code>_M_reserve_element_at_front()</code>表示<mark>结点</mark>不够用扩充结点。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">void</span> _M_reserve_map_at_back (size_type __nodes_to_add = <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__nodes_to_add + <span class="number">1</span> &gt; _M_map_size - (_M_finish._M_node - _M_map))</span><br><span class="line">      _M_reallocate_map(__nodes_to_add, <span class="literal">false</span>);</span><br><span class="line">  &#125;<span class="comment">//map尾结点可用空间不足，换个更大空间</span></span><br><span class="line">  <span class="keyword">void</span> _M_reserve_map_at_front (size_type __nodes_to_add = <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__nodes_to_add &gt; <span class="built_in">size_type</span>(_M_start._M_node - _M_map))</span><br><span class="line">      _M_reallocate_map(__nodes_to_add, <span class="literal">true</span>);</span><br><span class="line">  &#125;<span class="comment">//map头结点可用空间不足，换个更大空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> deque&lt;_Tp,_Alloc&gt;::_M_reallocate_map(size_type __nodes_to_add,</span><br><span class="line">                                          <span class="keyword">bool</span> __add_at_front)</span><br><span class="line">&#123;</span><br><span class="line">  size_type __old_num_nodes = _M_finish._M_node - _M_start._M_node + <span class="number">1</span>;</span><br><span class="line">  size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;</span><br><span class="line"></span><br><span class="line">  _Map_pointer __new_nstart;</span><br><span class="line">  <span class="keyword">if</span> (_M_map_size &gt; <span class="number">2</span> * __new_num_nodes) &#123;	<span class="comment">//总空间充足（元素偏向一侧）则调整位置</span></span><br><span class="line">    __new_nstart = _M_map + (_M_map_size - __new_num_nodes) / <span class="number">2</span> </span><br><span class="line">                     + (__add_at_front ? __nodes_to_add : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (__new_nstart &lt; _M_start._M_node)</span><br><span class="line">      <span class="built_in">copy</span>(_M_start._M_node, _M_finish._M_node + <span class="number">1</span>, __new_nstart);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">copy_backward</span>(_M_start._M_node, _M_finish._M_node + <span class="number">1</span>, </span><br><span class="line">                    __new_nstart + __old_num_nodes);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;	<span class="comment">//空间不足 新申请一片空间</span></span><br><span class="line">    size_type __new_map_size = </span><br><span class="line">      _M_map_size + <span class="built_in">max</span>(_M_map_size, __nodes_to_add) + <span class="number">2</span>;</span><br><span class="line">    _Map_pointer __new_map = _M_allocate_map(__new_map_size);	<span class="comment">//配置新空间</span></span><br><span class="line">    __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / <span class="number">2</span></span><br><span class="line">                         + (__add_at_front ? __nodes_to_add : <span class="number">0</span>);	<span class="comment">//寻找新头</span></span><br><span class="line">    <span class="built_in">copy</span>(_M_start._M_node, _M_finish._M_node + <span class="number">1</span>, __new_nstart);</span><br><span class="line">    _M_deallocate_map(_M_map, _M_map_size);</span><br><span class="line"></span><br><span class="line">    _M_map = __new_map;</span><br><span class="line">    _M_map_size = __new_map_size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _M_start._M_set_node(__new_nstart);</span><br><span class="line">  _M_finish._M_set_node(__new_nstart + __old_num_nodes - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="M-insert-aux"><a href="#M-insert-aux" class="headerlink" title="_M_insert_aux()"></a>_M_insert_aux()</h4><p><code>insert</code>函数底层调用<code>_M_insert_aux()</code>其中有两个重载版本的<code>_M_insert_aux</code>存在一些问题（非不能，个人认为传参有些冗余）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> deque&lt;_Tp,_Alloc&gt;::_M_insert_aux(iterator __pos,</span><br><span class="line">                                      <span class="keyword">const</span> value_type* __first,</span><br><span class="line">                                      <span class="keyword">const</span> value_type* __last,</span><br><span class="line">                                      size_type __n)&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> deque&lt;_Tp,_Alloc&gt;::_M_insert_aux(iterator __pos,</span><br><span class="line">                                      const_iterator __first,</span><br><span class="line">                                      const_iterator __last,</span><br><span class="line">                                      size_type __n)&#123;</span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个函数上层<code>insert()</code>函数重载时，传入的是三个参数（<code>Where</code>,<code>First</code>,<code>Last</code>）。而在调用底层<code>_M_insert_aux</code>时，添加第四参数<code>n = first - last</code>。（个人认为这里不传，底层去计算亦可）</p>
<h3 id="stack-queue"><a href="#stack-queue" class="headerlink" title="stack/queue"></a>stack/queue</h3><blockquote>
<p>stack/queue无迭代器</p>
</blockquote>
<p>底层容器可以是<code>vector  list  deque</code>。然后采用$Adapter$设计模式，改装成<code>stack/queue</code>。默认底层容器<code>deque</code>。做底层容器要求：拥有<code>empty()  size()  push_back()  pop_back()/pop_front()  back()/front()  operatot==</code>等函数。（改装时，调用底层容器的函数，能够成功调用。）</p>
<h3 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h3><p>默认底层容器<code>vector</code>，默认规则<code>max-heap</code>。插入、删除、弹出元素时调用<code>make_heap()  push_heap()  pop_heap()</code></p>
<h3 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h3><blockquote>
<p>heap无迭代器。</p>
</blockquote>
<blockquote>
<p>heap不提供外部调用接口，仅供<code>priority_queue</code>使用</p>
</blockquote>
<p>默认底层容器<code>vector</code>。根节点位于 vector 的头部；</p>
<p>当 heap 中的某个节点位于 vector 的 $i $处，左子节点位于  $2i+1 $，右子节点位于 $2i+2$ ；然后调整为 heap。</p>
<p>heap有四个主要函数:<code>push_heap  pop_heap  make_heap  sort_heap</code></p>
<h4 id="push-heap"><a href="#push-heap" class="headerlink" title="push_heap"></a>push_heap</h4><p>push_heap所做的操作是：向根尾部插入一个元素，然后调整到正确的位置。源码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> _<span class="title">Distance</span>, <span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">__push_heap(_RandomAccessIterator __first,</span><br><span class="line">            _Distance __holeIndex, _Distance __topIndex, _Tp __value)</span><br><span class="line">&#123;</span><br><span class="line">  _Distance __parent = (__holeIndex - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// 找到插入节点的父节点位置</span></span><br><span class="line">  <span class="keyword">while</span> (__holeIndex &gt; __topIndex &amp;&amp; *(__first + __parent) &lt; __value) &#123; <span class="comment">// 当插入值大于其父节点的值</span></span><br><span class="line">    *(__first + __holeIndex) = *(__first + __parent);   <span class="comment">// 将其插入节点的父节点的值赋给插入节点位置</span></span><br><span class="line">    __holeIndex = __parent;  <span class="comment">// 索引位置改变，插入值的索引为父节点索引</span></span><br><span class="line">    __parent = (__holeIndex - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// 插入值的索引的父节点</span></span><br><span class="line">  &#125;    </span><br><span class="line">  *(__first + __holeIndex) = __value; <span class="comment">// 交换完后，找到插入值的真正位置，赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>__first    —    容器首部迭代器，用于定位元素的位置(下面的<code>*(__first + __holeIndex)</code>)</p>
</li>
<li><p>__holeIndex    —    容器已使用的长度、也是新插入元素在数组中存放的角标</p>
</li>
<li><p>__topIndex    —    允许上升的最大高度，用于控制循环退出条件(一般为根节点高度0)</p>
</li>
<li><p>__value    —    新插入元素的值</p>
</li>
<li><p>__comp    —    仿函数，用于传入自定义比较规则。（影响上述源码第7行循环中的比较标准）</p>
<ul>
<li><code>*(__first + __parent) &lt; __value) </code>$\longrightarrow$<code>__comp(*(__first + __parent), __value))</code></li>
</ul>
</li>
</ul>
<h4 id="pop-heap"><a href="#pop-heap" class="headerlink" title="pop_heap"></a>pop_heap</h4><p>pop_heap调用<code>__pop_heap</code>实现弹堆顶元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIterator</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pop_heap</span><span class="params">(_RandomAccessIterator __first,_RandomAccessIterator __last)</span></span>&#123;</span><br><span class="line">  __pop_heap_aux(__first, __last, __VALUE_TYPE(__first));   <span class="comment">// pop_heap 调整函数，将 vector 头部元素放到 vector 的尾部</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __pop_heap_aux(_RandomAccessIterator __first, _RandomAccessIterator __last,_Tp*)&#123;</span><br><span class="line">  __pop_heap(__first, __last - <span class="number">1</span>, __last - <span class="number">1</span>, _Tp(*(__last - <span class="number">1</span>)), __DISTANCE_TYPE(__first)); </span><br><span class="line">    <span class="comment">// 调整 heap 后，变为[first, last-1)</span></span><br><span class="line">    <span class="comment">//这里还要注意，第四个参数__value传的是_Tp(*(__last - 1))。也就是原来堆尾的值。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,</span><br><span class="line">           _RandomAccessIterator __result, _Tp __value, _Distance*)</span><br><span class="line">&#123;</span><br><span class="line">  *__result = *__first;  <span class="comment">// 先保存 vector 头部元素，放到 vector 的尾端</span></span><br><span class="line">  __adjust_heap(__first, _Distance(<span class="number">0</span>), _Distance(__last - __first), __value); <span class="comment">// 再做 shift down 操作调整</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>__pop_heap参数如下</p>
</blockquote>
<ul>
<li><p>__first    —    指向堆顶的迭代器。（要弹出元素的位置）</p>
</li>
<li><p>__last    —    容器尾部迭代器（实际使用的最后一个元素位置）</p>
</li>
<li><p>__result    —    结果保存的位置。由于底层容器为vector，当删除一个元素时，是将其移动到容器尾，然后再移动尾迭代器使其不可见，故默认值为<code>_Tp(*__last )</code></p>
</li>
<li><p>__value    —    堆中最小的元素值（堆尾部的值）</p>
</li>
<li><p>__comp    —    仿函数，用于传入自定义比较规则。如果有会相应的传给<code>__adjust_heap</code>函数</p>
</li>
</ul>
<h5 id="adjust-heap"><a href="#adjust-heap" class="headerlink" title="__adjust_heap"></a>__adjust_heap</h5><p>pop_heap底层真正调用实现剩余元素维持堆序性的函数。这里以删除结点后的调整为例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> _<span class="title">Distance</span>, <span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">__adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,</span><br><span class="line">              _Distance __len, _Tp __value)</span><br><span class="line">&#123;</span><br><span class="line">  _Distance __topIndex = __holeIndex;  <span class="comment">// __holeIndex = 0，为 heap 的根节点</span></span><br><span class="line">  _Distance __secondChild = <span class="number">2</span> * __holeIndex + <span class="number">2</span>; <span class="comment">// 根节点的右节点的索引</span></span><br><span class="line">  <span class="keyword">while</span> (__secondChild &lt; __len) &#123;</span><br><span class="line">      <span class="comment">// __comp	传入时，用来修改此处的比较条件</span></span><br><span class="line">    <span class="keyword">if</span> (*(__first + __secondChild) &lt; *(__first + (__secondChild - <span class="number">1</span>))) <span class="comment">// 比较根节点的左右节点值</span></span><br><span class="line">      __secondChild--;<span class="comment">//__secondChild向下传递时，一定为较大值</span></span><br><span class="line">    *(__first + __holeIndex) = *(__first + __secondChild);  <span class="comment">// while 里做 shift down 操作</span></span><br><span class="line">      <span class="comment">//二者本来是兄弟节点，较大值升为父节点。</span></span><br><span class="line">    __holeIndex = __secondChild;</span><br><span class="line">    __secondChild = <span class="number">2</span> * (__secondChild + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (__secondChild == __len) &#123;  <span class="comment">// 没有右子节点，只有左子节点</span></span><br><span class="line">    *(__first + __holeIndex) = *(__first + (__secondChild - <span class="number">1</span>));</span><br><span class="line">    __holeIndex = __secondChild - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="comment">//循环退出时，__holeIndex移动到最后一层。</span></span><br><span class="line">    <span class="comment">// 此时。__holeIndex标志着最小值__value的位置</span></span><br><span class="line">  __push_heap(__first, __holeIndex, __topIndex, __value);  <span class="comment">// 向上寻找 找到真正的位置，插入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抛开<mark>删除元素移动最小值</mark>而言，当我们所操作的是任意一个元素时，所进行的操作是先将其<mark>下降到最深深度</mark>，然后将其<mark>上升至适当位置</mark>，<strong>但是最终这个位置不能大于其原本的位置</strong>。</p>
<h4 id="make-heap"><a href="#make-heap" class="headerlink" title="make_heap"></a>make_heap</h4><p>递归调用<code>__adjust_heap()</code>进行调整 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [first, last) 调整为 heap</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">__make_heap(_RandomAccessIterator __first,</span><br><span class="line">            _RandomAccessIterator __last, _Tp*, _Distance*)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__last - __first &lt; <span class="number">2</span>) <span class="keyword">return</span>; <span class="comment">// 如果长度为 0 或 1，不排列</span></span><br><span class="line">  _Distance __len = __last - __first; <span class="comment">// 待排列的长度</span></span><br><span class="line">  _Distance __parent = (__len - <span class="number">2</span>)/<span class="number">2</span>; <span class="comment">// 父节点i和右子节点2i+2</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">// 这里 __parent 就是待插入节点索引</span></span><br><span class="line">    __adjust_heap(__first, __parent, __len, _Tp(*(__first + __parent)));</span><br><span class="line">    <span class="keyword">if</span> (__parent == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    __parent--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sort-heap"><a href="#sort-heap" class="headerlink" title="sort_heap"></a>sort_heap</h4><p>重复调用<code>pop_heap</code>函数，将当前最大值丢到尾部。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> </span></span><br><span class="line"><span class="function"><span class="title">sort_heap</span><span class="params">(_RandomAccessIterator __first,</span></span></span><br><span class="line"><span class="params"><span class="function">          _RandomAccessIterator __last, _Compare __comp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __STL_REQUIRES(_RandomAccessIterator, _Mutable_RandomAccessIterator);</span><br><span class="line">  <span class="keyword">while</span> (__last - __first &gt; <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">pop_heap</span>(__first, __last--, __comp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>既然sort_heap已经可以实现排序，那make_heap作用？</p>
</blockquote>
<p>首先，我们在<code>priority_queue</code>底层了解到其存在如下构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">priority_queue</span>(<span class="keyword">const</span> value_type* __first, <span class="keyword">const</span> value_type* __last) </span><br><span class="line">    : <span class="built_in">c</span>(__first, __last) &#123; <span class="built_in">make_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp); &#125;</span><br></pre></td></tr></table></figure>

<p>当我们为其传入一个<code>vector</code>的首尾指针时（测试<code>list</code>亦可），会先把相应的值赋给底层容器里，然后调用<code>make_heap</code>函数，将拷贝到底层容器里的值进行排序。</p>
<blockquote>
<p>后话：暂时在该版本源码中并未发现sort_heap的调用</p>
</blockquote>
<h2 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h2><h3 id="RB-Tree"><a href="#RB-Tree" class="headerlink" title="RB-Tree"></a>RB-Tree</h3><p>红黑树，是一个自平衡的<mark>二叉搜索树</mark>。</p>
<p>首先用<code>bool</code>类型定义结点的红黑色。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">bool</span> _Rb_tree_Color_type;</span><br><span class="line"><span class="keyword">const</span> _Rb_tree_Color_type _S_rb_tree_red = <span class="literal">false</span>; <span class="comment">// 红色为 0</span></span><br><span class="line"><span class="keyword">const</span> _Rb_tree_Color_type _S_rb_tree_black = <span class="literal">true</span>; <span class="comment">// 黑色为 1</span></span><br></pre></td></tr></table></figure>

<h4 id="header"><a href="#header" class="headerlink" title="header"></a>header</h4><p>红黑树的虚拟头结点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Rb_tree_base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    _Rb_tree_node&lt;_Tp&gt;* _M_header;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">Rb_tree</span> :</span> <span class="keyword">protected</span> _Rb_tree_base&lt;_Value, _Alloc&gt; &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    size_type _M_node_count; <span class="comment">// keeps track of size of tree 节点数量</span></span><br><span class="line">    _Compare _M_key_compare; <span class="comment">// 节点间的键值大小比较准则</span></span><br><span class="line">&#125;;</span><br><span class="line">_Link_type&amp; _M_root() <span class="keyword">const</span> </span><br><span class="line">&#123; <span class="keyword">return</span> (_Link_type&amp;) _M_header-&gt;_M_parent; &#125;</span><br><span class="line">_Link_type&amp; _M_leftmost() <span class="keyword">const</span> </span><br><span class="line">&#123; <span class="keyword">return</span> (_Link_type&amp;) _M_header-&gt;_M_left; &#125;</span><br><span class="line">_Link_type&amp; _M_rightmost() <span class="keyword">const</span> </span><br><span class="line">&#123; <span class="keyword">return</span> (_Link_type&amp;) _M_header-&gt;_M_right; &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对于一个空树而言。<ul>
<li><code>header</code>的<code>left  right</code>指针指向自己</li>
<li><code>header-&gt;parent = nullptr</code></li>
</ul>
</li>
<li>红黑树非空<ul>
<li><code>root-&gt;parent = header</code> &amp;&amp; <code>header-&gt;parent = root</code></li>
<li><code>header-&gt;left = leftmost(最小值结点)</code> &amp;&amp; <code>header-&gt;right = rightmost(最大值结点)</code></li>
</ul>
</li>
</ul>
<h4 id="node"><a href="#node" class="headerlink" title="node"></a>node</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Rb_tree_node_base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> _Rb_tree_Color_type _Color_type;</span><br><span class="line">  <span class="keyword">typedef</span> _Rb_tree_node_base* _Base_ptr;</span><br><span class="line">  _Color_type _M_color;   <span class="comment">// 节点颜色，非红即黑</span></span><br><span class="line">  _Base_ptr _M_parent;    <span class="comment">// 父节点</span></span><br><span class="line">  _Base_ptr _M_left;      <span class="comment">// 左节点</span></span><br><span class="line">  _Base_ptr _M_right;     <span class="comment">// 右节点</span></span><br><span class="line">    <span class="comment">//此外，还有找最大值、最小值的函数，二叉搜索树最大值、最小值即为最右侧、最左侧结点。</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Value</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Rb_tree_node</span> :</span> <span class="keyword">public</span> _Rb_tree_node_base</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typedef</span> _Rb_tree_node&lt;_Value&gt;* _Link_type;</span><br><span class="line">  _Value _M_value_field;  <span class="comment">// 节点值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RB-tree 的迭代器-基类</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Rb_tree_base_iterator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> _Rb_tree_node_base::_Base_ptr _Base_ptr;</span><br><span class="line">  _Base_ptr _M_node; <span class="comment">// 它用来与容器之间产生一个连接关系</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="decrement-increment"><a href="#decrement-increment" class="headerlink" title="decrement/increment"></a>decrement/increment</h4><p>迭代器<code>++/--</code>的底层，用于寻找前驱、后继节点（按值的大小序），但其中对虚拟header结点有着特殊处理。最左值的前一个和最右值的后一个结点均为header</p>
<h4 id="end"><a href="#end" class="headerlink" title="end()"></a>end()</h4><p>返回最右值的后一个元素(header)</p>
<h4 id="equal-range"><a href="#equal-range" class="headerlink" title="equal_range"></a>equal_range</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Key</span>, <span class="keyword">class</span> _<span class="title">Value</span>, <span class="keyword">class</span> _<span class="title">KeyOfValue</span>,  <span class="keyword">class</span> _<span class="title">Compare</span>, <span class="keyword">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> pair&lt;<span class="keyword">typename</span> _Rb_tree&lt;_Key,_Value,_KeyOfValue,_Compare,_Alloc&gt;::iterator,</span><br><span class="line">     		<span class="keyword">typename</span> _Rb_tree&lt;_Key,_Value,_KeyOfValue,_Compare,_Alloc&gt;::iterator&gt;</span><br><span class="line">_Rb_tree&lt;_Key,_Value,_KeyOfValue,_Compare,_Alloc&gt;::<span class="built_in">equal_range</span>(<span class="keyword">const</span> _Key&amp; __k)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> pair&lt;iterator, iterator&gt;(<span class="built_in">lower_bound</span>(__k), <span class="built_in">upper_bound</span>(__k));</span><br><span class="line">&#125;<span class="comment">// key == _k的结点迭代器所在的范围。</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>lower_bound(const _Key&amp; __k)  —  <strong>不小于k</strong>的第一个节点的迭代器</p>
</li>
<li><p>upper_bound(const _Key&amp; __k)  —  <strong>大于k</strong>的第一个节点的迭代器</p>
</li>
</ul>
<h4 id="rb-verify"><a href="#rb-verify" class="headerlink" title="__rb_verify()"></a>__rb_verify()</h4><p>判断红黑树<mark>是否合法</mark>。（满足红黑树的性质）</p>
<p>源码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Key</span>, <span class="keyword">class</span> _<span class="title">Value</span>, <span class="keyword">class</span> _<span class="title">KeyOfValue</span>,  <span class="keyword">class</span> _<span class="title">Compare</span>, <span class="keyword">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> _Rb_tree&lt;_Key,_Value,_KeyOfValue,_Compare,_Alloc&gt;::__rb_verify() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_M_node_count == <span class="number">0</span> || <span class="built_in">begin</span>() == <span class="built_in">end</span>())</span><br><span class="line">        <span class="keyword">return</span> _M_node_count == <span class="number">0</span> &amp;&amp; <span class="built_in">begin</span>() == <span class="built_in">end</span>() &amp;&amp;</span><br><span class="line">        _M_header-&gt;_M_left == _M_header &amp;&amp; _M_header-&gt;_M_right == _M_header;</span><br><span class="line">  <span class="comment">//true代表此空树符合红黑树的性质</span></span><br><span class="line">    <span class="keyword">int</span> __len = __black_count(_M_leftmost(), _M_root());	<span class="comment">//每个分支上黑节点个数</span></span><br><span class="line">    <span class="keyword">for</span> (const_iterator __it = <span class="built_in">begin</span>(); __it != <span class="built_in">end</span>(); ++__it) &#123;</span><br><span class="line">        _Link_type __x = (_Link_type) __it._M_node;</span><br><span class="line">        _Link_type __L = _S_left(__x);</span><br><span class="line">        _Link_type __R = _S_right(__x);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//红黑树性质之 红节点的子节点均为黑</span></span><br><span class="line">        <span class="keyword">if</span> (__x-&gt;_M_color == _S_rb_tree_red)</span><br><span class="line">            <span class="keyword">if</span> ((__L &amp;&amp; __L-&gt;_M_color == _S_rb_tree_red) ||</span><br><span class="line">                (__R &amp;&amp; __R-&gt;_M_color == _S_rb_tree_red))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="comment">//二叉搜素树结点间大小关系</span></span><br><span class="line">        <span class="keyword">if</span> (__L &amp;&amp; _M_key_compare(_S_key(__x), _S_key(__L)))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (__R &amp;&amp; _M_key_compare(_S_key(__R), _S_key(__x)))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">//统计一条分支上黑节点个数 与基准值不同  则不符合</span></span><br><span class="line">        <span class="keyword">if</span> (!__L &amp;&amp; !__R &amp;&amp; __black_count(__x, _M_root()) != __len)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//左节点不是最小值、右节点不是最大值</span></span><br><span class="line">    <span class="keyword">if</span> (_M_leftmost() != _Rb_tree_node_base::_S_minimum(_M_root()))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (_M_rightmost() != _Rb_tree_node_base::_S_maximum(_M_root()))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="set-multiset"><a href="#set-multiset" class="headerlink" title="set/multiset"></a>set/multiset</h3><p>底层容器为红黑树。函数实现为调用红黑树相应的函数。两个的区别在于<code>insert</code>函数</p>
<ul>
<li>set调用红黑树的<code>insert_unique</code>函数</li>
<li>multiset调用红黑树的<code>insert_equal</code>函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Key</span>, <span class="keyword">class</span> _<span class="title">Compare</span>, <span class="keyword">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">set</span>&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> _Key     key_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Key     value_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Compare key_compare;</span><br><span class="line">    <span class="keyword">typedef</span> _Compare value_compare;</span><br><span class="line">    <span class="keyword">typedef</span> _Rb_tree&lt;key_type, value_type, _Identity&lt;value_type&gt;, key_compare, _Alloc&gt; _Rep_type;</span><br><span class="line">    <span class="comment">// set 的底层实现为 RB-tree</span></span><br><span class="line">    _Rep_type _M_t;  <span class="comment">// red-black tree representing set</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="map-multimap"><a href="#map-multimap" class="headerlink" title="map/multimap"></a>map/multimap</h3><p>除了下述基础结构和<code>set/mutiset</code>有细微差距外，整体与<code>set/mutiset</code>类似、</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Key</span>, <span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Compare</span>, <span class="keyword">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">map</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> _Key                  key_type; <span class="comment">// 键值类型</span></span><br><span class="line">    <span class="keyword">typedef</span> _Tp                   data_type; <span class="comment">// 实值类型</span></span><br><span class="line">    <span class="keyword">typedef</span> _Tp                   mapped_type;</span><br><span class="line">    <span class="keyword">typedef</span> pair&lt;<span class="keyword">const</span> _Key, _Tp&gt; value_type;  <span class="comment">// 元素类型(键值/实值)</span></span><br><span class="line">    <span class="keyword">typedef</span> _Compare              key_compare; <span class="comment">// 键值比较函数</span></span><br><span class="line">    _Compare comp;</span><br><span class="line">    <span class="keyword">typedef</span> _Rb_tree&lt;key_type, value_type,  _Select1st&lt;value_type&gt;, key_compare, _Alloc&gt; _Rep_type; </span><br><span class="line">    <span class="comment">// map 的底层机制 RB-tree </span></span><br><span class="line">    _Rep_type _M_t;  <span class="comment">// red-black tree representing map 以红黑树(RB-tree) 表现 map</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h3><p> map 的结构是键值对 <code>&lt;Key, value&gt;</code>，这种结构在底层以<code>pair</code>形式存储。基本结构如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">T1</span>, <span class="keyword">class</span> _<span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pair</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> _T1 first_type;</span><br><span class="line">    <span class="keyword">typedef</span> _T2 second_type;</span><br><span class="line">    _T1 first;  <span class="comment">// 第一个参数</span></span><br><span class="line">    _T2 second; <span class="comment">// 第二个参数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="opertor-lt"><a href="#opertor-lt" class="headerlink" title="opertor&lt;"></a>opertor&lt;</h4><p>先比较第一参数大小关系，第一参数相等时，再比较第二参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">T1</span>, <span class="keyword">class</span> _<span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> pair&lt;_T1, _T2&gt;&amp; __x, <span class="keyword">const</span> pair&lt;_T1, _T2&gt;&amp; __y)</span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">return</span> __x.first &lt; __y.first || (!(__y.first &lt; __x.first) &amp;&amp; __x.second &lt; __y.second); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="make-pair"><a href="#make-pair" class="headerlink" title="make_pair"></a>make_pair</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">T1</span>, <span class="keyword">class</span> _<span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> pair&lt;_T1, _T2&gt; <span class="title">make_pair</span><span class="params">(<span class="keyword">const</span> _T1&amp; __x, <span class="keyword">const</span> _T2&amp; __y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pair&lt;_T1, _T2&gt;(__x, __y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h3><p>整体实现上与<code>bit_vector</code>有些类似。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> _Nw&gt;	<span class="comment">//使用时传入的bitset中的位数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Base_bitset</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> _WordT;</span><br><span class="line"></span><br><span class="line">    _WordT _M_w[_Nw];</span><br><span class="line">&#125;:</span><br></pre></td></tr></table></figure>

<h4 id="BITSET-WORDS"><a href="#BITSET-WORDS" class="headerlink" title="__BITSET_WORDS"></a>__BITSET_WORDS</h4><p>当我们声明一个<code>bitset</code>时，该宏定义用于计算出需要多少个<code>unsigned int</code>才能存储这些<code>bit</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __BITSET_WORDS(__n) ((__n) &lt; 1 ? 1 : ((__n) + __BITS_PER_WORD - 1)/__BITS_PER_WORD)</span></span><br></pre></td></tr></table></figure>

<p>由于操作系统位数不同，可能会带来歧义。该模块用于自动推导出<code>unsigned int</code>所占空间大小。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __BITS_PER_WORD (CHAR_BIT*sizeof(unsigned long))</span></span><br></pre></td></tr></table></figure>

<h4 id="Bit-count"><a href="#Bit-count" class="headerlink" title="_Bit_count"></a>_Bit_count</h4><p>该数组提供一个对照表用于判断角标所代表元素的二进制标志中<code>1</code>的个数。</p>
<p>如 $7=111_{(2)}$,故<code>_Bit_count[7] = 3</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> __dummy&gt; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Bit_count</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> _S_bit_count[<span class="number">256</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="First-one"><a href="#First-one" class="headerlink" title="_First_one"></a>_First_one</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> __dummy&gt; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">First_one</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> _S_first_one[<span class="number">256</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>同样的，该数组也起到对照作用。该数组表示首个<code>1</code>开始，后面二进制值为<code>0</code>的个数。</p>
<p>如 $7 = 111_{(2)}$,故<code>_First_one[7] = 0</code></p>
<h4 id="S-whichword"><a href="#S-whichword" class="headerlink" title="_S_whichword"></a>_S_whichword</h4><p>获取比特位<code>__pos</code>在数组中的下标。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> _S_whichword( <span class="keyword">size_t</span> __pos )</span><br><span class="line">	&#123; <span class="keyword">return</span> __pos / __BITS_PER_WORD; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="S-whichbyte"><a href="#S-whichbyte" class="headerlink" title="_S_whichbyte"></a>_S_whichbyte</h4><p>获取在<code>word</code>中第几个char</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> _S_whichbyte( <span class="keyword">size_t</span> __pos )</span><br><span class="line">	&#123; <span class="keyword">return</span> (__pos % __BITS_PER_WORD) / CHAR_BIT; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="S-whichbit"><a href="#S-whichbit" class="headerlink" title="_S_whichbit"></a>_S_whichbit</h4><p>获取在<code>word</code>中第几个<code>bit</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> _S_whichbit( <span class="keyword">size_t</span> __pos )</span><br><span class="line">        &#123; <span class="keyword">return</span> __pos % __BITS_PER_WORD; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="S-maskbit"><a href="#S-maskbit" class="headerlink" title="_S_maskbit"></a>_S_maskbit</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> _WordT;</span><br><span class="line"><span class="keyword">static</span> _WordT _S_maskbit( <span class="keyword">size_t</span> __pos )</span><br><span class="line">    &#123; <span class="keyword">return</span> (<span class="keyword">static_cast</span>&lt;_WordT&gt;(<span class="number">1</span>)) &lt;&lt; _S_whichbit(__pos); &#125;</span><br></pre></td></tr></table></figure>

<p>移位，以供<code>set  reset  flip</code>等调用</p>
<p>为实现一些功能，封装了一些简单函数</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">含义</th>
<th align="center">调用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">_M_do_and()</td>
<td align="center">bitset之间逻辑<strong>与</strong></td>
<td align="center">&amp;  &amp;=</td>
</tr>
<tr>
<td align="center">_M_do_or()</td>
<td align="center">bitset之间逻辑<strong>或</strong></td>
<td align="center">|  |=</td>
</tr>
<tr>
<td align="center">_M_do_xor()</td>
<td align="center">bitset之间逻辑<strong>异或</strong></td>
<td align="center">^  ^=</td>
</tr>
<tr>
<td align="center">_M_do_flip()</td>
<td align="center">逐元素取反</td>
<td align="center">flip()  ~</td>
</tr>
<tr>
<td align="center">_M_do_left_shift()</td>
<td align="center">左移</td>
<td align="center">&lt;&lt;  &lt;&lt;=</td>
</tr>
<tr>
<td align="center">_M_do_right_shift()</td>
<td align="center">右移</td>
<td align="center">&gt;&gt;  &gt;&gt;=</td>
</tr>
<tr>
<td align="center">_M_do_set()</td>
<td align="center">置为1</td>
<td align="center">set()</td>
</tr>
<tr>
<td align="center">_M_do_reset()</td>
<td align="center">置为0</td>
<td align="center">reset()</td>
</tr>
<tr>
<td align="center">_M_is_equal()</td>
<td align="center">判断是否相等</td>
<td align="center">==  !=</td>
</tr>
<tr>
<td align="center">_M_is_any()</td>
<td align="center">是否有值为<code>1</code>的位</td>
<td align="center">any()  none()</td>
</tr>
<tr>
<td align="center">_M_do_count()</td>
<td align="center">值为<code>1</code>的位的个数</td>
<td align="center">count()</td>
</tr>
<tr>
<td align="center">_M_do_to_ulong()</td>
<td align="center">01串转换成整数</td>
<td align="center">to_ulong()</td>
</tr>
<tr>
<td align="center">_M_copy_to_string()</td>
<td align="center">赋值给string</td>
<td align="center">to_string()</td>
</tr>
</tbody></table>
<h4 id="重载cin-cout"><a href="#重载cin-cout" class="headerlink" title="重载cin/cout"></a>重载cin/cout</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> _Nb&gt;</span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; __is, bitset&lt;_Nb&gt;&amp; __x) &#123;</span><br><span class="line">    string __tmp;</span><br><span class="line">    __tmp.<span class="built_in">reserve</span>(_Nb);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__is.<span class="built_in">flags</span>() &amp; ios::skipws) &#123;</span><br><span class="line">        <span class="keyword">char</span> __c;</span><br><span class="line">        <span class="keyword">do</span> </span><br><span class="line">            __is.<span class="built_in">get</span>(__c);</span><br><span class="line">        <span class="keyword">while</span> (__is &amp;&amp; <span class="built_in">isspace</span>(__c));</span><br><span class="line">        <span class="keyword">if</span> (__is)</span><br><span class="line">            __is.<span class="built_in">putback</span>(__c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> __i = <span class="number">0</span>; __i &lt; _Nb; ++__i) &#123;</span><br><span class="line">        <span class="keyword">char</span> __c;</span><br><span class="line">        __is.<span class="built_in">get</span>(__c);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!__is)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (__c != <span class="string">&#x27;0&#x27;</span> &amp;&amp; __c != <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">            __is.<span class="built_in">putback</span>(__c);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            __tmp.<span class="built_in">push_back</span>(__c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__tmp.<span class="built_in">empty</span>()) </span><br><span class="line">        __is.<span class="built_in">clear</span>(__is.<span class="built_in">rdstate</span>() | ios::failbit);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        __x._M_copy_from_string(__tmp, <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(<span class="number">0</span>), _Nb);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> __is;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出 以字符串形式输出</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> _Nb&gt;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; __os, <span class="keyword">const</span> bitset&lt;_Nb&gt;&amp; __x) &#123;</span><br><span class="line">    string __tmp;</span><br><span class="line">    __x._M_copy_to_string(__tmp);</span><br><span class="line">    <span class="keyword">return</span> __os &lt;&lt; __tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="hashtable"><a href="#hashtable" class="headerlink" title="hashtable"></a>hashtable</h3><p>哈希表的链式避免冲突法在成链时，新插入的元素在头部。（头插）</p>
<h4 id="结点"><a href="#结点" class="headerlink" title="结点"></a>结点</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Val</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Hashtable_node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _Hashtable_node* _M_next;	<span class="comment">//用于链式连接</span></span><br><span class="line">  _Val _M_val;</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Val</span>, <span class="keyword">class</span> _<span class="title">Key</span>, <span class="keyword">class</span> _<span class="title">HashFcn</span>,</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> _<span class="title">ExtractKey</span>, <span class="keyword">class</span> _<span class="title">EqualKey</span>, <span class="keyword">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Hashtable_iterator</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> hashtable&lt;_Val,_Key,_HashFcn,_ExtractKey,_EqualKey,_Alloc&gt; _Hashtable;</span><br><span class="line">    <span class="keyword">typedef</span> _Hashtable_node&lt;_Val&gt; _Node; <span class="comment">// hash table 节点</span></span><br><span class="line">    <span class="keyword">typedef</span> forward_iterator_tag iterator_category; <span class="comment">// 迭代器类型：前向迭代器</span></span><br><span class="line"></span><br><span class="line">    _Node* _M_cur; <span class="comment">// 迭代器目前所指的节点</span></span><br><span class="line">    _Hashtable* _M_ht; <span class="comment">// 保持对容器的连接关系，bucket</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="bucket"><a href="#bucket" class="headerlink" title="bucket"></a>bucket</h4><p>一共提供28个bucket大小。设置的原则为，2倍扩充附近的质数。分别如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> __stl_num_primes = <span class="number">28</span> &#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> __stl_prime_list[__stl_num_primes] =</span><br><span class="line">&#123;</span><br><span class="line">  <span class="number">53ul</span>,         <span class="number">97ul</span>,         <span class="number">193ul</span>,       <span class="number">389ul</span>,       <span class="number">769ul</span>,</span><br><span class="line">  <span class="number">1543ul</span>,       <span class="number">3079ul</span>,       <span class="number">6151ul</span>,      <span class="number">12289ul</span>,     <span class="number">24593ul</span>,</span><br><span class="line">  <span class="number">49157ul</span>,      <span class="number">98317ul</span>,      <span class="number">196613ul</span>,    <span class="number">393241ul</span>,    <span class="number">786433ul</span>,</span><br><span class="line">  <span class="number">1572869ul</span>,    <span class="number">3145739ul</span>,    <span class="number">6291469ul</span>,   <span class="number">12582917ul</span>,  <span class="number">25165843ul</span>,</span><br><span class="line">  <span class="number">50331653ul</span>,   <span class="number">100663319ul</span>,  <span class="number">201326611ul</span>, <span class="number">402653189ul</span>, <span class="number">805306457ul</span>, </span><br><span class="line">  <span class="number">1610612741ul</span>, <span class="number">3221225473ul</span>, <span class="number">4294967291ul</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="hashtable-1"><a href="#hashtable-1" class="headerlink" title="hashtable"></a>hashtable</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Val</span>, <span class="keyword">class</span> _<span class="title">Key</span>, <span class="keyword">class</span> _<span class="title">HashFcn</span>,</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> _<span class="title">ExtractKey</span>, <span class="keyword">class</span> _<span class="title">EqualKey</span>, <span class="keyword">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hashtable</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _Key key_type; <span class="comment">// 节点的键值</span></span><br><span class="line">    <span class="keyword">typedef</span> _Val value_type; <span class="comment">// 节点的实值</span></span><br><span class="line">    <span class="keyword">typedef</span> _HashFcn hasher; <span class="comment">// 哈希函数</span></span><br><span class="line">    <span class="keyword">typedef</span> _EqualKey key_equal; <span class="comment">// 判断键值是否相同</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _Hashtable_node&lt;_Val&gt; _Node; <span class="comment">// 节点</span></span><br><span class="line">    hasher                _M_hash;</span><br><span class="line">    key_equal             _M_equals;</span><br><span class="line">    _ExtractKey           _M_get_key;</span><br><span class="line">    vector&lt;_Node*,_Alloc&gt; _M_buckets; <span class="comment">// vector 容器</span></span><br><span class="line">    size_type             _M_num_elements;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>_Val  —  节点的实值类型</p>
</li>
<li><p>_Key  —  节点的键值类型</p>
</li>
<li><p>_HashFcn  —  哈希函数的类型</p>
</li>
<li><p>_ExtractKey  —  从节点中取出键值的方法</p>
</li>
<li><p>_EqualKey  —  判断键值是否相同的方法</p>
</li>
<li><p>_Alloc  —  空间配置器</p>
</li>
</ul>
<h4 id="bkt-num"><a href="#bkt-num" class="headerlink" title="bkt_num"></a>bkt_num</h4><p>我们知道可以通过<code>Key</code>来获取到元素相应的<code>bucket</code>、重复的个数等信息。利用该函数，可以通过<code>Value</code>获取到相应信息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">size_type _M_bkt_num(<span class="keyword">const</span> value_type&amp; __obj) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _M_bkt_num_key(_M_get_key(__obj));</span><br><span class="line">&#125;</span><br><span class="line">size_type _M_bkt_num(<span class="keyword">const</span> value_type&amp; __obj, <span class="keyword">size_t</span> __n) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _M_bkt_num_key(_M_get_key(__obj), __n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//向上寻定义	_ExtractKey           _M_get_key;</span></span><br></pre></td></tr></table></figure>

<h4 id="stl-hash-string"><a href="#stl-hash-string" class="headerlink" title="__stl_hash_string"></a>__stl_hash_string</h4><p>各种数字(<code>int</code>、<code>unsigned int</code>、<code>long</code>、<code>unsigned long</code>、<code>short</code>)以及字符<code>char</code>进行传入的是原值、除此之外字符串类型(<code>char*</code>)会进行转换:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">size_t</span> __stl_hash_string(<span class="keyword">const</span> <span class="keyword">char</span>* __s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> __h = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> ( ; *__s; ++__s)</span><br><span class="line">        __h = <span class="number">5</span>*__h + *__s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">size_t</span>(__h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="hashmap-hashset"><a href="#hashmap-hashset" class="headerlink" title="hashmap/hashset"></a>hashmap/hashset</h3><p><code>hash_set/hash_map</code> 底层实现机制是<code> hash table</code>，所以 <code>hash_set/hash_map</code> 内部实现就是封装<code>hashtable</code>类。与map/set和<code>multimap/multiset</code>基于红黑树改装类似，再次不过多赘述。</p>

    </div>

    
    
    
<div>
  
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------感谢阅读<i class="fa fa-heart"></i>有缘再见-------------</div>
    
</div>
  
</div>

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/CPP/" rel="tag"><i class="fa fa-tag"></i> CPP</a>
              <a href="/tags/SGI-STL/" rel="tag"><i class="fa fa-tag"></i> SGI_STL</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" rel="prev" title="STL源码剖析">
      <i class="fa fa-chevron-left"></i> STL源码剖析
    </a></div>
      <div class="post-nav-item">
    <a href="/STL%E6%BA%90%E7%A0%81-%E5%88%86%E9%85%8D%E5%99%A8/" rel="next" title="STL源码-分配器">
      STL源码-分配器 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E5%9E%8B%E5%AE%B9%E5%99%A8"><span class="nav-text">顺序型容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#vector"><span class="nav-text">vector</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#pragma-set-woff-XXX"><span class="nav-text">#pragma set woff XXX</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#static-assert"><span class="nav-text">static_assert</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#noexcept"><span class="nav-text">noexcept</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#explicit"><span class="nav-text">explicit</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#const-iterator"><span class="nav-text">const_iterator</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#max-size"><span class="nav-text">max_size()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#copy"><span class="nav-text">copy()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#construct"><span class="nav-text">construct()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#copy-backward"><span class="nav-text">copy_backward()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bit-vector"><span class="nav-text">bit_vector</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#flip"><span class="nav-text">flip()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#list"><span class="nav-text">list</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#begin-end"><span class="nav-text">begin()&#x2F;end()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#transfer"><span class="nav-text">transfer()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#splice"><span class="nav-text">splice()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#unique"><span class="nav-text">unique()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#merge"><span class="nav-text">merge()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sort"><span class="nav-text">sort()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#slist"><span class="nav-text">slist</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#slist-splice-after"><span class="nav-text">__slist_splice_after()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#M-erase-after"><span class="nav-text">_M_erase_after()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#begin-end-1"><span class="nav-text">begin()&#x2F;end()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#push-pop"><span class="nav-text">push&#x2F;pop</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#previous"><span class="nav-text">previous()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#deque"><span class="nav-text">deque</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E6%9E%84"><span class="nav-text">结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Deque-iterator"><span class="nav-text">_Deque_iterator</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#operator"><span class="nav-text">operator-</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#M-initialize-map"><span class="nav-text">_M_initialize_map()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#erase-iterator-pos"><span class="nav-text">erase(iterator __pos)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#M-reserve-map-at-back"><span class="nav-text">_M_reserve_map_at_back()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#M-insert-aux"><span class="nav-text">_M_insert_aux()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stack-queue"><span class="nav-text">stack&#x2F;queue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#priority-queue"><span class="nav-text">priority_queue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#heap"><span class="nav-text">heap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#push-heap"><span class="nav-text">push_heap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pop-heap"><span class="nav-text">pop_heap</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#adjust-heap"><span class="nav-text">__adjust_heap</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#make-heap"><span class="nav-text">make_heap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sort-heap"><span class="nav-text">sort_heap</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8"><span class="nav-text">关联式容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RB-Tree"><span class="nav-text">RB-Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#header"><span class="nav-text">header</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#node"><span class="nav-text">node</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#iterator"><span class="nav-text">iterator</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#decrement-increment"><span class="nav-text">decrement&#x2F;increment</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#end"><span class="nav-text">end()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#equal-range"><span class="nav-text">equal_range</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rb-verify"><span class="nav-text">__rb_verify()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set-multiset"><span class="nav-text">set&#x2F;multiset</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map-multimap"><span class="nav-text">map&#x2F;multimap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pair"><span class="nav-text">pair</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#opertor-lt"><span class="nav-text">opertor&lt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#make-pair"><span class="nav-text">make_pair</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bitset"><span class="nav-text">bitset</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#BITSET-WORDS"><span class="nav-text">__BITSET_WORDS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Bit-count"><span class="nav-text">_Bit_count</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#First-one"><span class="nav-text">_First_one</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#S-whichword"><span class="nav-text">_S_whichword</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#S-whichbyte"><span class="nav-text">_S_whichbyte</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#S-whichbit"><span class="nav-text">_S_whichbit</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#S-maskbit"><span class="nav-text">_S_maskbit</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E8%BD%BDcin-cout"><span class="nav-text">重载cin&#x2F;cout</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hashtable"><span class="nav-text">hashtable</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E7%82%B9"><span class="nav-text">结点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-text">迭代器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bucket"><span class="nav-text">bucket</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hashtable-1"><span class="nav-text">hashtable</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bkt-num"><span class="nav-text">bkt_num</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#stl-hash-string"><span class="nav-text">__stl_hash_string</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hashmap-hashset"><span class="nav-text">hashmap&#x2F;hashset</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">某卑微社畜</p>
  <div class="site-description" itemprop="description">爱过</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">44</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/ikun7355608" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ikun7355608" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:goudan.wang@outlook.com" title="邮箱 → mailto:goudan.wang@outlook.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>邮箱</a>
      </span>
      <span class="links-of-author-item">
        <a href="tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=1992018857&website=www.oicqzone.com" title="QQ → tencent:&#x2F;&#x2F;AddContact&#x2F;?fromId&#x3D;45&amp;fromSubId&#x3D;1&amp;subcmd&#x3D;all&amp;uin&#x3D;1992018857&amp;website&#x3D;www.oicqzone.com" rel="noopener" target="_blank"><i class="fab fa-qq fa-fw"></i>QQ</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2021 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">某卑微社畜</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">239k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:37</span>
<div>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv" style='display:none'>
    有<span id="busuanzi_value_site_uv"></span>人看过我的博客啦
</span>
</div>
</div>
<div>
<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
    var now = new Date(); 
    function createtime() { 
        var grt= new Date("12/29/2021 12:00:00");//在此处修改你的建站时间
        now.setTime(now.getTime()+250); 
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
        document.getElementById("timeDate").innerHTML = "已运行 "+dnum+" 天 "; 
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
    } 
setInterval("createtime()",250);
</script>
</div>
<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>
-->
        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
