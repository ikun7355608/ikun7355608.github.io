<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>我的大学</title>
      <link href="/%E6%88%91%E7%9A%84%E5%A4%A7%E5%AD%A6/"/>
      <url>/%E6%88%91%E7%9A%84%E5%A4%A7%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<p>谨以此文纪念我的大学时光</p><span id="more"></span><h2 id="生涯规划"><a href="#生涯规划" class="headerlink" title="生涯规划"></a>生涯规划</h2><p>步入大学没有了之前那种固定的长远目标，似乎未来充满着无限可能，却又无从下手。刚入学的时候，对自己的未来还没有任何规划，但学校里的人、事都在烘托着一种「读研是大学的最好出路」的氛围：保研名校的学长学姐系列讲座；升学率宣传；同学、家长的学历崇拜……似乎大学和之前的阶段一样，目的是拿到下一阶段的入场券。刚入学时，每天都能听到学长学姐的保研、考研、求职的光辉事迹，但其实只是当个故事听，也并没有考虑过将来自己想做什么。刚摆脱高中那种压抑的环境（每天12点睡5点起，还因为午休时间午睡被请过家长），每天都在报复性的玩乐。教务处排课会避开周三下午，每周三下午我都能狂睡3、4个小时。</p><p>开学不久认识了两个学长，也是整个大一关系比较好的唯一的两个。A学长当时大四，他从大二开始就以实验室为家，寒暑假也要泡在实验室里做实验（甚至有一年过年都没回），最终成功保研；B学长当时研一，大学吃喝玩乐三年多，最后考研上岸。我每天接受的熏陶也都是要好好学习，准备考研。这时我的大学目标是<strong>保研</strong>。为了这个目标，大一上学期非常刻苦的学习了一学期。秋季学期结束后，排名大概在20%左右，基本上这样持续下去的话，也能够达到保研的要求。大一下学期疫情爆发，在家里上了一学期的网课，也是这个信念支撑这我每天认真学习。快期末的时候，学校的老师似乎清楚线上教学的问题，许多课程的考核标准降低了很多，这让基础相对比较扎实的我许多课程都取得了相对不错的成绩，排名一路冲到了前5%。大一结束学院进行专业分流，当时学的是机械，唯一的一门专业课是工图（我四年分最低的几门课之一），学不会工图的我对这个学院的专业产生畏惧，觉得自己学不会这个方向。于是，选择了转专业。当时互联网行业很热门，于是选择了软件学院，但是我的排名只是刚触碰到转专业的底线，又怕自己被刷下去被迫留在原学院。于是选择了软件学院的一个冷门的专业——信息安全。</p><p>刚转过去的时候，看到了新的专业排名——50%。此时的我每天都很焦虑，因为我很难再触碰到那个保研的最低排名要求（本身并没有相关基础，而且和要求存在较大差距）。虽然很焦虑但生活还要继续，学习时间更长了，每天都憋在图书馆里学习。这样持续了一年后，排名也并没有提高多少。而且这期间目睹了很多同学混分的事（因为更多的考核是实验，很多排名靠前的实验直接用学长学姐的，然后写一篇特别优质的实验报告），我付出的比他们要多很多，得到的却无法与之比拟。</p><p>大三上学期，虽然大二发生的事动摇了我保研的决心，但我的目标还是读研。因为目标变成了<strong>考研</strong>，不必再在意那些课程的成绩。这也使得我的生活丰富了许多，每天读书、看电影、打游戏（因为疫情封校只能在校园里活动）非常快乐。那段时光是我勉强能算得上真正意义上的大学时光的几个月。</p><p>大三上学期末的时候，开始真正的审视自己的未来问题（以前只是一个思想的萌芽并不清楚为什么要读研，只是大家都在做这件事），这次是真正的思考这个问题：我为什么要读研？思考了好久，发现我只是个俗人，我的目标只有金钱。像什么学术追求、职业方向、技术追求统统没有，<strong>我只在乎钱</strong>，给我一万五的月薪让我扫垃圾我都能干一辈子。想了一下，就算读研出来刚入职时月薪高3k，这三年的差价也很难在三五年内持平，更何况我三年也未必没有涨薪。这时就正式的放弃了读研的想法。此时只想着「打工不仅能致富，还能交友娶媳妇」。调研了一下网络安全行业，发现网安的待遇比起开发要低很多，于是目标就定为了开发岗。这一年半来接触过的也就只有C++，觉得这个还略微有点基础就开始准备C++相关的知识。</p><p>在大三下学期开学前以及大三下前两个月这段时间里都在准备C++后端所需要的知识：C++2.0、算法、网络、操作系统。当时的我觉得自己也就算半个科班（只学过计算机基础课），基础还不是很扎实，能进互联网大厂的唯一机会也就是实习转正。因而在3、4月份开始投实习时就没有投过非互联网行业的开发岗和互联网小厂。可惜心比天高，命比纸薄。最终并没有找到一份互联网大厂C++开发相关的实习，选择了去网安行业一探究竟。实习了一段时间，网安行业也成功的让我觉得当初选择走开发岗是正确的。</p><p>实习结束之后，8月份开始秋招。秋招了大概3个月，结果还算满意。（最近看到了学院的就业数据，对自己更加满意了。）</p><p>现阶段的生涯规划——活过试用期。</p><h2 id="情感"><a href="#情感" class="headerlink" title="情感"></a>情感</h2><p>本来是没打算写的，但是总觉得不写内容不够充实。（毕竟学习和谈恋爱是大学的两大主线任务）</p><p>我本身是一个思想很黑暗的人，就是所有的事情都做很坏（但不至于是最坏）的打算，对任何事情都不抱有多大期望。因而在很多事情发生时并不会有多伤心难过，相反很容易被一些小细节感动。这样的思想使得我并不缺少情感上的依赖（准确点说，是不需要）。爱情方面我总持有一个观点：「如果某天我谈恋爱了，绝对是因为性、因为我馋她身子，不会是因为爱」。然而我的良知又告诉：「即使给不了别人未来也要对别人负责。也许人家小姑娘不介意，但我介意。我怕我的行为导致她将来被男朋友嫌弃。」我知道这样的想法很天真、很傻逼，但是我做不到对明知给不了她未来的女生动手动脚。这样的想法就让我成功的单了四年，有些暧昧的苗头也都被我浇灭了。</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>真正意义上的大学时光只有一年半——疫情开始前的大一上、备案进出校的大二下、彻底放开的大四下。</p><p>大一上生活比较充实，平时参加一些文体活动，学累了就到处走走顺便买些零食、水果。这段时间虽然没有太多朋友，但是每天都和那为数不多的几个朋友在一起玩耍，关系维持的也都很好。这期间虽然有着保研的想法，但相对而言有难度的课程也比较少，平时大部分的时间都还是属于自己的。不过当时的思想并没有完全的从高中那个环境中脱离，活动的范围也只限于学校周边，并没有什么太多的娱乐活动。</p><p>大二下虽然是备案制可以较为随意的进出校，但是当时的心思都在为保研做准备上。再加上这一学期开了数据结构、操作系统、数据库、数学建模、密码学等太多的硬核专业课，这学期的大部分时光是泡在图书馆里，并没有太多的娱乐活动。偶尔出校几次，也只是吃个饭便回来，仅此而已。</p><p>大四下彻底放开之后的生活相对自由。大四下分为两个阶段，第一个阶段是毕设还没正式开始做毕设阶段，这期间组会大概在每周五进行，开完组会到下个周二的时光每天都泡在图书馆里看自己喜欢的书籍，然后周三周四完成一下相应的任务。虽然每周都在做毕设相关的工作，但这些工作都没什么价值，更准确点描述是在探索毕设的可能。大概在四月底到五月中旬疯狂的写毕设，每天都会写到精神涣散，怀疑人生。第二阶段是从五月中旬到离校前，这一个月左右的时间是我大学最快乐的时光，这期间没有了那种无用的社交，抽空便和好朋友到处玩耍，探索未知领域以及新店铺，每天都很快乐很充实。</p><p>其实，封校与否并不是限制我生活的因素。因为我本身并没有什么兴趣爱好，唯一喜欢点的就是看书和看电影，这些并不会因为出不了学校而被限制。基本上每周都会看1~2部电影或电视剧，积累了一定的观影量。</p><h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 关于我 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>悖论13</title>
      <link href="/%E6%82%96%E8%AE%BA13/"/>
      <url>/%E6%82%96%E8%AE%BA13/</url>
      
        <content type="html"><![CDATA[<p>本文主要是源于前两天在图书馆借的一本小说「悖论13」相关的故事。</p><span id="more"></span><p>大四下学期除了毕设基本没啥事了，每天闲着就去图书馆借几本书读一读。前天晚上看完书，临走的时候在图书馆又借了这本「悖论13」，刚借的时候发现书中有一张折起来的六级成绩单，本来也不是什么大事，毕竟一张没过的六级成绩单随手丢在某本书里也挺常见的。</p><p><img src="/%E6%82%96%E8%AE%BA13/%E5%85%AD%E7%BA%A7.jpg" alt="六级成绩单"></p><p>今天下午在读这本书的时候，在书中发现了张小纸条让我感受到了来自读书人的浪漫。</p><p><img src="/%E6%82%96%E8%AE%BA13/%E6%A0%87%E7%AD%BE.jpg" alt="标签"></p><p>关于书中的细节，在此就不透露了。说起来，大二的时候闲着没事买了一套（大概30张）关于电影台词的明信片，每次都是夹在书里当书签使用，然后在读完这本书时就直接夹在书里还了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日常瞎写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人在梦里死掉的话现实中还会醒过来吗</title>
      <link href="/%E4%BA%BA%E5%9C%A8%E6%A2%A6%E9%87%8C%E6%AD%BB%E6%8E%89%E7%9A%84%E8%AF%9D%E7%8E%B0%E5%AE%9E%E4%B8%AD%E8%BF%98%E4%BC%9A%E9%86%92%E8%BF%87%E6%9D%A5%E5%90%97/"/>
      <url>/%E4%BA%BA%E5%9C%A8%E6%A2%A6%E9%87%8C%E6%AD%BB%E6%8E%89%E7%9A%84%E8%AF%9D%E7%8E%B0%E5%AE%9E%E4%B8%AD%E8%BF%98%E4%BC%9A%E9%86%92%E8%BF%87%E6%9D%A5%E5%90%97/</url>
      
        <content type="html"><![CDATA[<p>昨晚做了个噩梦，每次做噩梦都是逃杀类型的，濒死之际醒来，心跳不止。不禁在想，如果有天我在梦里被杀死了，那现实中的我会醒过来吗。</p><span id="more"></span><h2 id="梦"><a href="#梦" class="headerlink" title="梦"></a>梦</h2><p>昨晚的梦大概是这样的：</p><p>一天晚上突然家里停电了。本来打算睡了，这时候家里来了个老妇人询问一些事。就在我为她解答的时候，她突然掏出了刀想要捅我，我跑到了另一个房间里反锁了门。</p><p>过了一段时间，爷爷来了说他的老年机上的时间不太对，让我给他校对一下。校对完之后送爷爷出去的时候，他突然转身向我丢了一些东西（好像是飞镖之类的暗器）。在我躲的同时，他提着斧子砍了过来，我在地上滚了几圈之后捡起了一根木棍和他打斗在一起，没几个回合我就败下阵来。他骑在我身上掐着我的脖子，在我拼命挣扎的时候，他突然停止了动作，倒在了地上。原来是门口那里有个人丢东西把他杀了。救我的人说，他几年前被我父亲救过一命，因为是在逃命，不知道能去哪就一直在我家后面不远处的一个废弃房屋里住着。他说这里不安全了，等天亮了让我赶紧走他还能拖一点时间。</p><p>他走了，但是我心中充满了疑惑。我决心今晚就要出去寻找一下真相。走着走着，在火车道下面的承重柱旁边有几个邻居。其中一个我称呼他为大伯的人要给其他几个人表演一个魔术，他用了两张贴纸（贴纸上画着箭头）紧挨着贴在了承重柱上（箭头方向这样←→），然后又用导线围着承重柱把箭头的两个指针连接在一起。之后，承重柱疯狂的响（类似于变压器附近那种电流的声音），响了一会儿柱子上开始冒烟，然后他们来追我。我拉起一个愣在原地的人疯狂的跑。（在火车道下面，沿着火车道的方向）跑着跑着，火车道两侧开始往下掉落石头。我以为只要沿着火车道跑就可以，反正石头也砸不到我。这时那个被我拉着的人告诉我不能这么做，用不了多久火车道就会塌掉，我们会被砸死在下面。然后我拉着她跑离火车道，跑着跑着到了一个山坡上，虽然没有悬崖那么陡，但大概也接近七八十度，一脚踩不稳也就滚下去了。这时我俩躺在悬崖的那一侧休息，她像是开玩笑的说，不能被他们抓到，是选择跑回去让石头砸死还是滚下去摔死。我没说话，微微抬头看着来的时候那条路（怕他们追上来），然后她就自言自语的讲着这几天的经历（和我类似，但似乎知道的比我要多很多）。她说着的时候，我看到追我们的那群人要追过来了，然后我就吻了上去想让她闭嘴。她挣扎了一下，似乎听到了那群人的脚步声就停止了反抗。大概是因为我没这方面的经验，大脑想象不出亲吻啥感觉就突然醒了。醒的时候心跳特别特别快，缓了好久才平静下来。</p><h2 id="想"><a href="#想" class="headerlink" title="想"></a>想</h2><p>记得之前看过一篇科幻小说「克莱因瓶」，讲的是一个VR设备可以让人玩游戏时不仅有身临其境般的画面，还有着和游戏角色一样的触觉、嗅觉、疼痛等感觉。（如果换做一个基于现实世界建模的地图的话，很难分清虚拟和现实）小说里面的设定是如果在游戏地图里死亡的话，那种真实的疼痛感会让玩家的大脑觉得玩家真的死亡，将醒不过来。</p><p>其实这个问题挺蠢的，即使在梦里死掉真的醒不过来了，那些人也没办法给我答案。真怕有一天，我在梦里濒死的时候没醒过来，而是死在了梦里。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日常瞎写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人不能至少不应该在同一个坑里连续跌倒两次</title>
      <link href="/%E4%BA%BA%E4%B8%8D%E8%83%BD%E8%87%B3%E5%B0%91%E4%B8%8D%E5%BA%94%E8%AF%A5%E5%9C%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E5%9D%91%E9%87%8C%E8%B7%8C%E5%80%92%E4%B8%A4%E6%AC%A1/"/>
      <url>/%E4%BA%BA%E4%B8%8D%E8%83%BD%E8%87%B3%E5%B0%91%E4%B8%8D%E5%BA%94%E8%AF%A5%E5%9C%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E5%9D%91%E9%87%8C%E8%B7%8C%E5%80%92%E4%B8%A4%E6%AC%A1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>二〇二二年十二月四日，这天对你来说可能是平平无奇的一天，而这天却给我留下了深刻的记忆。</p></blockquote><p>人不能至少不应该在同一个坑里跌倒两次，而我跌倒了三次。</p><span id="more"></span><p>故事是这样的：</p><p>昨天上午，我骑着我家的1号电动车出去，骑到半路上发现车胎破了无法继续前进，多大点事，推回家换了家里的2号电动车继续出门。</p><p>骑着2号电动车去完超市回到家里发现2号电动车车胎也破了。对比了一下，1号电动车漏气速度较慢，勉强给1号电动车打上气，去村里修补车胎的地方去补胎。发现前面有人换三轮车的电瓶，需要等好一会儿。和老板商量了一下，先骑着老板家的电动车回家，晚上回去换自家的。老板同意了，老板家电动车骑回家了。过了两个小时，骑着老板电动车出门，想去换回自家电动车的时候，老板家的自行车车胎也破了。再次对比了一下，2号电动车漏气速度比老板家的慢，骑着2号电动车去老板家换回了补好胎的1号电动车，并告诉老板有空去我家去补老板家电动车胎。</p><p>车胎破了，很常见的一件事。而我一天见证了三次。</p><p><img src="/%E4%BA%BA%E4%B8%8D%E8%83%BD%E8%87%B3%E5%B0%91%E4%B8%8D%E5%BA%94%E8%AF%A5%E5%9C%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E5%9D%91%E9%87%8C%E8%B7%8C%E5%80%92%E4%B8%A4%E6%AC%A1/000.png" alt="000"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 日常瞎写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校招之路</title>
      <link href="/%E6%B1%82%E8%81%8C/"/>
      <url>/%E6%B1%82%E8%81%8C/</url>
      
        <content type="html"><![CDATA[<p>本文介绍了整个校招过程中走过的路及一些经验</p><span id="more"></span><h2 id="求职之路"><a href="#求职之路" class="headerlink" title="求职之路"></a>求职之路</h2><h3 id="实习"><a href="#实习" class="headerlink" title="实习"></a>实习</h3><p>实习岗位的投递是在三月底，四月初开始的，主要的方向是<strong>CPP软开</strong>和<strong>CPP后端</strong>。选择这个方向主要是因为自己了解到有网络安全方向岗位的互联网大厂比较少，大多是去一些安全厂商做安服、技服等岗位（不太喜欢专业相关岗位），结合自身学过的编程语言只有<code>C/CPP</code>，课程的实验、课设也大多是用<code>C/CPP</code>写的，就选择了<code>CPP</code>这个赛道。再加上当时了解的比较少，没听过一些其他的赛道（测开、嵌入式、客户端都没接触过，也没听说过），就基本上投递的都是后端岗位。</p><p>说来惭愧，刚开始的时候傲气比天高，实习就只投递大厂。当初的我傻傻的以为去一些中小厂实习用处不太大，却没有撒泡尿照照自己几斤几两。当初了解到的企业也不是很多，只投了大概20+的大厂。果然没出意外，没几个面试机会，有也一面凉了。</p><p>当初可能也是脑子有点病，妄想进大厂实习然后转正。投递的全都是暑期实习，一个日常实习也没投。最终秋招落得一个没有相关开发岗位实习经验的下场。</p><p>找实习的结束是在<code>5.15</code>，这一天是学校的实习相关课程提交材料的最后一天。当初也像个憨批一样，没有考虑到七月中旬结束了这两个月的课程再去实习。还有另一个原因，也想去安全厂商看看做安全究竟如何。</p><p>当时学校给的实习单位有3个，选择安恒的原因是只有安恒有和cpp有点关系的实习岗位。（虽然实际上并没有关系）</p><p>整个学校的实习大概分为教学和实战两个阶段。教学阶段就是相关知识的学习；实战阶段是打靶场。然后中间给出了一个<code>重保项目</code>（其实就是HVV），参加了相关的护网，从出发到回家大概一个月的时间，相关的体验可以看另一篇文章。这期间也接触到了一些做安服、技服的人，了解到一些相关的消息，这个时候确定了：除了一些大厂的安全开发相关的岗位，大概是不会考虑网络安全相关的赛道了。</p><h3 id="秋招"><a href="#秋招" class="headerlink" title="秋招"></a>秋招</h3><p>六月底，学校实习课程的教学阶段结束。这个时候开始的投递一些cpp相关的岗位。刚开始的时候眼界还是有点高的，投递的是后端、软开之类的一些岗位，也都是一些比较大的厂。随着时间的推进逐渐的认清现实。又投递了一些<strong>QT客户端</strong>、<strong>嵌入式开发</strong>相关的岗位，关于企业的规模也没有那么多的要求了。（毕竟要没饭吃了）</p><p>7月参加护网，由于工作性质，时间比较阴间，没有办法在白天进行一些面试（要补觉），秋招基本就搁置了。</p><p>整个秋招大批量的笔面试集中在8、9月份，基本上每天都有1+笔面试。10月一共面试了不到10次，其中有一天就面试了4家，身心俱疲。整个秋招过程中有失望，有欣喜。一路摸爬滚打来到了11月底，整个秋招阶段基本接近尾声了，预期的薪资、预期的岗位、预期的企业降了一次又一次，最终也没有选择妥协。截止至写文的今日（十一月底），拿到的offer大概有：东软睿驰、经纬恒润、亚控科技。面试流程已结束，泡池子的大概有：比亚迪(9月底提交了资料审核就没开过奖)、中兴（9月底面完没等来所谓的offer签约会）、同花顺（国庆后一两天面完的HR面也还未开到奖）、华为（京津东北赛道9月底才开始笔试，十月底点亮完六盏灯入池）。想了想，我这一个下棋S6天天赏金，S7天天赌变形重组器的人，不赌一把有点不甘心。（还是已有的offer，薪资不符合预期）今天，拒了最后的保底offer，开启了漫长的泡池子之路，泡不出来就大概要春招了。</p><h3 id="春招"><a href="#春招" class="headerlink" title="春招"></a><del>春招</del></h3><p><del>赌狗一般是不会有好下场的，这个模块迟早要开，先占个坑。</del></p><h3 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h3><ul><li>实习 — 一些较大的厂会有<code>3/6</code>个月的试用期用来培训及做一些简单的任务。对于一些愿意培训的大厂来说，可能实习经历不是那么重要。但是对很多中小厂来说，他们更希望要一个契合度高的、能直接上手的人。如果可以的话，尽早找实习，多找几段日常实习来丰富简历。（虽然很多实习工作并没做一些有意义的工作，但是<del>我猜</del>能让你理解到工程和学习、科研的一些区别）</li><li>八股  —  其实我觉得这是最无聊的部分，他并不能区分出一个应聘者的能力好坏（就看谁背书能力强），但是好多厂的面试会有很多的八股问题，回答不上来还不是很好。（关于八股问题的回答，我的建议是尽量的说的结巴一些，别说那么全。让他觉得是你的知识储备量大，而不是面试前背的面经）</li><li>反问环节  —  很多企业规定，这个阶段不能问面评的。但是我觉得这个阶段可能是我接触一些大厂一线开发人员的不多的机会之一，这个阶段我一般会问对相关岗位的理解及看法、面试官期望的应届生应该具有哪些素质、对职业生涯的建议（基本都会给你讲一些他当年的故事）</li><li>笔试  —  这东西是蛮恶心人的一个环节，因为笔试的结果并没有什么卵用，说这话您可能不信。笔试仅仅是因为HR忙不过来晒选那么多简历，做一个简单的初筛。（当然，雷火那个难度的笔试肯定是有参考价值的）这两个月接触了太多大厂笔试题不太难，九十多分进不了后续环节；一些中厂笔试交白卷照样捞面试（经历了这些让我觉得笔试真就是一个摆设）。</li><li>KPI面  —  这个东西是最恶心人的，而且很多演都不带演的，根据面试官的表现基本上能判断出来。比如某信服的主管面问完问题没有反问直接光速下播反手终止流程、某滴的面试反问环节问基础问题（这个岗位从事什么工作，在企业中属于什么地位）直接不告诉你。</li><li>学历不重要  —  换你是HR，个位数的hc、上万个候选人，你怎么快速的晒选简历。不否认学历证明不了一切，但那些高学历的也不是只有学历。</li></ul><p>最后，</p><blockquote><p>To you and your path, wherever it leads.</p></blockquote><p><img src="/%E6%B1%82%E8%81%8C/000.png" alt="000"></p><hr><h3 id="1224更新"><a href="#1224更新" class="headerlink" title="1224更新"></a>1224更新</h3><p>赌来了华子Offer，准备给华子卖命去了。</p><p>关于我的秋招的时间线及面经，需要自提。</p><table><thead><tr><th align="center">[<a href="https://www.aliyundrive.com/s/GoEqx5J8dGF">下载自解压文件</a>]</th><th align="center">[<a href="https://github.com/ikun7355608/AutumnRecruitment">github在线阅读</a>]</th></tr></thead></table><h3 id="0317更新"><a href="#0317更新" class="headerlink" title="0317更新"></a>0317更新</h3><p>本来20块到付的校招礼盒让我快变成黑粉了，今天突然收到了入职预约附带的机票报销邮件（经济舱、高铁动车一等座、火车软卧 和 市内交通），让我一下子又粉了起来。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 关于我 </tag>
            
            <tag> 社畜养成计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-09月度总结</title>
      <link href="/2022-09%E6%9C%88%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
      <url>/2022-09%E6%9C%88%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>这个模块已经很久没有更新了，秋招两个月<code>0offer</code>，笔试测评做到吐，面试没几个，面完就泡着。无聊之际，更新一下秋招两个月的历程。</p><blockquote><p>「可以说脏话吗，不可以吗？那我没什么好说的了。」</p></blockquote><span id="more"></span><blockquote><p>山高处看得远，风大雨也大。山脚下条条小路却满目鲜花<br>没有那么多轰轰烈烈与庸庸绿碌，来这世上走上一遭活的其实就是一个好心态。</p></blockquote><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>整个秋招之旅大概开始于六月底，主要进行着C++基础语法、STL相关内容的深入学习。期间在七月初投了一部分简历，然后去参加护网，八月初回来之后开始疯狂投简历。截止至写这篇文章的时候，投了大概100份简历（80+19），感谢信以及官网流程终止的有36家，offer、意向仍然是0。</p><h3 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h3><p>落得如此下场，是环境问题吗？显然，技不如人是真的。本身学安全出身，课程什么的也不会有大型开发的项目，实习也是偏向安全的。虽然有竞赛，但也和互联网没任何关系。在这个hc骤减的环境下，高契合度且有大厂实习的候选人都比hc要多，谁会去考虑一个<strong>没竞赛、没实习、没项目</strong>的<strong>半个科班</strong>的人？</p><p>是眼高手低吗？「<strong>北京</strong>、<strong>千人以上</strong>、<strong>税前20W</strong>」，问了些往届的学长学姐还有一些一起秋招的朋友，「北京、研发」月薪<code>15K</code>上下，虽然不是特别的低，但不至于「<code>100</code>份简历，<code>0offer</code>」吧。我觉得，一个酒吧舞应届生，就算非互联网、不加班的岗位，月薪也有八九千吧。不至于每天被自愿加班的厂都嫌多吧。再者，至今面试了大概二十次左右？好像除了明显的岗位不匹、KPI面外，基本上是没有挂过面试，大多面完疯狂排序泡池子。感觉，也不是能力不行、过不了面试。</p><p>感觉，似乎一路走来，似乎并没有错：认真对待每一门课，哪怕他再水也认真完成作业、准备考试，却落得这<code>0offer</code>的结果；似乎每一步都错了，也许大二结束开始每个寒暑假就该找实习去丰富简历，才会有些竞争力。第一次上大学、一切都靠自己摸索，从机械转安全再转开发，能走到这里感觉已经很不容易了。难道应该收到录取通知书时，就开始了转码之旅？</p><h3 id="心态"><a href="#心态" class="headerlink" title="心态"></a>心态</h3><blockquote><p>每天都在崩溃的边缘，又或者破防后再重建那并不明确的目标。</p></blockquote><p>刚开始的时候，觉得投递自动送测评、海笔的公司还不错，后来发现纯纯浪费时间。性格测评题都没变过，还不能点击过快。辛辛苦苦三四十分钟写完行测、性格测试的题，反手「简历初筛未通过」。</p><p>刚开始的时候确实眼高手低，看很多公司的风评后都觉得「狗都不去」，逐渐的演变为「狗不去，我去」</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>几个等待国庆节后的hr面的企业， 希望能有一个好结果。</p><p>累吗，累。想放弃吗，想。但有的选吗，没有。还能咋办，继续投继续面呗。</p><blockquote><p>我不后悔学、准备C++，只能怪技不如人。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 关于我 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚函数</title>
      <link href="/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
      <url>/%E8%99%9A%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>我们知道，动态多态是借助虚函数实现的，下面是关于虚函数的一些介绍。</p><span id="more"></span><h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><p>通俗来讲，虚函数是在编译时，并不能确定的类函数，而是在运行时确定的。<br>独特功能：<strong>基类对象访问派生类的函数</strong>。<br>步骤</p><ol><li>定义基类时，函数声明为虚（virtual）</li><li>派生类中，重写基类中定义为虚的函数。</li><li>声明基类指针指向派生类对象。调用虚函数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">          cout&lt;&lt;<span class="string">&quot;A::foo() is called&quot;</span>&lt;&lt;endl;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">          cout&lt;&lt;<span class="string">&quot;B::foo() is called&quot;</span>&lt;&lt;endl;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A *a = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">    a-&gt;<span class="built_in">foo</span>();   <span class="comment">// 在这里，a虽然是指向A的指针，但是被调用的函数(foo)却是B的!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>纯虚函数可使当前类变成<strong style="color:red;">抽象类</strong>，<mark>禁止该类被实例化</mark>，并要求其非抽象类的派生类<mark>必须重写</mark>该纯虚函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>定义纯虚函数时，不需要定义函数的实现部分。「= 0」 表明程序员将不定义该函数，函数声明是为派生类保留一个位置。「= 0」 的本质是将指向函数体的指针定为$nullptr$</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li>类中一旦出现纯虚函数，就不可实例化了（抽象类）；</li><li>纯虚函数有函数体，但最终还是要被派生类重写，在派生类的函数中可以调用基类中有函数体的纯虚函数；</li><li>为使派生类能完全释放资源，基类析构函数必须声明为虚函数。否则，在用基类指针new一个派生类对象后，delete该指针就只能回收与基类相关的资源，造成内存泄漏；</li><li>纯虚析构函数必须要有函数体。</li></ol><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>存在纯虚函数的类，叫抽象类。</p><ol><li>抽象类不能用作参数类型、函数返回类型或显式转换的类型。</li><li>可以定义指向抽象类的指针和引用，此指针可以指向它的派生类，进而实现多态性。</li><li>抽象类只能用作其他类的基类，不能建立抽象类对象。</li></ol><h3 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h3><p>对象创建时,编译器对<code>vptr</code>进行初始化，只有当对象构造完全结束后<code>vptr</code>的指向才最终确定。<br>使用虚函数时，对象会多出4字节的虚指针，指针指向类的虚函数表。<strong>对象不包含虚函数表，只有虚指针，类才包含虚函数表。</strong><br>虚表中的指针顺序，取决于类中虚函数的<strong style="color:rgb(0, 191, 166);">声明顺序</strong>。<br>虚函数表在实例化对象创建时创建。</p><h3 id="虚指针-amp-虚表"><a href="#虚指针-amp-虚表" class="headerlink" title="虚指针&amp;虚表"></a>虚指针&amp;虚表</h3><p>vptr &amp; vtbl。只要类中有虚函数，类对象内部就会有出现<mark>一个</mark>指针。虚指针用来指向虚表中的<mark>函数指针</mark>指向虚函数的地址。未重写的虚函数，基类和派生类共用。重写了的，各自虚表中指向重写后的地址。<br>通过指针，向上转型，指向虚函数。<code>(*p-&gt;vptr[n])(p)</code></p><h3 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h3><blockquote><p>动态分配堆上内存的时候，析构函数必须是虚函数。</p></blockquote><p>动态的去分配堆区的空间时，无法在程序运行结束自动释放内存。若基类指针指向派生类，然后基类指针调用delete方法，只能释放基类的内存，进而导致内存泄露。<br>析构函数定义成虚函数，基类指针调用delete方法，会先调用派生类的析构函数，然后自动调用基类的析构函数。</p><blockquote><p>友元函数不能为虚函数</p></blockquote><p>友元函数，<mark>不属于</mark>这个类的成员函数。而且虚函数的目的是通过基类对象访问派生类实现的函数，友元函数不是不是成员函数，更无继承关系。</p><blockquote><p>多继承</p></blockquote><p>多继承下有多个虚表。多个基类之间（类内部按声明顺序）的虚函数，按照继承的顺序，存放虚函数指针。<br>虚函数表中，派生类<mark>重写</mark>的虚函数<strong style="color:orange;">替换了基类虚函数指针</strong>，并指向了派生类的函数实现。</p><blockquote><p>哪些函数不支持声明为虚函数</p></blockquote><p>非成员函数、静态成员函数、内联成员函数、构造函数、友元函数。</p><ul><li>非成员函数：非成员函数只能重载，不能重写。编译器会在编译时绑定函数。</li><li>构造函数：构造函数用来创建一个新的对象,而虚函数的运行是建立在对象的基础上,在构造函数执行时,对象尚未形成,所以不能将构造函数定义为虚函数。</li><li>内联函数：内联函数就是为了在代码中直接展开，减少函数调用花费的代价，虚函数是为了在继承后对象能够准确的执行自己的动作，这是不可能统一的。</li><li>静态成员函数： 静态成员函数对于每个类来说只有一份代码，所有的对象都共享这一份代码，他也没有要动态绑定的必要性。</li><li>友元函数： C++不支持友元函数的继承，对于没有继承特性的函数没有虚函数的说法。</li></ul><blockquote><p>为什么构造函数调用虚函数不能实现多态？</p></blockquote><p>子类构造函数要先调用父类构造函数，虚函数实现重载靠的是动态绑定。<br>如果构造函数中的虚函数为动态绑定(多态)，则子类在构造时，子类的构造函数先调用父类构造函数，而此时父类构造函数不能调用子类的重载函数（子类还未创建，没有虚表。）</p><blockquote><p>怎么通过虚函数实现的多态？(内存、寻址等)</p></blockquote><p>通过对象内存中的vptr找到虚函数表vtbl，接着通过vtbl找到对应虚函数的实现区域并进行调用。<br>类的成员函数存在于<code>.text segment</code>段，为类的所有对象公有。(不管创建多少个对象)成员变量存在于<code>.stack/.heap</code>中供类对象独有。<br>含有虚函数的类对象除了存储成员变量外，还存储一个虚指针<code>vptr</code>，这个虚指针指向一张虚表<code>vtbl</code>。<code>vtbl</code>中存的数据为<strong>函数指针</strong>，存储着虚函数调用的具体函数所在的地址。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> 八股 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP连接的建立与断开</title>
      <link href="/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%BA%E7%AB%8B%E4%B8%8E%E6%96%AD%E5%BC%80/"/>
      <url>/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%BA%E7%AB%8B%E4%B8%8E%E6%96%AD%E5%BC%80/</url>
      
        <content type="html"><![CDATA[<p>本文主要是「三次握手与四次挥手」相关的一些问题</p><span id="more"></span><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><ul><li>初始，客户端处于<code>close</code>状态，服务器处于<code>listen</code>状态</li><li>第一次握手  —  客户端向服务器端发送一个<code>SYN</code>位，切换状态至<code>SYN_SENT</code>。</li><li>第二次握手  —  服务器收到<code>SYN</code>报文，向客户端回一个确认报文<code>ACK</code>，切换状态至<code>SYN_REVD</code>；同时，发送自己的<code>SYN</code>报文进行应答。</li><li>第三次握手  —  客户端收到<code>SYN</code>报文后，发送<code>ACK</code>报文给服务器。同时，自身状态切换至<code>established</code></li><li>服务器端收到<code>ACK</code>报文后，切换自身状态为<code>established</code></li></ul><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><ul><li>客户端、服务器都处于<code>established</code>状态，进行数据传输。</li><li>第一次挥手  —  客户端发送一个<code>FIN</code>位，表示不再发送请求。同时，状态切换至<code>FIN_WAIT_1</code></li><li>第二次挥手  —  服务器收到客户端的结束请求，发送一个<code>ACK</code>位，表示已收到客户端报文。同时，服务器切换状态为<code>CLOSE_WAIT</code></li><li>客户端收到第二次挥手的报文后，切换自身状态为<code>FIN_WAIT_2</code></li><li>第三次挥手  —  服务器传完数据后，向客户端发送结束报文<code>FIN</code>位，进入<code>LAST_ACK</code>状态。</li><li>第四次挥手  —  客户端收到报文后，发送<code>ACK</code>进行应答。同时切换自身状态为<code>TIME_WAIT</code></li><li>服务器收到<code>ACK</code>报文后，关闭连接。切换为<code>CLOSE</code>状态</li><li>客户端在发送第四次握手后等待<code>2MSL</code>切换为<code>CLOSE</code>状态，关闭连接。</li></ul><h3 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h3><h4 id="为什么握手三次"><a href="#为什么握手三次" class="headerlink" title="为什么握手三次"></a>为什么握手三次</h4><blockquote><p>确认双方都能发送、接收数据。</p></blockquote><ul><li>第一次握手  —  服务器端知道客户端可以发送数据</li><li>第二次握手  —  客户端知道服务器端可以发送数据、可以接受数据。</li><li>第三次握手  — 服务器端知道客户端可以接收数据</li></ul><h4 id="FYN泛洪"><a href="#FYN泛洪" class="headerlink" title="FYN泛洪"></a>FYN泛洪</h4><p>利用三次握手的特性，攻击者疯狂发送第一次握手的数据包，收到服务器第二次握手数据包后，并<strong>不会回</strong>第三次握手数据包。服务器收不到相应的ACK位一直重发第二次握手的数据包，最终导致服务器资源耗尽。</p><h4 id="SYN-Cookie"><a href="#SYN-Cookie" class="headerlink" title="SYN Cookie"></a>SYN Cookie</h4><p>为了防止服务器拥有过多上述的半连接状态，在服务器收到第一次握手的数据后，并不会分配资源。而是利用客户端的<code>SYN</code>值计算一个<code>Cookie</code>保存在第二次握手的报文中，返回给客户端，等服务器收到第三次握手的数据包后，根据<code>Cookie</code>值检查报文的合法性。如果合法再分配资源</p><h4 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME_WAIT"></a>TIME_WAIT</h4><blockquote><p>防止第四次挥手丢包。</p></blockquote><p>如果客户端发送完第四次挥手数据后，直接切换至<code>CLOSE</code>状态，第四次挥手数据包丢包时，服务器超时重传第三次挥手数据包。此时如果有新的TCP连接重启这个地址信息的话，处于三次握手阶段，客户端发起的是<code>SYN</code>请求，而服务器所等待的是<code>ACK</code>应答。此时会导致发送<code>RST</code>重建连接。</p><h4 id="2MSL"><a href="#2MSL" class="headerlink" title="2MSL"></a>2MSL</h4><p>在<code>TIME_WAIT</code>防止丢包时，客户端从<code>TIME_WAIT</code>切换至<code>CLOSE</code>需要等待<code>2MSL</code></p><blockquote><p>MSL  报文的最大生存时间</p></blockquote><p>如果第三次挥手的包丢包，则第三次挥手从发送到重发，经过<code>2MSL</code>，此时对于客户端来说，已经过去的时间小于等于<code>1MSL</code>（发送第四次挥手数据包，过程中丢包），而后接收到重发的第三次握手数据包的时间小于等于<code>1MSL</code>。即，客户端等待<code>2MSL</code>未收到<code>FIN</code>（第三次挥手）则能够确认服务器已经收到第四次挥手数据包。</p><p>此外，经过<code>2MSL</code>后，与该次连接相关的所有报文，都会超过生命周期。防止提前关闭客户端时，部分报文还存活，从而影响新的连接。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 八股 </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图算法</title>
      <link href="/%E5%9B%BE%E7%AE%97%E6%B3%95/"/>
      <url>/%E5%9B%BE%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍<code>Floyd、Dijkstra、Prim</code>等图算法的代码实现</p><span id="more"></span><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> cost;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;edge&gt; graph[MAX];</span><br><span class="line"><span class="keyword">int</span> v, e;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 顶点数，边数</span></span><br><span class="line">    cin &gt;&gt; v &gt;&gt; e;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e; ++i ) &#123;</span><br><span class="line">        <span class="keyword">int</span> to;</span><br><span class="line">        <span class="keyword">int</span> from;</span><br><span class="line">        <span class="keyword">int</span> cost;</span><br><span class="line">        cin &gt;&gt; from &gt;&gt; to &gt;&gt; cost;</span><br><span class="line">        graph[from].<span class="built_in">push_back</span>(&#123;to, cost&#125;);</span><br><span class="line">        <span class="comment">// 有向图，则是单向 没有to--&gt;from链路</span></span><br><span class="line">        graph[to].<span class="built_in">push_back</span>(&#123;from, cost&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">graph</span>(MAX, vector&lt;<span class="keyword">int</span>&gt;(MAX, INF));</span><br><span class="line"><span class="keyword">int</span> v, e;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; v &gt;&gt; e;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e; ++i) &#123;</span><br><span class="line">        <span class="comment">// 对角线初始化</span></span><br><span class="line">        graph[i][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> to,</span><br><span class="line">            from,</span><br><span class="line">            cost;</span><br><span class="line">        cin &gt;&gt; from &gt;&gt; to &gt;&gt; cost;</span><br><span class="line">        graph[from][to] = cost;</span><br><span class="line">        <span class="comment">// 有向图 </span></span><br><span class="line">        graph[to][from] = cost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h3><p>Floyd算法的核心在于</p><ul><li>想求<code>start ===&gt; finish</code>的最小距离</li><li>考虑借助中间节点<code>k</code>来实现<code>start ===&gt; k ===&gt; finish</code>间接抵达</li><li>此时<code>cost[start][finish] = cost[start][k] + cost[k][finish]</code>（<code>cost[i][j]</code>以表示<code>i ===&gt; j</code>的花费）</li><li>遍历所有节点，找出最小权值和</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//graph：邻接矩阵</span></span><br><span class="line"><span class="comment">// INF：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">Floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; v; ++k) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v;++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; v;++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(graph[i][k] &lt; INF &amp;&amp; graph[k][j] &lt; INF) &#123; <span class="comment">//节点均畅通</span></span><br><span class="line">                    graph[i][j] = <span class="built_in">min</span>(graph[i][j], graph[i][k] + graph[k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h3><p>Dijkstra算法的核心是贪心</p><ul><li>想求<code>start ===&gt; finish</code>的最小距离</li><li>从<code>start</code>开始，考虑剩余（未到达）的可达节点中最小花费。</li><li>最小花费点作为下一个节点，更新花费表。</li><li>依次寻找最小花费，直至抵达目标点</li></ul><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">      0     1     2     3</span><br><span class="line">   -------------------------</span><br><span class="line">  0|<span class="string">  0  </span>|<span class="string">  2  </span>|<span class="string">  6  </span>|<span class="string">  4  </span>|</span><br><span class="line">   |<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|</span><br><span class="line">  1|<span class="string"> INF </span>|<span class="string">  0  </span>|<span class="string">  3  </span>|<span class="string"> INF </span>|</span><br><span class="line">   |<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|</span><br><span class="line">  2|<span class="string">  7  </span>|<span class="string"> INF </span>|<span class="string">  0  </span>|<span class="string">  1  </span>|</span><br><span class="line">   |<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|</span><br><span class="line">  3|<span class="string">  5  </span>|<span class="string"> INF </span>|<span class="string">  9  </span>|<span class="string">  0  </span>|</span><br><span class="line">   -------------------------</span><br><span class="line">从0号节点开始，此时达到其余各点的花费</span><br><span class="line">dist = [0, 2, 6, 4]</span><br><span class="line">此时1、2、3节点均未达，1节点花费最小 前往1节点</span><br><span class="line">dist = [0, 2, 5, 4]</span><br><span class="line">借助1节点到达2节点比直接到达2节点花费小，更新距离表</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//graph：邻接矩阵</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">Dijkstr_visited</span><span class="params">(MAX, <span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">Dijkstra_dist</span><span class="params">(MAX, INF)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = val;</span><br><span class="line">    Dijkstr_visited[start] = <span class="literal">true</span>; <span class="comment">//到达过</span></span><br><span class="line">    Dijkstra_dist = graph[start];      <span class="comment">//初始化为初始行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; v; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = INF; <span class="comment">//最近点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; v; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!Dijkstr_visited[j] &amp;&amp; Dijkstra_dist[j] &lt; tmp) &#123; <span class="comment">//未访问过，最小值</span></span><br><span class="line">                start = j;<span class="comment">//下次访问这个数组</span></span><br><span class="line">                tmp = Dijkstra_dist[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Dijkstr_visited[start] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; v; ++j) &#123;</span><br><span class="line">            Dijkstra_dist[j] = <span class="built_in">min</span>(Dijkstra_dist[j], Dijkstra_dist[start] + graph[start][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h3><p>Prim算法的核心在于</p><ul><li>选择一个节点（生成树内部）开始，考虑到达其他节点的最小花费</li><li>寻找未抵达节点中最小花费（生成树外的节点），将该路径及点加入生成树内</li><li>遍历所有节点，直至全部节点加入生成树</li></ul><blockquote><p>在保证不成环的基础下，依次寻找抵达生成树外节点的最小花费</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * graph：邻接矩阵</span></span><br><span class="line"><span class="comment"> * visited：存放节点是否访问过（最小生成树内部，外部）</span></span><br><span class="line"><span class="comment"> * lowcost：用于寻找靠近角标点的最小权值（扩展）</span></span><br><span class="line"><span class="comment"> * closecost：保存最靠近角标点的元素</span></span><br><span class="line"><span class="comment"> * lowcost[i]：closecost[i]是一对。</span></span><br><span class="line"><span class="comment"> * ***/</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">Prim_visited</span><span class="params">(MAX, <span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">Prim_lowcost</span><span class="params">(MAX, INF)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">Prim_closecost</span><span class="params">(MAX, INF)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Prim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 初始化为从0节点开始</span></span><br><span class="line">    Prim_visited[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    Prim_lowcost = graph[<span class="number">0</span>];</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;0 ----&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v;++i) &#123;</span><br><span class="line">        <span class="comment">// 最小权值，对应的角标</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">-1</span>,</span><br><span class="line">            tmp = INF;</span><br><span class="line">        <span class="comment">// 寻找lowcost的最小值（下一个目标）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; v; ++j) &#123;   <span class="comment">//0已经访问过了 visited[0]一定不成立 故从1开始</span></span><br><span class="line">            <span class="keyword">if</span> (!Prim_visited[j] &amp;&amp; Prim_lowcost[j] &lt; tmp) &#123;</span><br><span class="line">                index = j;</span><br><span class="line">                tmp = Prim_lowcost[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不可达</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">-1</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;cost:&quot;</span> &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">//找不到节点 不可达</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; index &lt;&lt; <span class="string">&quot; ----&gt;&quot;</span>;</span><br><span class="line">        Prim_visited[index] = <span class="literal">true</span>;</span><br><span class="line">        res += Prim_lowcost[index];</span><br><span class="line">        <span class="comment">// 更新最小权值表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; v;++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!Prim_visited[j] &amp;&amp; graph[index][j] != INF &amp;&amp; graph[index][j] &lt; Prim_lowcost[j]) &#123;</span><br><span class="line">                Prim_lowcost[j] = graph[index][j];</span><br><span class="line">                Prim_closecost[j] = index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣二叉树</title>
      <link href="/%E5%8A%9B%E6%89%A3%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/%E5%8A%9B%E6%89%A3%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>本文主要是介绍力扣二叉树的构造</p><p>即，从<code>[x, x, x, x, x]</code>为层序遍历的结果来构造一颗二叉树</p><span id="more"></span><h3 id="数据结构定义"><a href="#数据结构定义" class="headerlink" title="数据结构定义"></a>数据结构定义</h3><p>树节点数据结构包括  —  值、左指针、右指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据结构定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="keyword">int</span> val) : <span class="built_in">val</span>(val), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="keyword">int</span> val, TreeNode *left, TreeNode *right) : <span class="built_in">val</span>(val), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right)&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="力扣输入形式构造数组"><a href="#力扣输入形式构造数组" class="headerlink" title="力扣输入形式构造数组"></a>力扣输入形式构造数组</h3><p>根据<code>[x, x, x, x, x]</code>的形式创建数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">string str;</span><br><span class="line"><span class="built_in">getline</span>(cin, str);</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ch:str) &#123;</span><br><span class="line">    <span class="keyword">if</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        val = val * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;,&#x27;</span> || ch == <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(val);</span><br><span class="line">        val = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用层序遍历结果建树"><a href="#用层序遍历结果建树" class="headerlink" title="用层序遍历结果建树"></a>用层序遍历结果建树</h3><p>根据树用数组表示的特点（根节点角标与左右子树角标的关系）来递归构造二叉树</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建树</span></span><br><span class="line"><span class="function">TreeNode *<span class="title">CreateTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= nums.<span class="built_in">size</span>() || nums[index] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode *node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[index]);</span><br><span class="line">    node-&gt;left = <span class="built_in">CreateTree</span>(nums, <span class="number">2</span> * index + <span class="number">1</span>);</span><br><span class="line">    node-&gt;right = <span class="built_in">CreateTree</span>(nums, <span class="number">2</span> * index + <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>层序遍历，验证与输入是否一致</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 层序遍历</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">printTree</span><span class="params">(TreeNode * root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">    queue&lt;TreeNode *&gt; que;</span><br><span class="line">    que.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode *node = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        temp.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left) &#123;</span><br><span class="line">            que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;right) &#123;</span><br><span class="line">            que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="释放内存"><a href="#释放内存" class="headerlink" title="释放内存"></a>释放内存</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteTree</span><span class="params">(TreeNode * root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DeleteTree</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">DeleteTree</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">delete</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 数据结构定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="keyword">int</span> val) : <span class="built_in">val</span>(val), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="keyword">int</span> val, TreeNode *left, TreeNode *right) : <span class="built_in">val</span>(val), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 建树</span></span><br><span class="line"><span class="function">TreeNode *<span class="title">CreateTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= nums.<span class="built_in">size</span>() || nums[index] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode *node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[index]);</span><br><span class="line">    node-&gt;left = <span class="built_in">CreateTree</span>(nums, <span class="number">2</span> * index + <span class="number">1</span>);</span><br><span class="line">    node-&gt;right = <span class="built_in">CreateTree</span>(nums, <span class="number">2</span> * index + <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 释放</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteTree</span><span class="params">(TreeNode * root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DeleteTree</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">DeleteTree</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">delete</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 层序遍历</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">printTree</span><span class="params">(TreeNode * root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">    queue&lt;TreeNode *&gt; que;</span><br><span class="line">    que.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode *node = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        temp.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left) &#123;</span><br><span class="line">            que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;right) &#123;</span><br><span class="line">            que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    string str;</span><br><span class="line">    <span class="built_in">getline</span>(cin, str);</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ch:str) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            val = val * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;,&#x27;</span> || ch == <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(val);</span><br><span class="line">            val = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode *root = <span class="built_in">CreateTree</span>(vec, <span class="number">0</span>);</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    res = <span class="built_in">printTree</span>(root);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        cout &lt;&lt; res[i];</span><br><span class="line">        <span class="keyword">if</span>(i != res.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    <span class="built_in">DeleteTree</span>(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>海量数据问题</title>
      <link href="/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98/"/>
      <url>/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>高频八股之海量数据问题 </p><blockquote><p>本文参考自<a href="https://blog.csdn.net/v_JULY_v/article/details/7382693">教你如何迅速秒杀掉：99%的海量数据面试题</a></p></blockquote><span id="more"></span><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>数据量过大，而内存空间不足或短时间内无法迅速求解的问题</p><ul><li>内存空间不足  —  分治，存入多个小文件中操作</li><li>短时间不可解  —  数据结构+算法</li></ul><h4 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h4><p><code>分治  ===&gt;  hash  ===&gt;  求解子问题  ===&gt;  归并</code></p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><blockquote><p>现有海量日志数据，要提取出某日访问百度次数最多的那个IPv4地址<br>内存空间有限，不足以全部加载。</p></blockquote><ul><li>分治  —  IP地址范围<code>0.0.0.0 --- 255.255.255.255</code>共$2^{32}$个，根据其规律将其按地址划分(类似子网划分，在此根据掩码来划分为多个文件，以$2^8$为例，划分到$2^8$个子文件中，每个文件$2^{24} = 16M$个不同的IP地址)</li><li>hash  —  将<code>unsigned int32</code>类型的IP地址，做<code>hash(IP)%256</code>处理，划分到256个子文件中(哈希函数一定，某特定IP的多次计算得到的值一定相同，一定在同一个文件)</li><li>求解子问题  —  所求问题为最大值，如果我们对每个子问题（子文件）求最大值，则全局最大值一定在这些子问题最大值中。对每个小文件构建map，统计出现次数的最大值。</li><li>归并  —  得到多个子文件中的最大值（局部最优解）进行比较，得到全局最优解。$ File_i{Max} &gt; File_{else}Max &gt; File_{else}else$（子文件最大值中的最值 &gt; 其他子文件的最值 &gt; 其他子文件所有值）</li></ul><blockquote><p>有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，返回频数最高的100个词。<br>内存限制大小1M</p></blockquote><p>解题思路与上述基本相同，此外</p><ul><li>内存限制为1M，则至少需要<code>1G/1M = 1024</code>个文件(考虑分布不均，应至少为4、5倍，合理即可)</li><li>由于返回的是最大的100个词，同样防止分布不均（高频词都在一个文件），应每个子文件都要求<code>TOP100</code></li><li>如若子文件划分过多，每个的TOP100在内存中放不下（无法直接排序）可以：<ul><li>重复上述步骤</li><li>维持一个堆，记录高频词及出现次数。依次读不同文件来维持这个堆。</li></ul></li></ul><blockquote><p>海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。<br>海量数据中找出重复次数最多的一个<br>上千万或上亿数据（有重复），统计其中出现次数最多的前N个数据。</p></blockquote><p>同上</p><blockquote><p>给定a、b两个文件，各存放50亿个url，每个url各占64字节，找出a、b文件共同的url。<br>内存限制是4G</p></blockquote><ul><li>分治  —  $2^8\times 5G = 5\times2^{40} = 320G &gt; 4G$，将文件划分到多个子文件中（防止分布不均应多划分几个区间，如500个）</li><li>hash  —  文件a、b分别<code>hash(url)%500</code>存入各自子文件中（采用相同的hash函数，则相同的url存在于同一类子文件，如某url在a的子文件$a_{13}$中，则如果b中也有,则一定在$b_{13}$中）</li><li>求解子问题  —  分别读子文件$a_i\qquad b_i$，对比hash值得到相同url（如先将$a_i$中的值存入hash表，然后遍历$b_i$中的值和hash表比对，相同则存在重复元素）</li><li>归并</li></ul><blockquote><p>2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。</p></blockquote><ul><li>方案1  —  上述解决方案仍可行。</li><li>方案2  —  <code>bitmap</code> <ul><li>观察要求，数据分为三类：没出现过、出现一次（所求）、出现多次。我们可以用<code>2bit</code>来反应其出现情况，<code>00 ===&gt;没出现过  01 ===&gt; 出现1次  10 ===&gt; 出现多次</code></li><li>我们只需要人为规定一种映射来对应其关系即可，无需存储具体数字。由于，我们可以用2bit来表示出现情况，则1Bytes大小我们可以表示四个数字的出现情况。比如<code>100</code>即第<code>[100/4]</code>Bytes的第<code>[100%4 * 2]</code>和 <code>[100%4  * 2 + 1]</code>两位。利用<code>移位</code>及<code>&amp;</code>操作即可得到其值。（<code>bitmap[25] &gt;&gt; 6</code>）</li><li>理论原值存储使用空间<code>0.25G*4Bytes = 1GB</code>，实际使用空间<code>0.25G * 2bit = 64MB</code></li></ul></li></ul><blockquote><p>5亿个int型整数，找中位数</p></blockquote><p>按照前面的方案，我们可以将这些数据划分为多个子区域，然后再去寻找中位数。关于<strong>如何划分子区域</strong>，还能够让其保持一个相对顺序：</p><ul><li><p>首先，我们判断最高位，根据最高位为<code>1 or 0</code>可以分为两个子数组</p></li><li><p>再此基础上判断次高位为<code>1 or 0</code>再次划分</p></li><li><p>至此，我们有4个区间<code>0b11XXXXX  0b10XXXXX  0b01XXXXX  0b00XXXXX</code>，分组间的大小关系显而易见。</p></li><li><p>借此思路，我们可以直接根据前<code>X</code>位的值，将其划分为$2^X$个子文件，然后根据中位数（第K顺序统计量）所在的角标来判断其应该处于哪个子文件，然后在子文件中去排序、查找。</p></li></ul><blockquote><p>给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中</p></blockquote><ul><li>方案1  —  上述<code>bitmap</code>方案，每个数字仅需要一位即可（只需判断存在不存在）</li><li>方案2  —  上述子区域划分方案</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 八股 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>static</title>
      <link href="/static/"/>
      <url>/static/</url>
      
        <content type="html"><![CDATA[<p><code>static</code>关键字相关知识点</p><span id="more"></span><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>函数内部定义的变量，当程序执行到它的定义处时，编译器为它在栈上分配空间，函数执行结束时会释放掉他的内存。为保持变量的持久性，我们可以声明其为全局变量、全局函数。但全局函数又破坏了变量的访问范围，为了控制变量的存储方式和可见性，引入<code>static</code>关键字。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol><li>修饰局部变量  —  延长生命周期</li></ol><p>局部变量一般创建在栈区，将其声明为<code>static</code>会导致变量创建在全局区。全局区的变量只会在程序运行前初始化一次，其生命周期会一直延续到整个程序执行结束。</p><blockquote><p>生命周期以及存储空间发生了变化，但其作用域并没变。</p></blockquote><ol start="2"><li>修饰全局变量、函数  —  信息隐藏，对其他文件不可见。</li></ol><p>当同时编译多个文件时，所有未加 static 前缀的全局变量和函数都具有全局可见性。（可被其他文件访问）</p><p>声明为<code>static</code>后，该变量/函数仅在该文件中可见，不能被其他文件访问。</p><blockquote><p>同一工程下，不能被其他文件引用；文件外可定义同名变量/函数。</p></blockquote><ol start="3"><li>修饰类成员</li></ol><p>被<code>static</code>修饰的类成员函数、类成员变量，统一属于类的静态资源，是类实例之间共享的，不是属于此类的任何特定对象。</p><p>静态非常量数据成员在类内仅声明，只能在类外定义和初始化。</p><p><code>static</code>函数不接受<code>this</code>指针只能访问类的 <code>static </code>成员变量。(因为不属于某个具体对象)</p><blockquote><p>static 成员函数不能被 virtual 修饰(同样，因为不属于具体的某个对象)<br>虚函数的重写是通过每个对象内的虚指针去调用，而虚指针调用需要用到<code>this</code>。(<code>this</code>指针 –&gt; <code>vptr</code> –&gt;<code>vtable</code> –&gt; <code>virtual function</code>)</p></blockquote><blockquote><p>静态成员函数中不能引用非静态成员。类的非静态成员函数可以调用用静态成员函数。<br>静态的资源属于类，并没有实例化对象，没办法知道该类具体有哪些非静态的资源。而对象创建时，类有哪些成员是已知的，均可访问。</p></blockquote><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化只有一次，但是可以多次赋值，在主程序之前，编译器已经为其分配好了内存。</p><blockquote><p>在静态数据区，内存中所有的字节默认值都是 <code>0x00</code>，可以不用人为的初始化。</p></blockquote><p>在 C++中，初始化时在<strong>执行相关代码时才会进行初始化</strong>，主要是由于 C++引入对象后，要进行初始化必须执行相应构造函数和析构函数，在构造函数或析构函数中经常会需要进行某些程序中需要进行的特定操作，并非简单地分配内存。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> 八股 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存分区</title>
      <link href="/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/"/>
      <url>/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<p>本文基于笔试时遇到的简答题「内存空间分为哪几类」以及面试时遇到的问题「用户态/内核态，了解多少」</p><span id="more"></span><h3 id="Kernal-Space"><a href="#Kernal-Space" class="headerlink" title="Kernal Space"></a><code>Kernal Space</code></h3><p>内核空间。由于开发和维护内核的复杂性，只有最重要的和最关键的代码放置在内核中。其他内容通常是作为用户空间应用程序编程的。（避免一些敏感操作）</p><h3 id="User-Space"><a href="#User-Space" class="headerlink" title="User Space"></a><code>User Space</code></h3><blockquote><p>用户态的程序不能随意操作内核空间，这样对操作系统具有一定的安全保护作用。</p></blockquote><p>用户空间从高地址到低地址依次分为如下五个区：</p><h4 id="stack"><a href="#stack" class="headerlink" title=".stack"></a><code>.stack</code></h4><p>栈区。<strong>编译器</strong>在需要的时候分配，不需要时自动清除的变量所在的储存区。</p><ul><li>由编译器自动管理</li><li>程序运行时分配内存</li><li>使用效率高、但空间有限。</li><li>从高地址向低地址扩展，内存连续。</li><li>先进后出</li><li>存放：函数的入口参数、局部变量等</li></ul><h4 id="heap"><a href="#heap" class="headerlink" title=".heap"></a><code>.heap</code></h4><p>堆区。由程序员手动分配释放的储存区。忘记释放会造成内存泄漏。</p><ul><li>程序员手动管理(手动申请、释放)</li><li>程序运行时分配内存</li><li>空间大，可以是不连续的。</li><li>从低地址向高地址扩展</li><li>先进先出</li><li><code>malloc、realloc</code>等开辟的空间即堆区的空间</li></ul><h4 id="bss-segment"><a href="#bss-segment" class="headerlink" title=".bss segment"></a><code>.bss segment</code></h4><p>全局/静态区。用来存放全局变量、静态变量的区域；当程序运行结束后由系统释放。</p><ul><li>由编译器自动管理</li><li>编译时分配内存</li><li>存放全局变量、静态变量</li></ul><h4 id="data-segment"><a href="#data-segment" class="headerlink" title=".data segment"></a><code>.data segment</code></h4><p>常量区。用来存放字符串字面量、<code>const</code>修饰的全局变量、静态变量。</p><ul><li>由编译器自动管理</li><li>编译时分配内存</li><li>存放<code>const</code>全局变量、<code>const</code>静态变量、字符串字面量。</li></ul><h4 id="text-segment"><a href="#text-segment" class="headerlink" title=".text segment"></a><code>.text segment</code></h4><p>代码区。用于存放CPU指令</p><ul><li>由编译器自动管理</li><li>编译时分配内存</li><li>存放CPU指令</li></ul><h3 id="用户态-内核态"><a href="#用户态-内核态" class="headerlink" title="用户态/内核态"></a>用户态/内核态</h3><blockquote><p>用户态  —  进程运行在用户空间<br>内核态  —  进程运行在内核空间</p></blockquote><p>在<strong>内核态</strong>下，CPU 可以<strong>执行任何指令</strong>。运行的<strong>代码也不受任何的限制</strong>，可以<strong>自由地访问任何有效地址</strong>，也可以直接进行端口的访问。</p><p>在用户态下，被执行的代码要受到 CPU 的很多检查。</p><h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><p>磁盘上文件的读写、内存空间的分配、网络接口读写数据等，都是在内核态完成的。平时使用时，借助操作系统提供的<strong>系统调用接口</strong>来进行使用。</p><blockquote><p>应用程序读取文件大致步骤</p></blockquote><ol><li>应用程序向内核发起系统调用，将进程从用户态切换为内核态。</li><li>CPU把数据读取到内核空间</li><li>数据拷贝到用户空间，并将进程切换为用户态。</li><li>应用程序得到相应的数据，执行其他命令。</li></ol><p>库函数、Shell指令等就是利用操作系统提供的调用接口来实现用户态的程序向操作系统申请更高权限的服务。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 八股 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程同步</title>
      <link href="/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
      <url>/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<p>程序执行结果依赖于不同线程执行的先后顺序，那么就会形成「竞争条件」，由于竞争条件下计算结果是非预期的，因此我们应该尽量避免竞争条件的形成。</p><p>解决竞争条件的方式，除原子操作外，还有线程同步。</p><span id="more"></span><h3 id="同步-amp-amp-互斥"><a href="#同步-amp-amp-互斥" class="headerlink" title="同步 &amp;&amp; 互斥"></a>同步 &amp;&amp; 互斥</h3><p>多个线程之间协调同步，按照预定的先后次序进行运行（非同时）</p><p>对于线程共享的线程资源，在各个线程访问时具有排它性。当有若干个线程要访问同一共享资源时，任何时刻只允许一个线程进行访问，直到占有资源者放弃使用该资源。</p><h3 id="同步方式"><a href="#同步方式" class="headerlink" title="同步方式"></a>同步方式</h3><h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><p>每个线程在对共享资源操作前都会尝试先加锁，加锁成功才能操作，操作结束之后解锁。</p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul><li>当线程抢互斥锁失败的时候，线程会陷入休眠。</li><li>节省CPU资源，消耗等待时间</li></ul><h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><p>条件变量用来锁定一个线程，直到某个特殊的条件发生才继续执行。</p><h5 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h5><ul><li>创建条件变量</li><li>某线程因等待条件变量成立而挂起</li><li>一段时间后，另一个线程激活了条件变量</li><li>条件变量清楚，线程继续执行。</li></ul><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>信号量，分匿名信号量和命名信号量。</p><ul><li><p>临界资源  —  同一时刻只允许一个线程（或进程）访问的资源</p></li><li><p>临界区  —  访问临界资源的代码段。</p></li><li><p>P操作  —  申请资源 </p></li><li><p>V操作  —  释放资源</p></li></ul><blockquote><p>信号量允许多个线程同时进入临界区，而互斥量只允许一个线程进入临界区。</p></blockquote><h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><p>读写锁和互斥锁类似，但允许更高的并行性，有一定的性能提升。</p><p>一次只有一个线程可以占有写模式下的读写锁，但是可以有多个线程占有读模式下的读写锁。</p><ul><li>写独占  —  写锁占用时，其他线程加读锁或者写锁时都会阻塞（并非失败）</li><li>读共享  —  读锁占用时，其他线程加写锁时会阻塞，加读锁会成功</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 八股 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL基础</title>
      <link href="/SQL%E5%9F%BA%E7%A1%80/"/>
      <url>/SQL%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>本文参考<a href="https://github.com/datawhalechina/wonderful-sql/">SQL基础教程</a>编写，建立在曾学习过相关课程的基础上，进行回顾。如您未曾接触过SQL，阅读本文可能会有些吃力。</p><span id="more"></span><h3 id="语法规范"><a href="#语法规范" class="headerlink" title="语法规范"></a>语法规范</h3><ol><li>MySQL本身不区分大小写，但强烈要求关键字大写，表名、列名用小写；</li><li>创建表时，使用统一的、描述性强的字段命名规则保证字段名是独一无二且不是保留字的，不要使用连续的下划线，不用下划线结尾；最好以字母开头</li><li>关键字右对齐，且不同层级的用空格或缩进控制，使其区分开。</li><li>列名少的时候写在一行里无伤大雅；多的时候以及涉及到CASE WHEN 或者聚合计算的时候，建议分行写；个人习惯是逗号在列名前面，方便之后删除某些列，放列名后亦可；</li><li>表别名和列别名尽量用有具体含义的词组，不要用<code>a b c</code>，不然以后review的时候会非常痛苦；</li><li>运算符前后都加一个空格；</li><li>当用到多个表时，请在所有列名前写上引用的表别名，不要嫌麻烦；</li><li>每条命令用分号结尾；</li><li>养成随手写注释的习惯，注释方法：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#单行注释</span><br><span class="line"><span class="comment">-- 单行注释</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="SQL语句分类"><a href="#SQL语句分类" class="headerlink" title="SQL语句分类"></a>SQL语句分类</h3><h4 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h4><p>DDL（Data Definition Language，数据定义语言） 用来<strong>创建或者删除</strong>存储数据用的<strong>数据库以及</strong>数据库中的<strong>表</strong>等对象。（create、drop、alter）</p><h4 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h4><p>DML（Data Manipulation Language，数据操纵语言） 用来<strong>查询或者变更表中的记录</strong>。(select、insert、update、delete)</p><h4 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h4><p>DCL（Data Control Language，数据控制语言） 用来<strong>确认或者取消</strong>对数据库中的<strong>数据进行的变更</strong>。除此之外，还可以对 RDBMS 的用户是否有权限操作数据库中的对象（数据库表等）进行设定。（commit、rollback、grant、revoke）</p><blockquote><p>Win 系统默认不区分表名及字段名的大小写<br>Linux / Mac 默认严格区分表名及字段名的大小写</p></blockquote><h3 id="基本语句"><a href="#基本语句" class="headerlink" title="基本语句"></a>基本语句</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># 创建数据库</span><br><span class="line">CREATE DATABASE &lt; 数据库名称 &gt; ;</span><br><span class="line"># 建表</span><br><span class="line">CREATE TABLE &lt; 表名 &gt;</span><br><span class="line">( &lt; 列名 1&gt; &lt; 数据类型 &gt; &lt; 该列所需约束 &gt; ,</span><br><span class="line">  &lt; 列名 2&gt; &lt; 数据类型 &gt; &lt; 该列所需约束 &gt; ,</span><br><span class="line">  &lt; 该表的约束 1&gt; , &lt; 该表的约束 2&gt;);</span><br><span class="line"># 删除表</span><br><span class="line">DROP TABLE &lt; 表名 &gt; ;</span><br><span class="line"># 添加列</span><br><span class="line">ALTER TABLE &lt; 表名 &gt; ADD COLUMN &lt; 列的定义 &gt;;</span><br><span class="line"># 删除列</span><br><span class="line">ALTER TABLE &lt; 表名 &gt; DROP COLUMN &lt; 列名 &gt;;</span><br><span class="line"># 删除行</span><br><span class="line">DELETE FROM product WHERE &lt; 所满足的条件 &gt;;</span><br><span class="line"># 更新数据 值可以改为NULL</span><br><span class="line">UPDATE &lt;表名&gt;</span><br><span class="line">   SET &lt;列名&gt; = &lt;表达式&gt; [, &lt;列名2&gt;=&lt;表达式2&gt;]  </span><br><span class="line"> WHERE &lt;条件&gt;  -- 可选，非常重要</span><br><span class="line"> ORDER BY 子句  -- 可选</span><br><span class="line"> LIMIT 子句; -- 可选</span><br><span class="line"># 插入</span><br><span class="line">INSERT INTO &lt;表名&gt; (列1, 列2, 列3) VALUES (值1, 值2, 值3);  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 创建索引</span><br><span class="line">-- 建表时</span><br><span class="line">CREATE TABLE mytable(&lt; 列名 1&gt; &lt; 数据类型 &gt; &lt; 该列所需约束 &gt;,  </span><br><span class="line">INDEX [indexName] (username(length))  );  </span><br><span class="line">-- else</span><br><span class="line">CREATE INDEX indexName ON table_name (column_name)</span><br><span class="line"></span><br><span class="line">ALTER table tableName ADD INDEX indexName(columnName)</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>只有未设置<code>NOT NULL</code>且非主键的列才可以清空为NULL。</p></blockquote><h4 id="列约束"><a href="#列约束" class="headerlink" title="列约束"></a>列约束</h4><ul><li><code>PRIMARY KEY</code>  —  主键</li><li><code>UNIQUE</code>  —  值唯一（NULL值可重复）</li><li><code>DEFAULT</code>  —  默认值（使用时不写、写<code>DEFAULT</code>均可以）</li><li><code>NOT NULL</code>  —  非空</li><li><code>FOREIGN</code>  —  外键</li><li><code>AUTO_INCREMENT</code>  —  自动成长（成长为列的最大值+1）</li></ul><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>索引的作用  —  提高查询速率</p><p>索引一般分为</p><ol><li>聚集索引  —  在数据库中，所有行数都会按照主键索引排序。</li><li>非聚集索引  —  就是给普通字段加上索引。</li><li>联合索引  —  好几个字段组成的索引称为联合索引。</li></ol><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>主键索引</li></ul><p>建立在主键上的索引。一张数据表只能有一个主键索引，索引列值不允许有空值，通常在创建表时一起创建。</p><ul><li>唯一索引</li></ul><p>建立在UNIQUE字段上的索引。一张表可以有多个唯一索引，索引列值允许为空，列值中出现多个空值不会发生重复冲突。</p><ul><li>普通索引</li></ul><p>建立在普通字段上的索引。</p><ul><li>前缀索引</li></ul><p>对字符类型字段的前几个字符或对二进制类型字段的前几个bytes建立索引。通常建立在类型为<code>char、varchar、binary、varbinary</code>的列上。</p><p>可以大大减少索引占用的存储空间，也能提升索引的查询效率。</p><ul><li>全文索引</li></ul><p>全文索引技术就是将各种信息，文档中所有的文字序列都作为检索对象，找出包含检索词汇的信息或文档。</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><blockquote><p>找某一列</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">DISTINCT</span>] <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><ul><li><code>*</code>查找全部</li><li>随意使用换行符，不影响语句执行。</li><li><code>DISTINCT</code>用来去重。</li><li><code>-- 单行注释</code> &amp; <code>/* 多行注释*/</code></li><li>SELECT子句中可以使用常数或者表达式。</li></ul><blockquote><p>寻找某列满足某一条件的值所在行中的某些列</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span></span><br><span class="line">  <span class="keyword">FROM</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line"> <span class="keyword">WHERE</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><table><thead><tr><th align="center">含义</th><th align="center">运算符</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">加</td></tr><tr><td align="center">-</td><td align="center">减</td></tr><tr><td align="center">*</td><td align="center">乘</td></tr><tr><td align="center">/</td><td align="center">除</td></tr><tr><td align="center">=</td><td align="center">相等</td></tr><tr><td align="center">&lt;&gt;</td><td align="center">不等</td></tr><tr><td align="center">&gt;</td><td align="center">大于</td></tr><tr><td align="center">&gt;=</td><td align="center">大于等于</td></tr><tr><td align="center">&lt;</td><td align="center">小于</td></tr><tr><td align="center">&lt;=</td><td align="center">小于等于</td></tr><tr><td align="center">NOT</td><td align="center">非</td></tr><tr><td align="center">AND</td><td align="center">与</td></tr><tr><td align="center">OR</td><td align="center">或</td></tr><tr><td align="center">()</td><td align="center">改变优先级</td></tr></tbody></table><ul><li><code>NULL</code>既不为真也不为假。值为<code>UNKNOWN</code></li></ul><h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><ul><li>COUNT  —  行数</li><li>SUM  —  数据的和</li><li>AVG  —  数据均值</li><li>MAX  —  数据最大值</li><li>MIN  —  数据最小值</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> FUNC(<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>) <span class="keyword">FROM</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> ;</span><br></pre></td></tr></table></figure><ul><li><code>COUNT(*)</code>包含含有<code>NULL</code>的项；<code>COUNT(列名)</code>不包含NULL值。</li><li><code>MAX/MIN</code>适用于所有(字典序)，<code>AVG/SUM</code>只适用于数值。</li></ul><h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><p><code>GROUP BY</code>按照某几列的值进行分组（有优先级）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">SELECT</span> <span class="operator">&lt;</span>列名<span class="number">1</span><span class="operator">&gt;</span>, <span class="operator">&lt;</span>列名<span class="number">2</span><span class="operator">&gt;</span>, <span class="operator">&lt;</span>列名<span class="number">3</span><span class="operator">&gt;</span>,</span><br><span class="line">    <span class="keyword">FROM</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>列名<span class="number">1</span><span class="operator">&gt;</span>, <span class="operator">&lt;</span>列名<span class="number">2</span><span class="operator">&gt;</span>, <span class="operator">&lt;</span>列名<span class="number">3</span><span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><h4 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h4><p><code>HAVING</code>用于解决<strong>WHERE无法与聚合函数一起使用</strong>。这一问题</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">SELECT</span> <span class="operator">&lt;</span>列名<span class="number">1</span><span class="operator">&gt;</span>, <span class="operator">&lt;</span>列名<span class="number">2</span><span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">FROM</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line">   <span class="keyword">WHERE</span> <span class="operator">&lt;</span>条件<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>列名<span class="number">1</span><span class="operator">&gt;</span>, <span class="operator">&lt;</span>列名<span class="number">2</span><span class="operator">&gt;</span></span><br><span class="line">  <span class="keyword">HAVING</span> <span class="operator">&lt;</span>条件[常为聚合后的条件]<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p><code>ORDER BY</code>将查询结果排序。默认为升序排列，降序排列为<code>DESC</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">SELECT</span> <span class="operator">&lt;</span>列名<span class="number">1</span><span class="operator">&gt;</span>, <span class="operator">&lt;</span>列名<span class="number">2</span><span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">FROM</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line">   <span class="keyword">WHERE</span> <span class="operator">&lt;</span>条件<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>列名<span class="number">1</span><span class="operator">&gt;</span>, <span class="operator">&lt;</span>列名<span class="number">2</span><span class="operator">&gt;</span></span><br><span class="line">  <span class="keyword">HAVING</span> <span class="operator">&lt;</span>条件[常为聚合后的条件]<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>排序基准列<span class="number">1</span><span class="operator">&gt;</span>, <span class="operator">&lt;</span>排序基准列<span class="number">2</span><span class="operator">&gt;</span> [<span class="keyword">DESC</span>]</span><br></pre></td></tr></table></figure><ul><li><code>MySQL</code>中认为<code>NULL</code>值比<code>非NULL</code>小。（排序时可能需要特殊处理）<ul><li>在排序时可以使用<code>IS NULL</code>运算符及<code>ISNULL()</code>函数来对NULL值做特殊处理</li></ul></li></ul><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>视图是一个虚拟的表，不同于直接操作数据表，视图是依据 SELECT 语句来创建的，所有操作视图时会根据创建视图的 <code>SELECT</code> 语句生成一张虚拟表，然后在这张虚拟表上做 SQL 操作。</p><blockquote><p>视图与表的区别是「是否保存了实际的数据」</p></blockquote><p>视图<strong>并不是</strong>数据库<strong>真实存储的数据表</strong>，它可以看作是一个窗口，通过这个窗口我们可以看到数据库表中真实存在的数据。</p><h4 id="存在原因"><a href="#存在原因" class="headerlink" title="存在原因"></a>存在原因</h4><ul><li>可以将频繁使用的 SELECT 语句保存以提高效率。</li><li>可以使用户看到的数据更加清晰。</li><li>可以不对外公开数据表全部字段，增强数据的保密性。</li><li>可以降低数据的冗余。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建视图</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> <span class="operator">&lt;</span>视图名称<span class="operator">&gt;</span>(<span class="operator">&lt;</span>列名<span class="number">1</span><span class="operator">&gt;</span>,<span class="operator">&lt;</span>列名<span class="number">2</span><span class="operator">&gt;</span>) <span class="keyword">AS</span> <span class="operator">&lt;</span><span class="keyword">SELECT</span>语句<span class="operator">&gt;</span></span><br><span class="line"># 可以基于多张表创建视图</span><br></pre></td></tr></table></figure><ul><li>SELECT 语句中列的排列顺序和视图中列的排列顺序相同</li><li>视图名在数据库中需要是唯一的，不能与其他视图和表重名。</li></ul><h4 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h4><p>由于视图是一个虚拟表，对视图的操作就是对底层基础表的操作。</p><p>故，当视图存在以下结构时不能更新：</p><ul><li>聚合函数。如，SUM()、MIN()、COUNT() </li><li>DISTINCT 关键字</li><li>GROUP BY 子句。</li><li>HAVING 子句。</li><li>UNION 或 UNION ALL 运算符。</li><li>FROM 子句中包含多个表。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE <span class="operator">&lt;</span>视图名称<span class="operator">&gt;</span></span><br><span class="line">   <span class="keyword">SET</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> <span class="operator">=</span> <span class="operator">&lt;</span>表达式<span class="operator">&gt;</span></span><br><span class="line"> <span class="keyword">WHERE</span> <span class="operator">&lt;</span>条件<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><h4 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> <span class="operator">&lt;</span>视图名<span class="number">1</span><span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>一个查询语句嵌套在另一个查询语句内部。子查询结果作为外层查询的过滤条件，查询可以基于一个表或者多个表。</p><blockquote><p>不建议嵌套多层子查询<br>虽然嵌套子查询可以查询出结果，但是随着子查询嵌套的层数的叠加，SQL语句不仅会难以理解而且执行效率也会很差，所以要尽量避免这样的使用。</p></blockquote><h4 id="标量子查询"><a href="#标量子查询" class="headerlink" title="标量子查询"></a>标量子查询</h4><p>执行的SQL语句只能返回一个值，也就是要返回表中具体的<strong>某一行的某一列</strong>。</p><blockquote><p>标量子查询不仅仅局限于 WHERE 子句中，通常任何可以使用单一值的位置都可以使用。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查找价格高于平均值的商品</span></span><br><span class="line"><span class="keyword">SELECT</span> product_id, product_name, sale_price</span><br><span class="line">  <span class="keyword">FROM</span> product</span><br><span class="line"> <span class="keyword">WHERE</span> sale_price <span class="operator">&gt;</span> (<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(sale_price) <span class="keyword">FROM</span> product) <span class="keyword">AS</span> avg_price;</span><br></pre></td></tr></table></figure><blockquote><p>这里出现的<code>AS</code>用来起别名。创建别名是为了让列名称的可读性更强。</p></blockquote><h4 id="关联子查询"><a href="#关联子查询" class="headerlink" title="关联子查询"></a>关联子查询</h4><p>关联子查询，在细分的组内进行比较时使用。</p><blockquote><p>需要特别注意其与一般的SQL语句相比，执行顺序有所不同。</p></blockquote><ul><li>首先执行不带WHERE的主查询，获取到所关联的列，依次（一次传一行）传入子查询。</li><li>根据主查询传入的结果匹配子查询，将查询结果返回父查询</li><li>根据子查询返回值依次判断父查询的<code>WHERE</code>子句。</li></ul><p>以下列代码为例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/********************</span></span><br><span class="line"><span class="comment">  已知 有一张表 score</span></span><br><span class="line"><span class="comment">   表中含有如下信息：</span></span><br><span class="line"><span class="comment">   student_id 学生学号</span></span><br><span class="line"><span class="comment">    course_id 课程号</span></span><br><span class="line"><span class="comment"> course_score 课程成绩</span></span><br><span class="line"><span class="comment">  所要查询的内容：</span></span><br><span class="line"><span class="comment">  成绩大于平均分的学生</span></span><br><span class="line"><span class="comment">  的学号、课程号、成绩</span></span><br><span class="line"><span class="comment"> ********************/</span> </span><br><span class="line"><span class="keyword">SELECT</span> student_id,course_id,course_score</span><br><span class="line">  <span class="keyword">FROM</span> score <span class="keyword">AS</span> s1</span><br><span class="line"> <span class="keyword">WHERE</span> course_score <span class="operator">&gt;</span> ( <span class="keyword">SELECT</span> <span class="built_in">AVG</span>(course_score)</span><br><span class="line">             <span class="keyword">FROM</span> score <span class="keyword">AS</span> s2</span><br><span class="line">            <span class="keyword">WHERE</span> s1.course_id <span class="operator">=</span> s2.course_id</span><br><span class="line">       <span class="keyword">GROUP</span> <span class="keyword">BY</span> course_id);</span><br></pre></td></tr></table></figure><ol><li>首先执行主查询<code>SELECT student_id,course_id,course_score FROM score AS s1</code>提取出<code>student_id,course_id、course_score</code>三列所需要的信息</li><li>执行<code>()</code>中的子查询语句，依次将<code>course_id</code>传入<code>s1.course_id= s2.course_id </code>并执行得到<ul><li>如第一步查询出课程编号为<code>10001  10002  10003  10004</code></li><li>依次将课程号传入相应位置 执行<code>SELECT AVG(course_score) FROM score AS s2 WHERE course_id = 10001 GROUP BY course_id</code>根据这门课的所有人成绩计算该门课的平均分</li><li>依次将每门课的平均分<code>val</code>值返回给主查询。</li></ul></li><li>然后依次执行<code>SELECT student_id,course_id,course_score FROM score AS s1 WHERE course_score &gt; val</code>。得到每门课成绩大于平均分的学生的信息。</li></ol><blockquote><p>其中 需要注意的是 看似是废话的<code>WHERE s1.course_id = s2.course_id</code>即为关联子查询的关键点。（关联条件）</p></blockquote><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>SQL内置了一些函数，极大提高了SQL语言的便利性。分类如下</p><ul><li>算术函数</li><li>字符串函数</li><li>日期函数</li><li>转换函数</li><li>聚合函数</li></ul><h4 id="算术函数"><a href="#算术函数" class="headerlink" title="算术函数"></a>算术函数</h4><ul><li>ABS(val)  —  绝对值。ABS(NULL) 返回NULL</li><li>MOD(val, pow)  —  取余。</li><li>ROUND(val, n)  —  四舍五入保留n位小数。</li></ul><h4 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h4><ul><li>CONCAT(str1, str2)  —  字符串拼接</li><li>LENGTH(str)  —  字符串长度</li><li>LOWER(str)  —  转换成小写</li><li>UPPER(str)  —  转换成大写</li><li>REPLACE(str,ch1,ch2)  —  将str中<code>ch1</code>全部替换为<code>ch2</code></li><li>SUBSTRING(str FROM pos FOR n)  —  在str中pos位置开始提取长度为n的子串</li><li>SUBSTRING_INDEX(str,ch,n)  —  以ch为分隔符划分str，并获取第n个分隔符前的所有内容</li><li>REPEAT(str,n)  —  将字符串str重复n次</li></ul><h4 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h4><ul><li>CURRENT_DATE  —  获取当前日期</li><li>CURRENT_TIME  —  获取当前时间</li><li>CURRENT_TIMESTAMP  —  获取当前日期和时间</li><li>EXTRACT(日期元素 FROM 日期)  —  从日期中截取信息<ul><li>EXTRACT(YEAR   FROM CURRENT_TIMESTAMP) AS year 获取年份。</li><li>日期元素有<code>YEAR  MONTH  DAY  HOUR  MINUTE  SECOND</code></li></ul></li></ul><h4 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h4><ul><li>CAST(val,type)  —  将值转换成相应的类型</li><li>COALESCE(val1,val2,….)  —  获取所有参数中第一个非NULL值。</li></ul><h3 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h3><p>表示个体的性质和个体之间关系的符号。主要包括<code>LIKE、BETWEEN、IS NULL、IS NOT NULL、IN 、EXISTS</code></p><h4 id="LIKE"><a href="#LIKE" class="headerlink" title="LIKE"></a>LIKE</h4><p>用于字符串的部分匹配</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">&lt;</span>列名<span class="number">1</span><span class="operator">&gt;</span>, <span class="operator">&lt;</span>列名<span class="number">2</span><span class="operator">&gt;</span></span><br><span class="line">  <span class="keyword">FROM</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line"> <span class="keyword">WHERE</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> <span class="keyword">LIKE</span> <span class="operator">&lt;</span>字符串<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><p>字符串支持正则表达式。</p><ul><li><code>%</code>表示任意个数字符。例如，<code>%xxx%</code>表示含有<code>xxx</code>的所有字符串。</li><li><code>_</code>表示一个字符。例如<code>_xxx%</code>表示第2~4位为<code>xxx</code>的所有字符串。</li><li><code>[x]</code>表示列表中的一个字符。例如<code>[abcd]xxx</code>表示<code>axxx</code>或<code>bxxx</code>或<code>cxxx</code>或<code>dxxx</code></li><li><code>[^x] 、 [!x]</code>表示不在列表中的字符。<code>[^abc]xxx</code>表示长度为4，首位不为<code>a  b  c</code>，后三位为<code>xxx</code>的字符串</li></ul><h4 id="BETWEEN"><a href="#BETWEEN" class="headerlink" title="BETWEEN"></a>BETWEEN</h4><p>用于范围查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> product_name, sale_price</span><br><span class="line">  <span class="keyword">FROM</span> product</span><br><span class="line">  <span class="keyword">WHERE</span> sale_price <span class="keyword">BETWEEN</span> <span class="number">100</span> <span class="keyword">AND</span> <span class="number">1000</span>;</span><br><span class="line"><span class="comment">-- 查询价格在100~1000之间的商品</span></span><br></pre></td></tr></table></figure><blockquote><p><code>BETWEEN val1 AND val2 </code>包括左右临界值。</p></blockquote><h4 id="IS-NULL-IS-NOT-NULL"><a href="#IS-NULL-IS-NOT-NULL" class="headerlink" title="IS NULL/ IS NOT NULL"></a>IS NULL/ IS NOT NULL</h4><p>取空或非空（有些条件下不能使用<code>= &lt;&gt;</code>，比如取值为空的数据）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> product_name, purchase_price</span><br><span class="line">  <span class="keyword">FROM</span> product</span><br><span class="line"> <span class="keyword">WHERE</span> purchase_price <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><h4 id="IN-NOT-IN"><a href="#IN-NOT-IN" class="headerlink" title="IN/ NOT IN"></a>IN/ NOT IN</h4><p>多条件并集的查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> product_name, purchase_price</span><br><span class="line">  <span class="keyword">FROM</span> product</span><br><span class="line"> <span class="keyword">WHERE</span> purchase_price <span class="keyword">IN</span> (<span class="number">250</span>,<span class="number">500</span>,<span class="number">750</span>);</span><br><span class="line"> <span class="comment">/**********************************</span></span><br><span class="line"><span class="comment">       purchase_price = 250</span></span><br><span class="line"><span class="comment">    OR purchase_price = 500</span></span><br><span class="line"><span class="comment">    OR purchase_price = 750;</span></span><br><span class="line"><span class="comment">***********************************/</span></span><br></pre></td></tr></table></figure><blockquote><p>IN 还可以用在子查询中<br>比如某连锁商店有很多个分店，不同分店的商品不完全一样<br>我们查询某个分店的是否有某个商品时<br>子查询返回该分店的所有商品<br>主查询判断是否在这个范围内</p></blockquote><h4 id="EXIST-NOT-EXIST"><a href="#EXIST-NOT-EXIST" class="headerlink" title="EXIST/NOT EXIST"></a>EXIST/NOT EXIST</h4><p>「判断是否存在满足某种条件的<strong>记录</strong>」。存在，返回<code>true</code>；不存在，返回<code>false</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 选出某个分店在售商品(价格不为NULL)的单价</span></span><br><span class="line"><span class="comment">-- IN</span></span><br><span class="line"><span class="keyword">SELECT</span> product_name, sale_price</span><br><span class="line">  <span class="keyword">FROM</span> product</span><br><span class="line"> <span class="keyword">WHERE</span> product_id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> product_id</span><br><span class="line">                        <span class="keyword">FROM</span> shopproduct</span><br><span class="line">                       <span class="keyword">WHERE</span> shop_id <span class="operator">=</span> <span class="string">&#x27;XXX&#x27;</span>);</span><br><span class="line"><span class="comment">-- EXIST</span></span><br><span class="line"><span class="keyword">SELECT</span> product_name, sale_price</span><br><span class="line">  <span class="keyword">FROM</span> product <span class="keyword">AS</span> p</span><br><span class="line"> <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="comment">-- 这里可以书写适当的常数</span></span><br><span class="line">                 <span class="keyword">FROM</span> shopproduct <span class="keyword">AS</span> sp</span><br><span class="line">                <span class="keyword">WHERE</span> sp.shop_id <span class="operator">=</span> <span class="string">&#x27;XXX&#x27;</span></span><br><span class="line">                  <span class="keyword">AND</span> sp.product_id <span class="operator">=</span> p.product_id);</span><br></pre></td></tr></table></figure><blockquote><p>由于 EXIST 只关心记录是否存在，返回哪些列都没有关系。</p></blockquote><h3 id="CASE"><a href="#CASE" class="headerlink" title="CASE"></a>CASE</h3><p>条件分支。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CASE</span> <span class="keyword">WHEN</span> <span class="operator">&lt;</span>求值表达式<span class="operator">&gt;</span> <span class="keyword">THEN</span> <span class="operator">&lt;</span>表达式<span class="operator">&gt;</span></span><br><span class="line">     <span class="keyword">WHEN</span> <span class="operator">&lt;</span>求值表达式<span class="operator">&gt;</span> <span class="keyword">THEN</span> <span class="operator">&lt;</span>表达式<span class="operator">&gt;</span></span><br><span class="line">     <span class="keyword">WHEN</span> <span class="operator">&lt;</span>求值表达式<span class="operator">&gt;</span> <span class="keyword">THEN</span> <span class="operator">&lt;</span>表达式<span class="operator">&gt;</span></span><br><span class="line"><span class="comment">-- 均为假执行else</span></span><br><span class="line"><span class="keyword">ELSE</span> <span class="operator">&lt;</span>表达式<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">END</span>  </span><br><span class="line"><span class="comment">-- 可以用于调用聚合函数时 一些特殊值的处理</span></span><br><span class="line"><span class="keyword">CASE</span> <span class="keyword">WHEN</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">THEN</span> <span class="operator">&lt;</span>表达式<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">ELSE</span> <span class="operator">&lt;</span>表达式<span class="operator">&gt;</span> <span class="keyword">END</span></span><br></pre></td></tr></table></figure><h3 id="集合的运算"><a href="#集合的运算" class="headerlink" title="集合的运算"></a>集合的运算</h3><p><code>表、视图、查询结果</code>都是记录的集合， 其中的元素为「表或者查询结果」中的每一行。</p><p><code>UNION、INTERSECT、EXCEPT</code> 来将检索结果进行集合运算。</p><h4 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h4><p>UNION，重复项会去重。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************</span></span><br><span class="line"><span class="comment"> 楼下有两个商店</span></span><br><span class="line"><span class="comment"> shop1为A商店所卖商品</span></span><br><span class="line"><span class="comment"> shop2为B商店所卖商品</span></span><br><span class="line"><span class="comment"> 求问能在楼下买到啥</span></span><br><span class="line"><span class="comment">******************/</span></span><br><span class="line"><span class="keyword">SELECT</span> product_id, product_name</span><br><span class="line">  <span class="keyword">FROM</span> shop1</span><br><span class="line"> <span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> product_id, product_name</span><br><span class="line">  <span class="keyword">FROM</span> shop2;</span><br></pre></td></tr></table></figure><p><code>UNION ALL</code>取并集后不去重。</p><h4 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h4><p>INTERSECT，<code>MySQL</code>不支持。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 两个商店中均能买到的商品</span></span><br><span class="line"><span class="comment">-- INTERSECT</span></span><br><span class="line">   <span class="keyword">SELECT</span> product_id, product_name</span><br><span class="line">     <span class="keyword">FROM</span> shop1</span><br><span class="line"><span class="keyword">INTERSECT</span></span><br><span class="line">   <span class="keyword">SELECT</span> product_id, product_name</span><br><span class="line">     <span class="keyword">FROM</span> shop2;</span><br><span class="line"><span class="comment">-- 手动模拟</span></span><br><span class="line">    <span class="keyword">SELECT</span> s1.product_id, s1.product_name</span><br><span class="line">      <span class="keyword">FROM</span> shop1 s1</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> shop2 s2</span><br><span class="line">        <span class="keyword">ON</span> s1.product_id<span class="operator">=</span>s2.product_id</span><br></pre></td></tr></table></figure><h4 id="差集"><a href="#差集" class="headerlink" title="差集"></a>差集</h4><p>EXCEPT，<code>MySQL</code>不支持。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 只能在A商店中买的商品</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> shop1</span><br><span class="line"> <span class="keyword">WHERE</span> product_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> product_id</span><br><span class="line">                          <span class="keyword">FROM</span> shop2)</span><br><span class="line"><span class="comment">-- EXCEPT</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> shop1</span><br><span class="line"><span class="keyword">EXCEPT</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> shop2</span><br></pre></td></tr></table></figure><h4 id="对称差"><a href="#对称差" class="headerlink" title="对称差"></a>对称差</h4><p>两个集合<code>A  B</code>， 求仅在A及仅在B中的元素。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 只能在一个商店买</span></span><br><span class="line"><span class="comment">-- 另一个商店买不到</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> shop1</span><br><span class="line"> <span class="keyword">WHERE</span> product_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> product_id</span><br><span class="line">                          <span class="keyword">FROM</span> shop2)</span><br><span class="line"> <span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> shop2</span><br><span class="line"> <span class="keyword">WHERE</span> product_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> product_id</span><br><span class="line">                          <span class="keyword">FROM</span> shop1)</span><br><span class="line"><span class="comment">-- 交集 - 并集</span></span><br></pre></td></tr></table></figure><h3 id="JOIN"><a href="#JOIN" class="headerlink" title="JOIN"></a>JOIN</h3><p>从多个表获取信息时，用于表的合并。</p><p>使用某种关联条件将其他表中的列添加过来, 进行「添加列」的集合运算。</p><p>关联条件  —  两个表中的公共列信息（两个表建立关联的桥梁）</p><h4 id="INNER-JOIN"><a href="#INNER-JOIN" class="headerlink" title="INNER JOIN"></a>INNER JOIN</h4><p>将两张表进行连结。其中不满足关联条件的行被丢弃。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>表<span class="number">1</span><span class="operator">&gt;</span> <span class="keyword">INNER</span> <span class="keyword">JOIN</span> <span class="operator">&lt;</span>表<span class="number">2</span><span class="operator">&gt;</span> <span class="keyword">ON</span> <span class="operator">&lt;</span>关联条件<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>如果分组列和被聚合的列不在同一张表, 且二者都未被用于连结两张表, 则只能先连结, 再聚合。</p></blockquote><h5 id="NATURAL-JOIN"><a href="#NATURAL-JOIN" class="headerlink" title="NATURAL JOIN"></a>NATURAL JOIN</h5><p><code>INNER JOIN</code>的特例，会按照两个表中都包含的列名来进行等值连结。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>表<span class="number">1</span><span class="operator">&gt;</span> <span class="keyword">NATURAL</span>  <span class="keyword">JOIN</span> <span class="operator">&lt;</span>表<span class="number">2</span><span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><h4 id="OUTER-JOIN"><a href="#OUTER-JOIN" class="headerlink" title="OUTER JOIN"></a>OUTER JOIN</h4><p>将两张表进行连结。其中会保留部分不满足条件的行。提取不到的值填充为<code>NULL</code>值。</p><ul><li>LEFT OUTER JOIN  —  左外连结。保留左表（表1）中匹配失败的值。</li><li>RIGHT OUTER JOIN  —  右外连结。保留右表（表2）中匹配失败的值。</li><li>FULL OUTER JOIN  —  全外连结。两个表中匹配失败的值均会保留。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>表<span class="number">1</span><span class="operator">&gt;</span>  <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> <span class="operator">&lt;</span>表<span class="number">2</span><span class="operator">&gt;</span> <span class="keyword">ON</span> <span class="operator">&lt;</span>关联条件<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>表<span class="number">1</span><span class="operator">&gt;</span> <span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> <span class="operator">&lt;</span>表<span class="number">2</span><span class="operator">&gt;</span> <span class="keyword">ON</span> <span class="operator">&lt;</span>关联条件<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>表<span class="number">1</span><span class="operator">&gt;</span>  <span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> <span class="operator">&lt;</span>表<span class="number">2</span><span class="operator">&gt;</span> <span class="keyword">ON</span> <span class="operator">&lt;</span>关联条件<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><h4 id="多表连结"><a href="#多表连结" class="headerlink" title="多表连结"></a>多表连结</h4><p>语法中JOIN只涉及两个表，但实际使用会涉及多张表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- INNER JOIN</span></span><br><span class="line">      <span class="keyword">FROM</span> <span class="operator">&lt;</span>表<span class="number">1</span><span class="operator">&gt;</span> </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> <span class="operator">&lt;</span>表<span class="number">2</span><span class="operator">&gt;</span> <span class="keyword">ON</span> <span class="operator">&lt;</span>关联条件<span class="number">1</span><span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> <span class="operator">&lt;</span>表<span class="number">3</span><span class="operator">&gt;</span> <span class="keyword">ON</span> <span class="operator">&lt;</span>关联条件<span class="number">2</span><span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> <span class="operator">&lt;</span>表<span class="number">4</span><span class="operator">&gt;</span> <span class="keyword">ON</span> <span class="operator">&lt;</span>关联条件<span class="number">3</span><span class="operator">&gt;</span></span><br><span class="line"><span class="comment">-- OUTER JOIN 同理</span></span><br></pre></td></tr></table></figure><h4 id="非等值连结"><a href="#非等值连结" class="headerlink" title="非等值连结"></a>非等值连结</h4><p>ON子句中的关联条件不局限于两表中相等。</p><h4 id="交叉连结"><a href="#交叉连结" class="headerlink" title="交叉连结"></a>交叉连结</h4><p><code>CROSS JOIN</code>笛卡尔积。交叉连结不具备<code>ON</code>子句（可以理解为恒真）</p><p>对两张表中的全部记录进行交叉组合，因此结果中的记录数通常是两张表中行数的乘积。</p><h3 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h3><p><code>OnLine AnalyticalProcessing</code>OLAP函数。对数据库数据进行实时分析处理。</p><p>常规的SELECT语句都是对整张表进行查询，而窗口函数可以让我们有选择的去某一部分数据进行汇总、计算和排序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span>窗口函数<span class="operator">&gt;</span> <span class="keyword">OVER</span> ([<span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span>]</span><br><span class="line">                     <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>排序用列名<span class="operator">&gt;</span>)  </span><br><span class="line"><span class="comment">-- [PARTITION BY &lt;列名&gt;] 可以省略</span></span><br></pre></td></tr></table></figure><ul><li>PARTITION BY  —  指定窗口对象(分组基准)</li><li>ORDER BY  —  窗口内排序</li></ul><h4 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h4><p>窗口函数分为</p><ul><li>通用函数  —  <code>SUM  MAX  MIN</code>等</li><li>专用函数  —  <code>RANK  DENSE_RANK</code>等</li></ul><p>通用函数在聚合函数中就在使用。专用函数是专属的。</p><ul><li>RANK()  —  排序，存在相同位次会跳相应的位次<code>1 1 3</code></li><li>DENSE_RANK()  —  排序。存在相同位次不会跳相应的位次<code>1 1 2</code></li><li>ROW_NUMBER()  —  排序。值唯一（顺延，不存在并列）</li></ul><blockquote><p>聚合函数在窗口函数应用时，是一个<strong>累计</strong>的聚合函数值。(AVG分母从1开始加)</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++2.0</title>
      <link href="/c-2-0/"/>
      <url>/c-2-0/</url>
      
        <content type="html"><![CDATA[<p>本文综合了候捷老师「C++11/C++14课程」的内容及一些其他的自己已知的C++11的内容。</p><span id="more"></span><h3 id="vector-shrink-to-fit"><a href="#vector-shrink-to-fit" class="headerlink" title="vector::shrink_to_fit()"></a>vector::shrink_to_fit()</h3><p>减少容量，适应实际大小。（根据当前容量大小调用分配器的<code>realloc</code>版本）</p><blockquote><p>比如当前当前容量为256，存放了129个元素（扩容部分仅用了一个），调用该接口可以调整空间容量为<code>129</code></p></blockquote><h3 id="std-function"><a href="#std-function" class="headerlink" title="std::function"></a>std::function</h3><p>std::function的实例可以对任何可以调用的目标实体进行存储、复制和调用操作。这些目标实体包括普通函数、Lambda表达式、函数指针以及其它函数对象等。（升级版函数指针）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MyFunc1</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;&#125;</span><br><span class="line">function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; functor1 = MyFunc1;</span><br><span class="line"><span class="built_in">functor1</span>(<span class="number">7</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//lambda</span></span><br><span class="line"><span class="keyword">auto</span> MyFunc2 =[](<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;<span class="keyword">return</span> a + b;&#125;;</span><br><span class="line">function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; functor2 = MyFunc2;</span><br><span class="line"><span class="built_in">functor2</span>(<span class="number">2</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//仿函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyFunc3</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; functor3 = MyFunc3;</span><br><span class="line"><span class="built_in">functor2</span>(<span class="number">2</span>,<span class="number">9</span>);</span><br></pre></td></tr></table></figure><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p>new分配内存，智能指针可以自动释放。而传统指针需要手动delete。<br>智能指针对普通的指针进行封装，负责自动释放所指的对象，这样的一层封装机制的目的是为了使得智能指针可以方便的管理一个对象的生命期。</p><ol><li>auto_ptr（c++11弃用）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;I reigned loney as a cloud.&quot;</span>))</span></span>;</span><br><span class="line">auto_ptr&lt;string&gt; p2;</span><br><span class="line">p2=p1; <span class="comment">//auto_ptr不会报错</span></span><br></pre></td></tr></table></figure><p>此时p2剥夺p1所有权。访问p1会报错。（存在内存崩溃的风险）</p><ol start="2"><li><p>unique_ptr</p><p>实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。避免资源泄露</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;I reigned loney as a cloud.&quot;</span>))</span></span>;</span><br><span class="line">unique_ptr&lt;string&gt; p4;</span><br><span class="line">p4 = p3; <span class="comment">//error</span></span><br><span class="line"><span class="comment">/*****************************</span></span><br><span class="line"><span class="comment">当将一个 unique_ptr 赋值给另一个</span></span><br><span class="line"><span class="comment">如果源 unique_ptr 是个临时右值</span></span><br><span class="line"><span class="comment">编译器允许这么做</span></span><br><span class="line"><span class="comment">否则 报错</span></span><br><span class="line"><span class="comment">*****************************/</span></span><br><span class="line">unique_ptr&lt;string&gt; ps1, ps2;</span><br><span class="line">ps1 = make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">200</span>);</span><br><span class="line">ps2 = <span class="built_in">move</span>(ps1);</span><br></pre></td></tr></table></figure><ol start="3"><li><p>shared_ptr</p><p>实现<strong>共享式</strong>拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。用计数机制来表明资源被几个指针共享。</p><p>多个线程同时读同一个shared_ptr对象是线程安全的，但是如果是多个线程对同一个shared_ptr对象进行读和<strong>写</strong>，则需要<strong>加锁</strong>。<br>多线程读写shared_ptr所指向的同一个对象，不管是相同的shared_ptr对象，还是不同的shared_ptr对象，也需要加锁保护。</p><p>shared_ptr拥有成员函数如下：</p><ul><li>use_count  —  引用计数的个数</li><li>unique  —  是否独占</li><li>swap  —  交换两个shared_ptr所拥有的对象</li><li>get  —  返回内部对象</li></ul></li><li><p>weak_ptr</p><ul><li>尝尝与shared_ptr搭配使用，为shared_ptr的观察者。</li></ul><ul><li>不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象。</li><li>当 shared_ptr 管理的资源被释放时，weak_ptr 会自动变成 nullptr。</li><li>只是提供了对管理对象的一个访问手段。用来解决shared_ptr相互引用时的死锁问题</li></ul></li></ol><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul><li><code>const_cast</code>  —  将<code>const type</code>转化为<code>type</code>（type为<strong>指针或引用</strong>）</li><li><code>static_cast</code>  —  可以用于各种编译器认可的隐式转换(类对象向上转换)</li><li><code>dynamic_cast</code>  —  用于含有虚函数的类的转换，用于类向上和向下转换</li><li><code>reinterpret_cast</code>  —  任意类型转换，不保证成功。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//static_cast</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">double</span> b = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(a);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span>:</span>Base&#123; &#125;;</span><br><span class="line">Base* ptr;</span><br><span class="line">Derive *temp = <span class="keyword">new</span> <span class="built_in">Derive</span>();</span><br><span class="line">ptr = <span class="keyword">static_cast</span>&lt;Base*&gt;(temp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//const_cast</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(&amp;a);</span><br></pre></td></tr></table></figure><h3 id="Variadic-Template"><a href="#Variadic-Template" class="headerlink" title="Variadic Template"></a>Variadic Template</h3><p>数量不定的模板参数。</p><p><code>...</code>用来表示一包<code>pack</code>。表示模板参数、函数参数、函数参数类型的数量不确定。（用来递归）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;&#125;<span class="comment">//递归出口</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Types&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(constT&amp; firstArg,<span class="keyword">const</span> Types&amp;... args)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt;firstArg&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">print</span>(args...);</span><br><span class="line">    <span class="comment">//sizeof...(args)可以知道当前剩余几个</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//tuple</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Values&gt;<span class="class"><span class="keyword">class</span> <span class="title">tuple</span>;</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">class</span> <span class="title">typle</span>&lt;</span>&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head,<span class="keyword">typename</span>... Tail&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tuple</span>&lt;</span>Head,Tail...&gt;</span><br><span class="line">    :<span class="keyword">private</span> tuple&lt;Tail...&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">        Head m_head;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*******************************************</span></span><br><span class="line"><span class="comment">X&lt;T1,T2,T3&gt; ==&gt; X&lt;T2,T3&gt; ==&gt; X&lt;T3&gt; ==&gt;  X&lt;&gt;</span></span><br><span class="line"><span class="comment">  T1 t1     ==&gt;   T2 t2  ==&gt; T3 t3 ==&gt; NULL</span></span><br><span class="line"><span class="comment">*******************************************/</span></span><br></pre></td></tr></table></figure><p>作用域</p><ul><li>函数模板</li><li>类模板</li></ul><p>变化的是模板参数</p><ul><li>参数个数（参数个数逐一递减，实现递归）</li><li>参数类型（参数类型随参数个数也变化）</li></ul><h4 id="重写printf"><a href="#重写printf" class="headerlink" title="重写printf"></a>重写printf</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无参数版本 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(*s) &#123;</span><br><span class="line">        <span class="keyword">if</span>(*s == <span class="string">&#x27;%&#x27;</span> &amp;&amp; *(++s)!=<span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">            <span class="comment">//还有参数，则抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        std::cout&lt;&lt;*s++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*,T value,Args... args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(*s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*s == <span class="string">&#x27;%&#x27;</span> &amp;&amp; *(++s)!=<span class="string">&#x27;%&#x27;</span>) &#123;<span class="comment">//拿类型</span></span><br><span class="line">            std::cout &lt;&lt; value; <span class="comment">//输出</span></span><br><span class="line">            <span class="built_in">printf</span>(++s,args...);<span class="comment">//跳过 d,s,f等 继续递归</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout&lt;&lt;*s++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;xxx&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%d%s%p%f\n&quot;</span>,<span class="number">15</span>,<span class="string">&quot;Hello World&quot;</span>,pi,<span class="number">3.1415926</span>);</span><br></pre></td></tr></table></figure><p>递归继承 —  tuple</p><h3 id="Spaces-in-Template-Expressions"><a href="#Spaces-in-Template-Expressions" class="headerlink" title="Spaces in Template Expressions"></a>Spaces in Template Expressions</h3><p>模板表达式中的空格。</p><p>在过去的版本中，<code>vector&lt;vector&lt;int&gt; &gt; res</code>，右侧的<code>&gt; &gt;</code>中间必须有空格，不然编译器会以为是个操作符。该版本之后中间的空格可以取消。</p><h3 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h3><p>C++11支持使用 <code>nullptr</code>代替<code>0  NULL</code>，其类型为<code>std::nullptr_t</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span>(<span class="number">0</span>);<span class="comment">//调用func(int)</span></span><br><span class="line"><span class="comment">/************************</span></span><br><span class="line"><span class="comment">c++11之前， #define NULL 0</span></span><br><span class="line"><span class="comment">#define NULL ((void *)0)</span></span><br><span class="line"><span class="comment">*************************/</span></span><br><span class="line"><span class="built_in">func</span>(<span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">func</span>(<span class="literal">nullptr</span>);<span class="comment">//调用func(void*)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//nullptr定义</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(<span class="literal">nullptr</span>)</span> <span class="keyword">nullptr_t</span></span>;</span><br></pre></td></tr></table></figure><h3 id="Automatic-Type-Deduction"><a href="#Automatic-Type-Deduction" class="headerlink" title="Automatic Type Deduction"></a>Automatic Type Deduction</h3><p><code>auto</code>自动类型推断。在模板的应用中，我们已经知道编译器可以推导实参的类型，在此将此能力表现。</p><p>名称特别长懒得打字、类型复杂一时想不出时推荐使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">42</span>;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">auto</span> pos = vec.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">auto</span> tmp = [](<span class="keyword">int</span> x)-&gt;<span class="keyword">bool</span>&#123;&#125;;</span><br></pre></td></tr></table></figure><h3 id="Uniform-Initialization"><a href="#Uniform-Initialization" class="headerlink" title="Uniform Initialization"></a>Uniform Initialization</h3><p>一致性初始化。</p><p>在C++11之前，初始化可能会发生在<code>()、&#123;&#125;、=</code>操作中。程序员很容易困惑于：初始化变量、对象时怎么写？。基于此原因，导入<code>uniform initialization</code>。保证任何初始化都可以使用一种语法<code>&#123;&#125;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一致性初始化</span></span><br><span class="line"><span class="keyword">int</span> value&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">35</span>,<span class="number">4</span>&#125;;</span><br><span class="line">vector&lt;string&gt; vec&#123;<span class="string">&quot;asfg&quot;</span>,<span class="string">&quot;asgg&quot;</span>,<span class="string">&quot;ewgs&quot;</span>&#125;;</span><br><span class="line">complex&lt;<span class="keyword">double</span>&gt; comp&#123;<span class="number">4.0</span>,<span class="number">3.0</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="initializer-list"><a href="#initializer-list" class="headerlink" title="initializer_list"></a>initializer_list</h3><p>编译器看到<code>&#123;..&#125;</code>便生成<code>initializer_list&lt;T&gt;</code>，其内部关联到容器<code>array&lt;T,n&gt;</code>。调用构造函数时(初始化时调用的是构造函数<code>ctor</code>)，该<code>array</code>内的元素可被编译器分解，逐一传给函数。</p><ul><li><p>函数参数如果是<code>initializer_list&lt;T&gt;</code>，调用者不能传入多个<code>initializer_list&lt;T&gt;</code>。</p></li><li><p>可以利用<code>&#123;&#125;</code>来赋空值</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i&#123;&#125;; <span class="comment">// i == 0</span></span><br><span class="line"><span class="keyword">int</span>* ptr&#123;&#125;; <span class="comment">// ptr == nullptr</span></span><br></pre></td></tr></table></figure><ul><li>不推荐向低精度转化<code>int x&#123;5.0&#125;</code></li></ul><p>自定义函数时，如果想通过简单的方式来接收任意个数参数，可以使用<code>initializer_list</code>。</p><blockquote><p>比起<code>...</code>参数的类型比较严格。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(std::initializer_list&lt;<span class="keyword">int</span>&gt; vals)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p = vals.<span class="built_in">begin</span>();p!=vals.<span class="built_in">end</span>();p++) &#123;</span><br><span class="line">        std::cout &lt;&lt; *p &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="built_in">print</span>(&#123;<span class="number">12</span>,<span class="number">53</span>,<span class="number">26</span>,<span class="number">57</span>,<span class="number">14</span>&#125;);</span><br></pre></td></tr></table></figure><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">P</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">P</span>(<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;&#125;    <span class="comment">// func1</span></span><br><span class="line">    <span class="built_in">P</span>(initializer_list&lt;<span class="keyword">int</span>&gt; initlist)&#123;&#125; <span class="comment">// func2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//调用 </span></span><br><span class="line"><span class="function">P <span class="title">a</span><span class="params">(<span class="number">10</span>,<span class="number">20</span>)</span></span>; <span class="comment">//调用func1</span></span><br><span class="line">P b&#123;<span class="number">5</span>,<span class="number">7</span>&#125;;   <span class="comment">//func2</span></span><br><span class="line">P c&#123;<span class="number">2</span>,<span class="number">23</span>,<span class="number">62</span>&#125;;   <span class="comment">//func2</span></span><br><span class="line">P d=&#123;<span class="number">3</span>,<span class="number">5</span>&#125;;  <span class="comment">//func</span></span><br></pre></td></tr></table></figure><blockquote><p>上述样例中如果没有<code>func2</code>，则对象<code>b  d</code>仍会创建，调用<code>func1</code></p></blockquote><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">E</span>&gt;</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">initializer_list</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">typedef</span> _E        value_type;</span><br><span class="line">      <span class="keyword">typedef</span> <span class="keyword">const</span> _E&amp;     reference;</span><br><span class="line">      <span class="keyword">typedef</span> <span class="keyword">const</span> _E&amp;     const_reference;</span><br><span class="line">      <span class="keyword">typedef</span> <span class="keyword">size_t</span>        size_type;</span><br><span class="line">      <span class="keyword">typedef</span> <span class="keyword">const</span> _E*     iterator;</span><br><span class="line">      <span class="keyword">typedef</span> <span class="keyword">const</span> _E*     const_iterator;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">      iterator          _M_array;</span><br><span class="line">      size_type         _M_len;</span><br><span class="line">        <span class="comment">//编译器看到&#123;&#125;时会调用该私有构造</span></span><br><span class="line">      <span class="comment">// The compiler can call a private constructor.</span></span><br><span class="line">      <span class="function"><span class="keyword">constexpr</span> <span class="title">initializer_list</span><span class="params">(const_iterator __a, size_type __l)</span></span></span><br><span class="line"><span class="function">      : _M_array(__a), _M_len(__l) &#123;</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">constexpr</span> <span class="title">initializer_list</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">      : _M_array(<span class="number">0</span>), _M_len(<span class="number">0</span>) &#123;</span> &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Number of elements.</span></span><br><span class="line">      <span class="function"><span class="keyword">constexpr</span> size_type</span></span><br><span class="line"><span class="function">      <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> _M_len; &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// First element.</span></span><br><span class="line">      <span class="function"><span class="keyword">constexpr</span> const_iterator</span></span><br><span class="line"><span class="function">      <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> _M_array; &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// One past the last element.</span></span><br><span class="line">      <span class="function"><span class="keyword">constexpr</span> const_iterator</span></span><br><span class="line"><span class="function">      <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">begin</span>() + <span class="built_in">size</span>(); &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><blockquote><p>多个同类型的参数max/min通过initializer_list实现</p></blockquote><h3 id="Explicit"><a href="#Explicit" class="headerlink" title="Explicit"></a>Explicit</h3><p>作用于含有<strong>一个以上</strong>实参的构造函数，防止编译器进行隐式类型转换。</p><p>C++中<code>nonexplicit one argument ctor</code>才能做隐式转换。</p><h3 id="range-base-for"><a href="#range-base-for" class="headerlink" title="range-base for"></a>range-base <code>for</code></h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>-loop`本来的格式有三段，现可以简化为两段`<span class="keyword">for</span>(decl : coll)</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;vec&#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">547</span>,<span class="number">47</span>,<span class="number">85</span>,<span class="number">373</span>,<span class="number">856</span>,<span class="number">86</span>&#125;;</span><br><span class="line"><span class="comment">//以前</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;vec.<span class="built_in">size</span>();++i) &#123; cout &lt;&lt;vec[i];&#125;</span><br><span class="line"><span class="comment">//现在</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; elem:vec)&#123;cout&lt;&lt;elem;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//源码</span></span><br><span class="line"><span class="keyword">for</span>(decl:coll)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> _pos=coll.<span class="built_in">begin</span>();_pos !=coll.<span class="built_in">end</span>();++_pos)&#123;decl = *_pos;&#125;</span><br></pre></td></tr></table></figure><h3 id="default-delete"><a href="#default-delete" class="headerlink" title="=default/=delete"></a>=default/=delete</h3><p>如果有定义构造函数(ctor)，则编译器不会再提供默认构造函数(default ctor)，如果强制加上<code>=default</code>，可以重新获得并使用<code>default ctor</code>。主要用于构造函数、拷贝构造、拷贝赋值、析构函数（不写的话，编译器会自动增加的函数）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zoo</span>&#123;</span></span><br><span class="line">    <span class="built_in">Zoo</span>(<span class="keyword">const</span> Zoo&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">Zoo</span>(Zoo&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    Zoo&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Zoo&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    Zoo&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Zoo&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>=delete</code>禁用成员函数的使用。删除特殊成员函数提供了一种更简洁的方法来防止编译器生成我们不想要的特殊成员函数。</p><h3 id="Alias-Template"><a href="#Alias-Template" class="headerlink" title="Alias Template"></a>Alias Template</h3><p>模板别名。在专门化别名模板时生成的类型不允许直接或间接地使用其自己的类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;T&gt;</span><br><span class="line"><span class="keyword">using</span> Vec = std::vector&lt;T,MyAlloc&lt;T&gt;&gt;;</span><br><span class="line">Vec&lt;<span class="keyword">int</span>&gt; coll;</span><br></pre></td></tr></table></figure><blockquote><p><code>#define</code> <code>typedef</code>无法达到相同效果。<br><code>#define</code>会改变模板中的参数，从而形成类似于偏特化的东西<br><code>typedef</code>不接收参数，也无法达到预期效果。</p></blockquote><h3 id="template-template-parameter"><a href="#template-template-parameter" class="headerlink" title="template template parameter"></a>template template parameter</h3><p>模板模板参数则是模板的参数又是一个模板，如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt; <span class="keyword">typename</span> Container&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XCls</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Container&lt;T&gt; c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//调用 tmp为一个模板类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tmp</span>&#123;</span>&#125;;</span><br><span class="line">XCls&lt;std::string, Tmp&gt; test1;</span><br><span class="line"><span class="comment">//调用容器</span></span><br><span class="line">XCls&lt;string,vector&gt; test2; <span class="comment">//error</span></span><br><span class="line"><span class="comment">//由于vector会有第二参数（构造器），需要指定</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Vec = std::Vec&lt;T, std::allocator&lt;T&gt;&gt;;</span><br><span class="line">XCls&lt;string,Vec&gt; test2;</span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><blockquote><p>以下不为模板模板参数</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Sequence = list&lt;T&gt;&gt;</span><br><span class="line">class stack</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Sequence c;</span><br><span class="line">&#125;;</span><br><span class="line">stack&lt;<span class="keyword">int</span>, deque&lt;<span class="keyword">int</span>&gt;&gt; s2;</span><br></pre></td></tr></table></figure><p>这里是容器指定底层容器，虽然使用了模板参数，但两个参数一旦指定前一个，后一个随之确定。</p><p>而模板模板参数两个参数之间没有任何关系。</p><h3 id="Type-Alias"><a href="#Type-Alias" class="headerlink" title="Type Alias"></a>Type Alias</h3><p>类型别名，类似于<code>typedef</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*func)</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>; <span class="comment">//参数为int,int返回值为void的函数指针</span></span><br><span class="line"><span class="keyword">using</span> func = <span class="built_in"><span class="keyword">void</span></span>(*)(<span class="keyword">int</span>,<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要注意 = 左侧为重命名后的</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tmp</span>&#123;</span></span><br><span class="line">    <span class="keyword">using</span> value_type = T;</span><br><span class="line">    <span class="comment">//typedef T value_type;</span></span><br><span class="line">&#125;;</span><br><span class="line">Tmp::value_type xxx; </span><br></pre></td></tr></table></figure><h4 id="using"><a href="#using" class="headerlink" title="using"></a>using</h4><ol><li>using-directives 命名空间（<code>using namespace std</code>）、using-declarations 某个函数(<code>using std::function</code>)</li><li>using-declarations成员函数(using _Class::xxx)功能同上</li><li>type alias 、alias template去替换</li></ol><h4 id="noexcept"><a href="#noexcept" class="headerlink" title="noexcept"></a>noexcept</h4><p>不抛出异常。C++中的异常处理是在运行时而不是编译时检测的。为了实现运行时检测，编译器创建额外的代码，然而这会妨碍程序优化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="literal">true</span>)</span></span>;<span class="comment">//满足条件时不抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;<span class="comment">//一定不抛出异常</span></span><br></pre></td></tr></table></figure><h3 id="override"><a href="#override" class="headerlink" title="override"></a>override</h3><p>重写。子类在想要重写父类的虚函数时，声明为<code>override</code>（防止子类写错，不是重写虚函数则报错）可以显式的在派生类中声明，哪些成员函数需要被重写，如果没被重写，则编译器会报错。如果不小心漏写了虚函数重写的某个苛刻条件，也可通过编译器的报错，快速定位错误</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> x)</span> <span class="keyword">override</span></span>;<span class="comment">//error 非重写</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;　　</span><br></pre></td></tr></table></figure><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>用于修饰类、成员变量和成员函数。</p><ul><li>final修饰的类，不能被继承，其中所有的函数都不能被重写。</li><li>final修饰的成员函数不能被重写。</li><li>final修饰的变量不能更改。</li></ul><h3 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h3><p>类型自动推导</p><ul><li>用来声明返回值类型。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T1 x,T2 y)</span>-&gt;<span class="title">decltype</span><span class="params">(x+y)</span></span>; <span class="comment">//取决于T1 T2两个类的设计</span></span><br></pre></td></tr></table></figure><ul><li>函数模板设计中获取某对象类型</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T obj)</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="title">decltype</span><span class="params">(obj)</span>::iterator iType</span>;</span><br><span class="line">    <span class="comment">//防止编译不通过</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>获取<code>lambda</code>表达式的返回值的类型（用来声明）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> cmp = [](<span class="keyword">const</span> Person1&amp; p1,<span class="keyword">const</span> Person2&amp; p2)&#123;...&#125;;</span><br><span class="line"></span><br><span class="line">set&lt;Person,<span class="keyword">decltype</span>(cmp)&gt;<span class="built_in">Myset</span>(cmp);</span><br></pre></td></tr></table></figure><h3 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h3><p>无名仿函数。允许定义内联函数，用来当成参数、对象使用。是一组功能的定义，可以被定义在表达式里。</p><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[CaptureList] (ParamsList) <span class="keyword">mutable</span> exception-&gt; ReturnType &#123; FunctionBody &#125;</span><br></pre></td></tr></table></figure><ul><li><code>CaptureList</code>  —  捕获外部变量列表</li><li><code>ParamsList</code>  —  形参列表</li><li><code>mutable</code>  —  用来说明是否可以修改捕获的变量</li><li><code>exception</code>  —  异常设定</li><li><code>ReturnType</code>  —  返回类型</li><li><code>FunctionBody</code>  —  函数体</li></ul><h4 id="省略形式"><a href="#省略形式" class="headerlink" title="省略形式"></a>省略形式</h4><table><thead><tr><th>序号</th><th>格式</th></tr></thead><tbody><tr><td>1</td><td>[<code>CaptureList</code>] (<code>ParamsList</code>) -&gt; <code>ReturnType</code> {<code>FunctionBody</code>}</td></tr><tr><td>2</td><td>[<code>CaptureList</code>] (<code>ParamsList</code>) {<code>FunctionBody</code>}</td></tr><tr><td>3</td><td>[<code>CaptureList</code>] {<code>FunctionBody</code>}</td></tr></tbody></table><ul><li>格式1声明了<code>const</code>类型的表达式，这种类型的表达式<strong>不能修改</strong>捕获列表中的值。</li><li>格式2<strong>省略了返回值类型</strong>，但编译器可以<strong>根据以下规则推断</strong>出Lambda表达式的返回类型<ol><li>如果<code>FunctionBody</code>中<strong>存在</strong><code>return</code>语句，则该Lambda表达式的返回类型<strong>由</strong><code>return</code>语句的返回类型<strong>确定</strong>。</li><li>如果<code>FunctionBody</code>中<strong>没有</strong><code>return</code>语句，则返回值为<code>void</code>类型。</li></ol></li><li>格式3中省略了参数列表，类似普通函数中的无参函数。</li></ul><blockquote><p>参数详解</p></blockquote><h5 id="CaptureList"><a href="#CaptureList" class="headerlink" title="CaptureList"></a>CaptureList</h5><p> Lambda表达式与普通函数最大的区别是，除了可以使用参数以外，Lambda函数还可以通过捕获列表访问一些上下文中的数据。</p><ul><li>[]、[var]、[&amp;var]表示不捕获、值传递、引用传递</li><li>[=]表示<strong>值传递</strong>方式捕获<strong>所有</strong>父作用域的变量</li><li>[&amp;]表示<strong>引用传递</strong>方式捕捉<strong>所有</strong>父作用域的变量</li></ul><h5 id="ParamsList"><a href="#ParamsList" class="headerlink" title="ParamsList"></a>ParamsList</h5><p> 除了捕获列表之外，lambda还可以接受输入参数。参数列表是<strong>可选</strong>的。</p><h5 id="mutable"><a href="#mutable" class="headerlink" title="mutable"></a>mutable</h5><p>mutable<strong>修饰符</strong>， 默认情况下Lambda函数总是一个<code>const</code>函数，<code>mutable</code>可以取消其常量性。</p><blockquote><p>在使用该修饰符时，参数列表不可省略。</p></blockquote><h5 id="exception"><a href="#exception" class="headerlink" title="exception"></a>exception</h5><p>指示 Lambda 表达式不会引发任何异常。</p><h5 id="ReturnType"><a href="#ReturnType" class="headerlink" title="ReturnType"></a>ReturnType</h5><p>返回类型会<strong>自动推导</strong></p><h5 id="FunctionBody"><a href="#FunctionBody" class="headerlink" title="FunctionBody"></a>FunctionBody</h5><p>可以包含普通方法或函数的主体可以包含的任何内容。</p><h4 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; myvec&#123; <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">2</span> &#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">lbvec</span><span class="params">(myvec)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//仿函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  a &lt; b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(myvec.<span class="built_in">begin</span>(), myvec.<span class="built_in">end</span>(), cmp); </span><br><span class="line"></span><br><span class="line"><span class="comment">// Lambda表达式</span></span><br><span class="line"><span class="built_in">sort</span>(lbvec.<span class="built_in">begin</span>(), lbvec.<span class="built_in">end</span>(), [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">bool</span> &#123; <span class="keyword">return</span> a &lt; b; &#125;);   </span><br><span class="line"></span><br><span class="line"><span class="comment">//特例</span></span><br><span class="line"><span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> func = [id]()<span class="keyword">mutable</span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;id = &quot;</span>&lt;&lt; id &lt;&lt; endl;</span><br><span class="line">    ++id;<span class="comment">//如果没有mutable id不可更改</span></span><br><span class="line">&#125;</span><br><span class="line">id = <span class="number">200</span>;</span><br><span class="line"><span class="built_in">func</span>();</span><br><span class="line"><span class="built_in">func</span>();</span><br><span class="line"><span class="built_in">func</span>();</span><br><span class="line">cout &lt;&lt;<span class="string">&quot;id = &quot;</span> &lt;&lt; id&lt;&lt; endl;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">200</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="Rvalue-reference"><a href="#Rvalue-reference" class="headerlink" title="Rvalue reference"></a>Rvalue reference</h3><p>右值引用。</p><p>通俗来说，可以取地址、有名字的为左值。（在内存中有实际地址的值、可以出现在赋值左侧的值）</p><p>右值引用就是对一个右值进行引用的类型。左值引用就是对一个左值进行引用的类型。</p><p>为了解决非必要的拷贝。当赋值的右侧为一个右值时，左侧可以在右侧偷出值，而不需要调用构造器。</p><h4 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h4><p>左值引用包括常量左值引用和非常量左值引用。非常量左值引用只能接受左值，不能接受右值；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;a = <span class="number">2</span>;       <span class="comment">// 非常量左值引用 绑定到 右值，编译失败</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;        <span class="comment">// b 是非常量左值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;c = b; <span class="comment">// 常量左值引用 绑定到 非常量左值，编译通过</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> d = <span class="number">2</span>;  <span class="comment">// d 是常量左值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;e = d; <span class="comment">// 常量左值引用 绑定到 常量左值，编译通过</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;f =<span class="number">2</span>;  <span class="comment">// 常量左值引用 绑定到 右值，编译通过</span></span><br></pre></td></tr></table></figure><h4 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h4><p>右值引用独立于左值和右值。即，右值引用类型的变量可能是左值也可能是右值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp;&amp; var1 = x;</span><br></pre></td></tr></table></figure><p>var1类型为右值引用，但var1本身是左值，因为具名变量都是左值。</p><p>T&amp;&amp; 并不一定表示右值，它绑定的类型是未定的，既可能是左值又可能是右值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">f</span>(<span class="number">10</span>); <span class="comment">//param是右值</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">f</span>(x); <span class="comment">//param是左值</span></span><br><span class="line"><span class="comment">/*****************</span></span><br><span class="line"><span class="comment">参数为右值10时</span></span><br><span class="line"><span class="comment">param 被一个右值初始化</span></span><br><span class="line"><span class="comment">那么 param 就是右值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当参数为左值 x 时</span></span><br><span class="line"><span class="comment">param 被一个左值初始化</span></span><br><span class="line"><span class="comment">那么 param 就是一个左值</span></span><br><span class="line"><span class="comment">*****************/</span></span><br></pre></td></tr></table></figure><h4 id="std-move"><a href="#std-move" class="headerlink" title="std::move()"></a>std::move()</h4><p>该函数并不能移动任何东西，它唯一的功能是将一个左值强制转化为右值引用，继而可以通过右值引用使用该值，以用于移动语义。从实现上讲，std::move基本等同于一个类型转换<code>static_cast&lt;T&amp;&amp;&gt;(Lvalue);</code></p><h3 id="Perfect-forwarding"><a href="#Perfect-forwarding" class="headerlink" title="Perfect forwarding"></a>Perfect forwarding</h3><p><code>nonperfect forwarding</code>  —  当我们对一个右值调用函数时，右值会调用<code>move</code>函数，然后调用函数时调用相应的左指的函数。此时即为一个不完美的交付</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>&amp; i)</span></span>&#123; cout&lt;&lt;<span class="string">&quot;process(&amp;)&quot;</span>&lt;&lt;i&lt;&lt;endl;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>&amp;&amp; i)</span></span>&#123; cout&lt;&lt;<span class="string">&quot;process(&amp;&amp;)&quot;</span>&lt;&lt;i&lt;&lt;endl;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forward</span><span class="params">(<span class="keyword">int</span>&amp;&amp; i)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;forward(&amp;&amp;)&quot;</span>&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">process</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">forward(<span class="number">2</span>);</span><br><span class="line"><span class="comment">/*************</span></span><br><span class="line"><span class="comment">首先2是右值 调用相应函数</span></span><br><span class="line"><span class="comment">调用之后在forward(int &amp;&amp;)中</span></span><br><span class="line"><span class="comment">i变为一个左值，调用process(int &amp;)</span></span><br><span class="line"><span class="comment">而理想状态应该调用process(int &amp;&amp;)</span></span><br><span class="line"><span class="comment">故，为一个不完美的交付</span></span><br><span class="line"><span class="comment">**************/</span></span><br></pre></td></tr></table></figure><p>标准库中提供函数<code>std::foward</code>来实现完美的交付</p><h3 id="容器array"><a href="#容器array" class="headerlink" title="容器array"></a>容器array</h3><p>没有<code>ctor</code>，没有<code>dtor</code>。封装成类的数组。创建时指定大小，不可扩容。</p><h3 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h3><p>元组是将不同类型的元素打包到一个对象中使用，就像<code>pair</code>适用于成对的元素，但<code>tuple</code>可以泛化为任意数量的元素。相关函数如下</p><ul><li><code>tuple_size()</code>  —  获取元组中元素的个数</li><li><code>tuple_element()</code>  —  访问tuple中指定位置的元素</li><li><code>make_tuple()</code>  —  构造包含指定内容的元组</li><li><code>get&lt;index&gt;()</code>  —  获取元组中第index个元素</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">tuple&lt;<span class="keyword">int</span>,<span class="keyword">double</span>,string&gt; <span class="title">temp</span><span class="params">(<span class="number">11</span>,<span class="number">42.2</span>,<span class="string">&quot;xxx&quot;</span>)</span></span>;<span class="comment">//手动建元组</span></span><br><span class="line">get&lt;id&gt;(temp);<span class="comment">//获取元组temp中的第id个元素</span></span><br><span class="line"><span class="keyword">auto</span> temp2 = <span class="built_in">make_tuple</span>(<span class="number">15</span>,<span class="number">41.3</span>,<span class="string">&quot;sss&quot;</span>);<span class="comment">//把括号里的一包xxx生成为tuple</span></span><br><span class="line">cout &lt;&lt;tuple_size&lt;<span class="keyword">decltype</span>(temp)&gt;::value;<span class="comment">//元组中元素个数 3</span></span><br><span class="line">cout &lt;&lt;tuple_element&lt;<span class="number">0</span>,<span class="keyword">decltype</span>(temp)&gt;::type;<span class="comment">//第0个元素</span></span><br><span class="line">cout &lt;&lt; temp &lt;&lt;endl;<span class="comment">//tuple可以直接cout</span></span><br><span class="line">get&lt;<span class="number">1</span>&gt;(temp) = get&lt;<span class="number">1</span>&gt;(temp2);<span class="comment">//取元素赋值</span></span><br><span class="line">temp = temp2;<span class="comment">//直接赋值</span></span><br><span class="line"><span class="keyword">int</span> myint;</span><br><span class="line"><span class="keyword">double</span> mydouble;</span><br><span class="line">string mystring;</span><br><span class="line"><span class="built_in">tie</span>(myint,mydouble,mystring) = temp;<span class="comment">//tie对应赋值</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> 候捷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>本文是学习李建忠「设计模式」课程所记录的笔记，由于<code>GitHub Page</code>图片加载过于缓慢，类图已移除。若要查看有类图的版本，请移步<a href="https://blog.csdn.net/weixin_46065476/article/details/126336516">CSDN</a>或<a href="https://github.com/ikun7355608/cpp_Design_Patterns">GitHub</a></p><span id="more"></span><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>设计模式目标  —  <strong>可复用</strong></p><p>设计模式假设条件  —  存在稳定点</p><p>设计模式真谛  —  编译时复用，运行时变化。</p><table><thead><tr><th align="center">思维方式</th><th align="center">作用</th><th align="center">内容</th></tr></thead><tbody><tr><td align="center">底层思维</td><td align="center">把握机器底层微观构造</td><td align="center">语言构造、编译转换、内存模型、运行机制</td></tr><tr><td align="center">抽象思维</td><td align="center">将现实世界抽象为程序代码</td><td align="center">面向对象、组件封装、设计模式、架构模式</td></tr></tbody></table><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><ul><li><p>向下</p><ul><li><p>封装  —  隐藏内部代码</p></li><li><p>继承  —  复用已有代码</p></li><li><p>多态  —  改写对象行为</p></li></ul></li></ul><ul><li><p>向上</p><ul><li>深刻把握面向对象机制带来的抽象意义，理解如何利用这些机制来表达现实世界。</li></ul></li></ul><h4 id="软件设计复杂原因"><a href="#软件设计复杂原因" class="headerlink" title="软件设计复杂原因"></a>软件设计复杂原因</h4><p>软件设计复杂性根本原因  —  <strong>变化</strong>（客户需求、技术平台、开发团队、市场）</p><h4 id="解决复杂性"><a href="#解决复杂性" class="headerlink" title="解决复杂性"></a>解决复杂性</h4><ul><li><p>分解  —  分而治之，大问题分解为多个小问题，复杂问题分解为多个简单问题(独立实现每个小类，分别实现相应的功能)</p></li><li><p>抽象  —  由于不能掌握全部复杂对象，选择忽视一些非本质的细节。而去处理泛化和理想化的对象模型。（抽象一个虚基类，每个具体小类继承并重写）</p></li></ul><h4 id="C-对象模型"><a href="#C-对象模型" class="headerlink" title="C++对象模型"></a>C++对象模型</h4><p>几乎所有的设计模式都采用类内部组合一个对象指针的形式（指针指向多态对象以解耦合）</p><h4 id="什么时候不用设计模式"><a href="#什么时候不用设计模式" class="headerlink" title="什么时候不用设计模式"></a>什么时候不用设计模式</h4><ul><li>代码可读性差</li><li>需求理解很浅</li><li>变化尚未显现</li><li>不是系统关键依赖点</li><li>项目无复用价值</li><li>项目将要发布</li></ul><h4 id="经验之谈"><a href="#经验之谈" class="headerlink" title="经验之谈"></a>经验之谈</h4><ul><li>不要为了模式而模式</li><li>关注抽象类和接口</li><li>理清变化点和稳定点</li><li>审视依赖关系</li><li>要有框架和应用的区隔思维</li><li>良好的设计是演化的结果</li></ul><h4 id="设计模式成长之路"><a href="#设计模式成长之路" class="headerlink" title="设计模式成长之路"></a>设计模式成长之路</h4><ol><li>「手中无剑，心中无剑」  —  见模式而不知</li><li>「手中有剑，心中无剑」  —  可以识别模式，作为应用开发人员使用模式</li><li>「手中有剑，心中有剑」  —  作为框架开发人员为应用设计模式</li><li>「手中无剑，心中有剑」  —  忘掉模式，只有原则</li></ol><h3 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h3><p>面向对象设计最大优势  —  <strong>抵御变化</strong></p><h4 id="面向对象-1"><a href="#面向对象-1" class="headerlink" title="面向对象"></a>面向对象</h4><ul><li>隔离变化  —  面向对象构建方式更能适应软件变化，能将变化带来的影响降到最小（宏观）</li><li>各司其职  —  需求变化导致的新增类型，不影响原来类型的实现（微观）</li></ul><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><ul><li>语言层面  —  对象封装了代码和数据</li><li>规格层面  —  对象定义了一系列接口</li><li>概念层面  —  对象是拥有某种责任的抽象</li></ul><h4 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h4><ol><li><p>依赖倒置原则(DIP)</p><ul><li><p>高层模块（稳定）不应该依赖于低层模块（变化），二者均依赖于抽象（稳定）。</p></li><li><p>抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于抽象（稳定）。</p></li></ul></li><li><p>开放封闭原则(OCP)</p><ul><li><p>对扩展开放，对更改封闭</p></li><li><p>类模块应该是可扩展的，但不可修改。</p></li></ul></li><li><p>单一职责原则(SRP)</p><ul><li>一个类应该仅有一个引起变化的原因</li><li>变化的方向隐含类的责任</li></ul></li><li><p>Liskov替换原则(LSP)</p><ul><li>子类必须能够替换基类（子类能调用父类方法）</li><li>继承表达类型抽象</li></ul></li><li><p>接口隔离原则(ISP)</p><ul><li>不应该强迫客户程序（使用者）依赖不用的方法</li><li>接口应该小而完备</li></ul></li><li><p>优先使用对象组合，而不是类继承</p><ul><li>类继承通常为「白盒复用」，对象组合通常为「黑盒复用」</li><li>继承在某种程度上破坏了封装性，耦合度高。而对象组合则要求被组合的对象具有良好定义的接口，耦合度低。</li></ul></li><li><p>封装变化点</p><ul><li>使用封装创建对象之间的分界层，让设计者可以在其一侧修改，不会对另一侧产生不良影响。实现层次间的松耦合</li></ul></li><li><p>针对接口编程，而非针对实现。</p><ul><li>不将变量类型声明为具体类，而是声明为接口。</li><li>客户程序无需知晓对象的具体类型，只需要知道所具有的接口。</li></ul></li></ol><p>产业强盛标志  —  <strong>接口标准化</strong></p><h4 id="设计经验"><a href="#设计经验" class="headerlink" title="设计经验"></a>设计经验</h4><p>由设计原则归纳、总结出的点</p><ol><li><p>设计习语(Design Idioms)  —  与特定编程语言相关的底层模式、技巧惯用法</p></li><li><p>设计模式(Design Patterns)  —  类与对象之间的组织关系，包括角色、职责、协作方式</p></li><li><p>架构模式(Architectural Patterns)  —  系统中与组织结构关系密切的高层模式，包括子系统划分、职责、组织关系。</p></li></ol><h3 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h3><p>23个设计模式的分类原则</p><ul><li><p>目的</p><ul><li><p>创建型  —  对象创建</p></li><li><p>结构型  —  对象需求变化对结构造成的冲击</p></li><li><p>行为型  —  多个类交互</p></li></ul></li><li><p>范围</p><ul><li>类模式  —  处理类与子类的静态关系（继承）</li><li>对象模式  —  对象间的动态关系（组合）</li></ul></li><li><p>封装变化</p><ul><li>组件协作  —  <code>Template Method、Strategy、Observer/Event</code></li><li>单一职责  —  <code>Decorator、Bridge</code></li><li>对象创建  —  <code>Factory Method、Abstract Factory、Prototype、Builder</code></li><li>对象性能  —  <code>Singleton、Flyweight</code></li><li>接口隔离  —  <code>Facade、Proxy、Mediator、Adapter</code></li><li>状态变化  —  <code>Memento、State</code></li><li>数据结构  —  <code>Composite、Iterator、Chain of Resposibility</code></li><li>行为变化  —  <code>Command、Visitor</code></li><li>领域问题  —  <code>Interpreter</code></li></ul></li></ul><blockquote><p>由于时代的发展，一些设计模式已不常用：<code>Builder、Mediator、Memento、Iterator、Chain of Resposibility、Command、Interpreter、Visitor</code></p></blockquote><h4 id="Refactoring-to-Patterns"><a href="#Refactoring-to-Patterns" class="headerlink" title="Refactoring to Patterns"></a>Refactoring to Patterns</h4><p><code>重构获得模式</code>是普遍认为最好的使用设计模式方法</p><ul><li>面向对象设计模式可以应对变化、提高复用。</li><li>现代软件设计特征  —  需求频繁变化。</li><li>设计模式的要点  —  寻找变化点（将稳定部分和变化不分分离开），变化点处使用设计模式来应对变化</li><li>设计模式的应用不该先入为主（防止误用）。没有一步到位的设计模式。（故，要<code>Refactoring to Patterns</code>）</li></ul><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ol><li>自主增加相应的模块</li><li>思考违背哪些设计原则</li><li>重构代码</li></ol><h5 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h5><ul><li>静态绑定$\to$动态绑定</li><li>早绑定$\to$晚绑定</li><li>继承$\to$组合</li><li>编译时依赖$\to$运行时依赖</li><li>紧耦合$\to$松耦合</li></ul><h2 id="GoF23"><a href="#GoF23" class="headerlink" title="GoF23"></a>GoF23</h2><h3 id="组件协作"><a href="#组件协作" class="headerlink" title="组件协作"></a>组件协作</h3><p>通过晚期绑定，实现<strong>框架与应用程序</strong>之间的松耦合。实现「框架与应用程序之间的划分」</p><h4 id="Template-Method"><a href="#Template-Method" class="headerlink" title="Template  Method"></a>Template  Method</h4><p>模板方法。定义一个操作中的算法的骨架（稳定），将一些步骤延迟（变化）到子类。使得子类可以不改变一个算法的结构（复用），同时重定义该算法的某些特定步骤。</p><h5 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h5><p>软件构造过程中，对于某项任务，有<strong>稳定</strong>的整体操作<strong>结构</strong>，但各个子步骤却有很多<strong>改变</strong>的需求；或者由于固有原因而无法和任务整体结构同时实现。</p><p>模板方法能够在<strong>稳定操作</strong>的前提下，灵活应对各个<strong>子步骤的变化</strong>及晚期实现需求。</p><h5 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h5><ul><li><code>Template  Method</code>是非常常用的基础设计模式，面向对象系统中大量使用。</li><li><code>Template  Method</code>机制简洁(虚函数的重载)，为许多应用程序架构提供了灵活扩展点，是代码复用层面的基本实现结构。</li><li><code>Template  Method</code>内含反向控制结构(<code>App</code>调用<code>Lib</code>中的方法 $\to$ <code>Lib</code>调用<code>App</code><strong>重写</strong>的方法)</li><li><code>Template  Method</code>调用的虚方法可以不做实现，但一般设计为<code>protected</code>方法。(流程中的一部分，不供外界调用)</li></ul><h5 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h5><p>基类（Lib）实现执行流程，关于具体细节部分（步骤的详情），通过相应的派生类（App）去重写。</p><blockquote><p>步骤的具体功能改变，不需要重写框架中的执行流程</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//库</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Library</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//具体执行流程（定）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">Step1</span>();</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Step2</span>()) &#123;</span><br><span class="line">            <span class="built_in">Step3</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Library</span>() &#123;...&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 定</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Step1</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Step3</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="comment">// 变</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Step2</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"> &#125;;</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span> :</span> <span class="keyword">public</span> Library &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Step2</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Library* pLib = <span class="keyword">new</span> <span class="built_in">Application</span>();</span><br><span class="line">    pLib-&gt;<span class="built_in">Run</span>();</span><br><span class="line">    <span class="keyword">delete</span> pLib;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Strategy"><a href="#Strategy" class="headerlink" title="Strategy"></a>Strategy</h4><p>策略模式。定义一系列算法，分别封装，并且使他们可以相互替换(<strong>变化</strong>)。该模式使得算法「独立」于使用他的客户程序(稳定)而变化。</p><h5 id="动机-1"><a href="#动机-1" class="headerlink" title="动机"></a>动机</h5><p>软件构造过程中，某些对象使用的<strong>算法多种多样</strong>，经常改变。如果将算法都编码到对象中，会使得对象异常复杂且冗余。</p><p>策略模式能够在运行时根据需求透明的更改对象的算法，将算法与对象解耦合。</p><h5 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h5><p>银行支持多个国家税额的计算。具体的支持国家会根据银行的发展改变。</p><blockquote><p>增加新的国家税额计算方式时（具体实现细节、客户程序），无需改变框架（算法）。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算策略 定</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaxStrategy</span>&#123;</span></span><br><span class="line">    TaxBase tax;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">CalculateTax</span><span class="params">(...)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">CalculateTax</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//具体国家的计算式 变</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CNTax</span> :</span> <span class="keyword">public</span> TaxStrategy &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">CalculateTax</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//订单类 需要计算的值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SalesOrder</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TaxStrategy* strategy;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//传入国家，新增</span></span><br><span class="line">    <span class="built_in">SalesOrder</span>(...) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;strategy = <span class="keyword">new</span> ...;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="要点-1"><a href="#要点-1" class="headerlink" title="要点"></a>要点</h5><ul><li><code>Strategy</code>及其子类为组件提供一系列可重用算法，使得运行时方便切换。</li><li><code>Strategy</code>提供了条件判断语句以外的选择，消除判断本身以解耦合。</li><li>如果<code>Strategy</code>对象不实例化，那么 各个上下文共享一个Strategy对象以节省开销。</li></ul><h4 id="Observer-Event"><a href="#Observer-Event" class="headerlink" title="Observer/Event"></a>Observer/Event</h4><p>观察者模式。定义一种对象间的<strong>一对多</strong>（变化）的依赖关系，以便当一个对象(Subject)的状态发生改变时，所有<strong>依赖它的对象</strong>都得到通知并<strong>自动更新</strong>。</p><h5 id="动机-2"><a href="#动机-2" class="headerlink" title="动机"></a>动机</h5><p>软件构造过程中，需要为某些对象创建一种“通知依赖关系”  —  一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）随之改变。若此依赖关系过于紧密，则软件不能很好的抵御变化。</p><p>观察者模式能够弱化这种依赖关系，形成稳定依赖关系、解耦合。</p><h5 id="样例-2"><a href="#样例-2" class="headerlink" title="样例"></a>样例</h5><p>文件分割器（U盘、移动硬盘太小装不下整个文件，要将文件划分为多个模块）中增加进度显示（变化，可能有多个细节方式实现。如：进度条、百分比）。</p><blockquote><p>分割的进度（主体对象）变化会引发进度显示（进度条、百分比）等观察者的变化。</p></blockquote><p>进度显示为一个用户反馈控件，抽象出相应的类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//框架--用户反馈机制</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IProgress</span>&#123;</span>  <span class="comment">//用户反馈</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DoProgress</span><span class="params">(<span class="keyword">float</span> value)</span></span>=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">IProgress</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSplitter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">string m_filePath;</span><br><span class="line"><span class="keyword">int</span> m_fileNumber;</span><br><span class="line">List&lt;IProgress*&gt;  m_iprogressList; <span class="comment">// 抽象反馈机制，支持多个观察者</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">FileSplitter</span>(<span class="keyword">const</span> string&amp; filePath, <span class="keyword">int</span> fileNumber) :</span><br><span class="line"><span class="built_in">m_filePath</span>(filePath), </span><br><span class="line"><span class="built_in">m_fileNumber</span>(fileNumber)&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//1.读取大文件</span></span><br><span class="line"><span class="comment">//2.分批次向小文件中写入</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_fileNumber; i++)&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">float</span> progressValue = m_fileNumber;</span><br><span class="line">progressValue = (i + <span class="number">1</span>) / progressValue;</span><br><span class="line"><span class="built_in">onProgress</span>(progressValue);<span class="comment">//反馈</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//增加/减少 反馈（观察者个数）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addIProgress</span><span class="params">(IProgress* iprogress)</span></span>&#123;</span><br><span class="line">m_iprogressList.<span class="built_in">push_back</span>(iprogress);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeIProgress</span><span class="params">(IProgress* iprogress)</span></span>&#123;</span><br><span class="line">m_iprogressList.<span class="built_in">remove</span>(iprogress);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onProgress</span><span class="params">(<span class="keyword">float</span> value)</span></span>&#123; <span class="comment">//反馈内容</span></span><br><span class="line">List&lt;IProgress*&gt;::iterator iter=m_iprogressList.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (iter != m_iprogressList.<span class="built_in">end</span>() )</span><br><span class="line">(*iter)-&gt;<span class="built_in">DoProgress</span>(value); <span class="comment">//更新进度条</span></span><br><span class="line">iter++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用框架</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainForm</span> :</span> <span class="keyword">public</span> Form, <span class="keyword">public</span> IProgress</span><br><span class="line">&#123;</span><br><span class="line">TextBox* txtFilePath;</span><br><span class="line">TextBox* txtFileNumber;</span><br><span class="line">ProgressBar* progressBar;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Button1_Click</span><span class="params">()</span></span>&#123;</span><br><span class="line">string filePath = txtFilePath-&gt;<span class="built_in">getText</span>();</span><br><span class="line"><span class="keyword">int</span> number = <span class="built_in">atoi</span>(txtFileNumber-&gt;<span class="built_in">getText</span>().<span class="built_in">c_str</span>());</span><br><span class="line">ConsoleNotifier cn;</span><br><span class="line"><span class="function">FileSplitter <span class="title">splitter</span><span class="params">(filePath, number)</span></span>;</span><br><span class="line">splitter.<span class="built_in">addIProgress</span>(<span class="keyword">this</span>); <span class="comment">//增加反馈 （观察者个数）</span></span><br><span class="line">splitter.<span class="built_in">addIProgress</span>(&amp;cn); <span class="comment">//增加反馈 （观察者个数）</span></span><br><span class="line">splitter.<span class="built_in">split</span>();</span><br><span class="line">splitter.<span class="built_in">removeIProgress</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DoProgress</span><span class="params">(<span class="keyword">float</span> value)</span></span>&#123;</span><br><span class="line">progressBar-&gt;<span class="built_in">setValue</span>(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsoleNotifier</span> :</span> <span class="keyword">public</span> IProgress &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DoProgress</span><span class="params">(<span class="keyword">float</span> value)</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;....&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="要点-2"><a href="#要点-2" class="headerlink" title="要点"></a>要点</h5><ul><li><code>Observer</code>使得我们可以<strong>独立地改变</strong>目标与观察者，从而使二者之间的依赖关系达致松耦合。</li><li>目标发送通知时，无需指定观察者，通知（可以携带通知信息作为参数）会<strong>自动传播</strong>。</li><li>观察者自己决定是否需要订阅通知，目标对象对此一无所知。</li><li><code>Observer</code>是基于事件的UI框架中非常常用的设计模式，也是MVC模式的一个重要组成部分。</li></ul><h3 id="单一职责"><a href="#单一职责" class="headerlink" title="单一职责"></a>单一职责</h3><p>如果责任划分不清晰，使用继承得到的结果往往是随着需求的变化，子类急剧膨胀，同时充斥着重复代码，这时往往需要划清责任。</p><h4 id="Decorator"><a href="#Decorator" class="headerlink" title="Decorator"></a>Decorator</h4><p>装饰模式。动态（<strong>组合</strong>）地给一个对象增加一些额外的职责。就增加功能而言，Decorator模式比生成子类（<strong>继承</strong>）更为灵活（消除重复代码、减少子类个数）</p><h5 id="动机-3"><a href="#动机-3" class="headerlink" title="动机"></a>动机</h5><p>在某些情况下我们可能会“过度地使用继承来扩展对象的功能”，由于继承为类型引入的静态特质，使得这种扩展方式缺乏灵活性；并且随着子类的增多（扩展功能的增多），各种子类的组合（扩展功能的组合）会导致更多子类的膨胀。</p><p>装饰模式能够使“对象功能的扩展”根据需要来动态实现，避免子类膨胀，从而使得任何“功能扩展变化”所导致的影响降为最低。</p><h5 id="样例-3"><a href="#样例-3" class="headerlink" title="样例"></a>样例</h5><p>各个流(文件流、网络流、内存流)的库中存在着很多功能相同的模块。模块各自继承自相应的流，而功能相同。现，给各模块增加加密功能。</p><p><code>Crypto[File,Network,Memory]Stream::read/seek/write</code>$ \to $<code>CryptoStream::read/seek/write</code></p><ul><li><code>Crypto[File,Network,Memory]Stream::read/seek/write</code>  —  每个流中相应功能各自实现加密</li><li><code>CryptoStream</code>  —  脱离开具体流（避免了多次拷贝）</li></ul><blockquote><p>不同流中增加同一类似功能无需每个流均<strong>继承</strong>一份，单独封装后每个流在使用时，通过组合引入即可。 </p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//业务操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stream</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Stream</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主体类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileStream</span>:</span> <span class="keyword">public</span> Stream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span></span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkStream</span> :</span><span class="keyword">public</span> Stream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span></span>&#123;...&#125;    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemoryStream</span> :</span><span class="keyword">public</span> Stream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span></span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩展操作</span></span><br><span class="line"><span class="comment">// 由于两个子类有相同的成员Stream*，所以这个成员要往上提</span></span><br><span class="line">DecoratorStream: <span class="keyword">public</span> Stream&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Stream* stream;<span class="comment">//复合</span></span><br><span class="line">    <span class="built_in">DecoratorStream</span>(Stream * stm):<span class="built_in">stream</span>(stm)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CryptoStream</span>:</span> <span class="keyword">public</span> DecoratorStream &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CryptoStream</span>(Stream* stm):<span class="built_in">DecoratorStream</span>(stm)&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        stream-&gt;<span class="built_in">Read</span>(number);<span class="comment">//读XX流  XX为文件 | 网络 | 内存</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        stream::<span class="built_in">Seek</span>(position);<span class="comment">//定位XX流</span></span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(byte data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        stream::<span class="built_in">Write</span>(data);<span class="comment">//写XX流</span></span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Process</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//运行时装配</span></span><br><span class="line">    FileStream* s1=<span class="keyword">new</span> <span class="built_in">FileStream</span>();</span><br><span class="line">    CryptoStream* s2=<span class="keyword">new</span> <span class="built_in">CryptoStream</span>(s1); <span class="comment">//CryptoFileStream</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="要点-3"><a href="#要点-3" class="headerlink" title="要点"></a>要点</h5><ul><li><p>通过采用组合而非继承的手法， <code>Decorator</code>实现了在<strong>运行时</strong>动态扩展对象功能的能力，而且可以根据需要扩展多个功能。<br>避免了使用继承带来的“灵活性差”和“多子类衍生问题”。</p></li><li><p>Decorator类在<strong>接口上表现为is-a</strong> Component的继承关系（Decorator类继承了Component类所具有的接口），但在<strong>实现上又表现为has-a</strong> Component的组合关系（Decorator类又使用了一个Component类）</p><blockquote><p>继承  —  完善接口的规范</p><p>组合  —  支撑具体实现类</p></blockquote></li><li><p>Decorator模式的目的并非解决“多子类衍生的多继承”问题，Decorator模式应用的<strong>要点</strong>在于解决<strong style="color:#c04851;">「主体类在多个方向上的扩展功能」</strong>——是为“装饰”的含义。</p></li></ul><h4 id="Bridge"><a href="#Bridge" class="headerlink" title="Bridge"></a>Bridge</h4><p>桥模式。将抽象部分(<strong>业务功能</strong>)与实现部分(<strong>平台实现</strong>)<strong>分离</strong>，使它们都可以独立地变化。</p><h5 id="动机-4"><a href="#动机-4" class="headerlink" title="动机"></a>动机</h5><p>某些类型的固有的实现逻辑，使得它们具有两个变化的维度，乃至多个纬度的变化。</p><p>桥模式能够应对这种「多维度的变化」，轻松地沿着两个乃至多个方向变化，而不引入额外的复杂度。</p><h5 id="样例-4"><a href="#样例-4" class="headerlink" title="样例"></a>样例</h5><p>通信模块中，<code>Login  SendMessage  SendPicture  PlaySound  DrawShape  WriteText  Connect</code>等功能跨平台实现不太一样。平台中分为精简版、完美版。不同版本基本功能的实现是相似。</p><blockquote><p>原本这些功能存在平台、版本等多个维度的变化，实现时针对特定平台特定版本创建类<code>IOSLiteXXX</code>，导致代码过度冗余。<br>桥模式将平台、版本问题剥离（单一职责原则）。</p></blockquote> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">      Messager &quot;1&quot;-- &quot;m&quot; Platform</span><br><span class="line">      Platform &quot;1&quot;-- &quot;n&quot; Release </span><br></pre></td></tr></table></figure><blockquote><p>原来需要实现<code>1+m+m*n</code>个类（1通信模块+扩展m个平台+每个平台n个发布版本）</p><p>桥模式无需根据相应的平台推出对应版本(<code>1+m+n</code>个类)。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Messager</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">     MessagerImp* messagerImp;<span class="comment">//平台</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Login</span><span class="params">(string username, string password)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Messager</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 不同的变化方向(业务和平台)，所以分为两个类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessagerImp</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PlaySound</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DrawShape</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">WriteText</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Connect</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">MessagerImp</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//平台实现 n</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PCMessagerImp</span> :</span> <span class="keyword">public</span> MessagerImp&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PlaySound</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DrawShape</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">WriteText</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Connect</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MobileMessagerImp</span> :</span> <span class="keyword">public</span> MessagerImp&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//具体实现</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PlaySound</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DrawShape</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">WriteText</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Connect</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//业务抽象 m</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessagerLite</span> :</span><span class="keyword">public</span> Messager &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Login</span><span class="params">(string username, string password)</span></span>&#123;</span><br><span class="line">        messagerImp-&gt;<span class="built_in">Connect</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span></span>&#123;</span><br><span class="line">        messagerImp-&gt;<span class="built_in">WriteText</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>&#123;</span><br><span class="line">        messagerImp-&gt;<span class="built_in">DrawShape</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessagerPerfect</span>  :</span><span class="keyword">public</span> Messager &#123; </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Login</span><span class="params">(string username, string password)</span></span>&#123;</span><br><span class="line">        messagerImp-&gt;<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        messagerImp-&gt;<span class="built_in">Connect</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span></span>&#123;</span><br><span class="line">        messagerImp-&gt;<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        messagerImp-&gt;<span class="built_in">WriteText</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>&#123;</span><br><span class="line">        messagerImp-&gt;<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        messagerImp-&gt;<span class="built_in">DrawShape</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Process</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//运行时装配</span></span><br><span class="line">    MessagerImp* mImp=<span class="keyword">new</span> <span class="built_in">PCMessagerImp</span>();</span><br><span class="line">    Messager *m =<span class="keyword">new</span> <span class="built_in">Messager</span>(mImp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="要点-4"><a href="#要点-4" class="headerlink" title="要点"></a>要点</h5><ul><li><code>Bridge</code>使用「<strong>对象间的组合关系</strong>」解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自纬度的变化，即“子类化”它们。</li><li><code>Bridge</code>有时候类似于多继承方案，但是多继承方案往往违背单一职责原则（即一个类只有一个变化的原因），复用性比较差。Bridge模式是比多继承方案更好的解决方法。</li><li><code>Bridge</code>的应用一般在「两个非常强的变化维度」，有时一个类也有多于两个的变化维度，这时可以使用Bridge的扩展模式。</li></ul><h3 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h3><p>通过「对象创建」，绕开<code>new</code>以避免<code>new</code>过程所导致的紧耦合（依赖于具体类），从而支持对象创建的稳定。「对象创建」是接口抽象后的第一步工作。</p><h4 id="Factory-Method"><a href="#Factory-Method" class="headerlink" title="Factory Method"></a>Factory Method</h4><p>工厂方法。定义一个用于创建对象的接口，让子类决定实例化哪一个类。<code>Factory Method</code>使得一个类的实例化延迟到子类。（目的  —  解耦合，手段  —  虚函数）</p><h5 id="动机-5"><a href="#动机-5" class="headerlink" title="动机"></a>动机</h5><p>在软件系统中，经常面临着创建对象的工作；由于需求的变化，需要创建的对象的具体类型经常变化。</p><p>工厂方法能够<strong>绕过</strong>new创建对象（<strong>具体实现类</strong>），提供一种“封装机制”来避免客户程序和“具体对象创建工作”的紧耦合。</p><h5 id="样例-5"><a href="#样例-5" class="headerlink" title="样例"></a>样例</h5><p>分割器不局限于文本分割器，还包括图片、视频、文本等多个分割器。实例化对象创建时不受限于具体某种分割器（具体工厂）。</p><blockquote><p>工厂模式提供了基类使得多个具体类的实例化代码统一。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ISplitter</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ISplitter</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//工厂基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SplitterFactory</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">CreateSplitter</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">SplitterFactory</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//具体类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySplitter</span> :</span> <span class="keyword">public</span> ISplitter&#123;...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TxtSplitter</span>:</span> <span class="keyword">public</span> ISplitter&#123;...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PictureSplitter</span>:</span> <span class="keyword">public</span> ISplitter&#123;...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoSplitter</span>:</span> <span class="keyword">public</span> ISplitter&#123;...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySplitterFactory</span>:</span> <span class="keyword">public</span> SplitterFactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">CreateSplitter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">BinarySplitter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TxtSplitterFactory</span>:</span> <span class="keyword">public</span> SplitterFactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">CreateSplitter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TxtSplitter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PictureSplitterFactory</span>:</span> <span class="keyword">public</span> SplitterFactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">CreateSplitter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">PictureSplitter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoSplitterFactory</span>:</span> <span class="keyword">public</span> SplitterFactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">CreateSplitter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">VideoSplitter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainForm</span> :</span> <span class="keyword">public</span> Form</span><br><span class="line">&#123;</span><br><span class="line">    SplitterFactory*  factory;<span class="comment">//工厂</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainForm</span>(SplitterFactory*  factory)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;factory=factory;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Button1_Click</span><span class="params">()</span></span>&#123;</span><br><span class="line">ISplitter * splitter = factory-&gt;<span class="built_in">CreateSplitter</span>(); <span class="comment">//多态new</span></span><br><span class="line">        splitter-&gt;<span class="built_in">split</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="要点-5"><a href="#要点-5" class="headerlink" title="要点"></a>要点</h5><ul><li><code>Factory Method</code>用于<strong>隔离</strong>类对象的<strong>使用者</strong>和<strong>具体类型</strong>之间的耦合关系。面对一个经常变化的具体类型，紧耦合关系(new)会导致软件的脆弱。</li><li><code>Factory Method</code>通过<strong>面向对象的手法</strong>(多态)，将所要创建的具体对象工作<strong style="color:red;">延迟</strong>到子类，从而实现一种<strong>扩展</strong>（<strong style="color:red;">而非更改</strong>）的策略，较好地解决了这种紧耦合关系。</li><li><code>Factory Method</code>解决「单个对象」的需求变化。缺点在于要求创建方法/参数相同。</li></ul><h4 id="Abstract-Factory"><a href="#Abstract-Factory" class="headerlink" title="Abstract Factory"></a>Abstract Factory</h4><p>抽象工厂。提供一个接口，让该接口负责创建一系列「相关或者相互依赖的对象」，无需指定它们具体的类。</p><h5 id="动机-6"><a href="#动机-6" class="headerlink" title="动机"></a>动机</h5><p>在软件系统中，经常面临着「一系列相互依赖的对象工作」；同时，由于需求的变化，往往存在更多系列对象的创建工作。</p><p>抽象工厂能够绕过new创建对象，提供一种“封装机制”来避免<strong>客户程序</strong>和这种「<strong>多系列具体对象创建工作</strong>」的紧耦合。</p><h5 id="样例-6"><a href="#样例-6" class="headerlink" title="样例"></a>样例</h5><p>数据库模块，支持多种数据库的<code>Connection  Command</code>等操作。区别于<code>Bridge</code>，该处的侧重点不在于<code>操作  数据库类型</code>这多维度的变化，而是侧重于「每个数据库类型的Command会调用同类型数据的Connection」（多系列对象）</p><blockquote><p>由于<code>XXXCommand</code>调用的<code>Connection</code>一定是<code>XXXConnection</code>，存在系列对象的相互依赖、相互作用。</p><p>抽象工厂模式将系列操作封装为一个工厂，保证多系列对象创建之间的相互依赖的同时，摆脱具体实现类。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据库访问有关的基类 产品基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDBConnection</span>&#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDBCommand</span>&#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDataReader</span>&#123;</span>...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象工厂 统一系列化对象（相互作用）  工厂基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDBFactory</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDBConnection* <span class="title">CreateDBConnection</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDBCommand* <span class="title">CreateDBCommand</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDataReader* <span class="title">CreateDataReader</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//支持SQL Server 具体产品实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqlConnection</span>:</span> <span class="keyword">public</span> IDBConnection&#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqlCommand</span>:</span> <span class="keyword">public</span> IDBCommand&#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqlDataReader</span>:</span> <span class="keyword">public</span> IDataReader&#123;...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体工厂实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqlDBFactory</span>:</span><span class="keyword">public</span> IDBFactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDBConnection* <span class="title">CreateDBConnection</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDBCommand* <span class="title">CreateDBCommand</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDataReader* <span class="title">CreateDataReader</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmployeeDAO</span>&#123;</span></span><br><span class="line">    IDBFactory* dbFactory;    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;EmployeeDO&gt; <span class="title">GetEmployees</span><span class="params">()</span></span>&#123;</span><br><span class="line">        IDBConnection* connection = dbFactory-&gt;<span class="built_in">CreateDBConnection</span>();</span><br><span class="line">        connection-&gt;<span class="built_in">ConnectionString</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">        IDBCommand* command =dbFactory-&gt;<span class="built_in">CreateDBCommand</span>();</span><br><span class="line">        command-&gt;<span class="built_in">CommandText</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">        command-&gt;<span class="built_in">SetConnection</span>(connection); <span class="comment">//关联性</span></span><br><span class="line">        IDBDataReader* reader = command-&gt;<span class="built_in">ExecuteReader</span>(); <span class="comment">//关联性</span></span><br><span class="line">        <span class="keyword">while</span> (reader-&gt;<span class="built_in">Read</span>())&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="要点-6"><a href="#要点-6" class="headerlink" title="要点"></a>要点</h5><ul><li>如果没有应对”多<strong>系列对象</strong>创建“的需求变化，则没有必要使用Abstract Factory模式，这时候使用简单的工厂即可。</li><li><strong>「系列对象」</strong>指的是在某一个特定系列的对象之间有<strong>相互依赖、相互作用</strong>的关系。不同系列的对象之间不能相互依赖。</li><li><code>Abstract Factory</code>模式主要在于应用「新系列」的需求变动(增加其他系列操作)。其缺点在与<strong>难以应对新对象</strong>的需求变动（在系列操作中更改）。</li></ul><h4 id="Prototype"><a href="#Prototype" class="headerlink" title="Prototype"></a>Prototype</h4><p>原型模式。使用原型实例（仅供克隆）指定创建对象的种类，然后通过拷贝这些原型来创建新的对象。</p><h5 id="动机-7"><a href="#动机-7" class="headerlink" title="动机"></a>动机</h5><p>在软件系统中，经常面临这“某些结构复杂的对象”的创建工作；由于需求的变化，这些对象<strong>经常面临着剧烈的变化</strong>，但是它们却拥有比较稳定一致的接口。</p><p>原型模式能够向客户程序(使用者)隔离出「易变对象」，从而使得依赖这些易变对象的客户程序不随着需求改变而改变。</p><h5 id="样例-7"><a href="#样例-7" class="headerlink" title="样例"></a>样例</h5><p>同工厂方法的背景</p><blockquote><p>对象比较复杂时，利用工厂方法初始化的对象不便于使用。借助已经处于某种状态的原型，克隆出处于理想状态（避免状态条件苛刻带来不必要的资源浪费）的对象。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainForm</span> :</span> <span class="keyword">public</span> Form</span><br><span class="line">&#123;</span><br><span class="line">    ISplitter*  prototype;<span class="comment">//原型对象</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainForm</span>(ISplitter*  prototype)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;prototype=prototype;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Button1_Click</span><span class="params">()</span></span>&#123;</span><br><span class="line">ISplitter * splitter=</span><br><span class="line">            prototype-&gt;<span class="built_in">clone</span>(); <span class="comment">//克隆原型</span></span><br><span class="line">        splitter-&gt;<span class="built_in">split</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象类 原型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ISplitter</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">clone</span><span class="params">()</span></span>=<span class="number">0</span>; <span class="comment">//通过克隆自己来创建对象</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ISplitter</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//具体类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySplitter</span> :</span> <span class="keyword">public</span> ISplitter&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">BinarySplitter</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoSplitter</span>:</span> <span class="keyword">public</span> ISplitter&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">VideoSplitter</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="要点-7"><a href="#要点-7" class="headerlink" title="要点"></a>要点</h5><ul><li><code>Prototype</code>模式同样用于<strong>隔离</strong>对象的<strong>使用者和具体类型</strong>(易变类)之间的耦合关系，它同样要求这些“易变类”拥有<strong>稳定的接口</strong>。(和工厂方法一样)</li><li><code>Prototype</code>模式对于“如何创建易变类的实体对象“采用<strong>「原型克隆」</strong>的方法来做，它使得我们可以非常灵活地动态创建「拥有某些稳定接口」的新对象——所需工作仅仅是注册一个新类的对象(即原型)，然后在任何需要的地方clone。</li><li><code>Prototype</code>模式中的Clone方法可以利用某些框架中的序列化来实现深拷贝。(c++用拷贝构造函数即可)</li></ul><h4 id="Builder"><a href="#Builder" class="headerlink" title="Builder"></a>Builder</h4><p>构建器。将一个复杂对象的<strong>构建</strong>与其表示相分离，使得<strong>同样的构建过程</strong>(稳定)可以<strong>创建不同的表示</strong>(变化)。</p><h5 id="动机-8"><a href="#动机-8" class="headerlink" title="动机"></a>动机</h5><p>在软件系统中，有时候面临着“一个<strong>复杂对象</strong>”的创建工作，其通常<strong>由各个部分的子对象</strong>用一定的算法<strong>构成</strong>；由于需求的变化，这个复杂对象的<strong>各个部分</strong>经常面临着剧烈的<strong>变化</strong>，但是将它们组合在一起的<strong>算法却相对稳定</strong>。</p><p>构建器提供一种<strong>封装机制</strong>来隔离出「复杂对象的各个部分」的变化，从而保持系统中的「稳定构建算法」不随着需求改变而改变。</p><blockquote><p><code>Builder</code>用于解决<strong>对象创建</strong>时的算法恒定，细节各异的问题。(构造函数调用虚函数不能实现多态)<br><br><code>Template Method</code>用于解决<strong>函数应用</strong>时的算法恒定，细节各异的问题。（成员函数可以调用虚函数实现多态）</p></blockquote><p>为什么构造函数调用虚函数不能实现多态？</p><blockquote><p>子类构造函数要先调用父类构造函数，虚函数实现重载靠的是动态绑定。<br>如果构造函数中的虚函数为动态绑定(多态)，则子类在构造时，子类的构造函数先调用父类构造函数，而此时父类构造函数不能调用子类的重载函数（子类还未创建，没有虚表。）</p></blockquote><h5 id="样例-8"><a href="#样例-8" class="headerlink" title="样例"></a>样例</h5><p>游戏里建房子，使用的材料各异，但构建的流程不变。</p><blockquote><p>由于构造函数的特殊性质，不能直接借助虚函数在构造函数中实现上述功能。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//抽象基类 需要的几个构造部分 (门、窗、桌子)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HouseBuilder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">House* <span class="title">GetResult</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pHouse;<span class="comment">//构造完返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">HouseBuilder</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    House* pHouse;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuildPart1</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuildPart2</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuildPart3</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuildPart4</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuildPart5</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StoneHouse</span>:</span> <span class="keyword">public</span> House&#123;...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StoneHouseBuilder</span>:</span> <span class="keyword">public</span> HouseBuilder&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//每部分构造的具体实现</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuildPart1</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuildPart2</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuildPart3</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuildPart4</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuildPart5</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//造房子</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HouseDirector</span>&#123;</span>   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    HouseBuilder* pHouseBuilder;</span><br><span class="line">    <span class="built_in">HouseDirector</span>(HouseBuilder* pHouseBuilder)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;pHouseBuilder=pHouseBuilder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">House* <span class="title">Construct</span><span class="params">()</span></span>&#123;<span class="comment">//分别构造每一部分</span></span><br><span class="line">        pHouseBuilder-&gt;<span class="built_in">BuildPart1</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">            pHouseBuilder-&gt;<span class="built_in">BuildPart2</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> flag=pHouseBuilder-&gt;<span class="built_in">BuildPart3</span>();</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            pHouseBuilder-&gt;<span class="built_in">BuildPart4</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        pHouseBuilder-&gt;<span class="built_in">BuildPart5</span>();</span><br><span class="line">        <span class="keyword">return</span> pHouseBuilder-&gt;<span class="built_in">GetResult</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="要点-8"><a href="#要点-8" class="headerlink" title="要点"></a>要点</h5><ul><li><code>Builder </code>模式主要用于“<strong>分步骤构建</strong>一个复杂的对象”。在这其中“分步骤”是一个<strong>稳定的算法</strong>，而复杂对象的<strong>各个部分</strong>则经常<strong>变化</strong>。</li><li>变化点在哪里，封装哪里—— <code>Builder</code>模式主要在于应对“复杂对象各个部分”的频繁需求变动。其缺点在于难以应对“分步骤构建算法”的需求变动。</li><li>在<code>Builder</code>模式中，要注意不同语言中构造器内<strong>调用虚函数的差别</strong>。</li></ul><h3 id="对象性能"><a href="#对象性能" class="headerlink" title="对象性能"></a>对象性能</h3><p>面向对象很好地解决了“抽象”的问题，但是必不可免地要付出一定的代价。对于通常情况来讲，面向对象的成本大都可以忽略不计。但是<strong>某些情况，面向对象所带来的成本必须谨慎处理</strong>。</p><h4 id="Singleton"><a href="#Singleton" class="headerlink" title="Singleton"></a>Singleton</h4><p>单件模式。保证一个<strong>类仅有一个实例</strong>，并<strong>提供</strong>一个该实例的<strong>全局访问点</strong>。</p><h5 id="动机-9"><a href="#动机-9" class="headerlink" title="动机"></a>动机</h5><p>在软件系统中，经常有这样一些<strong>特殊的类</strong>，必须保证它们在系统中<strong>只存在一个实例</strong>，才能确保它们的逻辑正确性、以及良好的效率。这应该是类设计者的责任，而不是使用者的责任。</p><p>单件模式可以绕过常规的构造器，提供一种机制来保证一个类只有一个实例。</p><h5 id="样例-9"><a href="#样例-9" class="headerlink" title="样例"></a>样例</h5><p>具体的单件创建方案的演变见代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:<span class="comment">//默认构造、拷贝构造不声明会自动生成</span></span><br><span class="line">    <span class="built_in">Singleton</span>();</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="keyword">const</span> Singleton&amp; other);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">static</span> Singleton* m_instance;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::m_instance=<span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程非安全版本（多线程不可用）</span></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//线程A判为true，但并未new，在等待执行</span></span><br><span class="line"><span class="comment">//此时线程B如果调用，则仍可以判为true</span></span><br><span class="line">    <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        m_instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程安全版本，但锁的代价过高</span></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Lock lock;</span><br><span class="line">    <span class="comment">//某线程判true则加锁</span></span><br><span class="line">    <span class="comment">//但，只有第一次创建时是写操作，大部分为读操作。</span></span><br><span class="line">    <span class="comment">//此后的多线程读时，浪费时间。</span></span><br><span class="line">    <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        m_instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//双检查锁，但由于内存读写reorder不安全</span></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//锁前检查，读操作可直接跳进锁流程</span></span><br><span class="line">    <span class="comment">//内存读写reorder会导致双检察锁失效</span></span><br><span class="line">    <span class="comment">//创建单例过程 1.分配内存2.调用构造器3.返回赋值</span></span><br><span class="line">    <span class="comment">//编译器针对对象创建优化时会打乱上述流程（跳过2进入3）</span></span><br><span class="line">    <span class="comment">//如果此时再来一个线程能读取到单例已创建并得到指针</span></span><br><span class="line">    <span class="comment">//但此时单例还未调用构造器，未初始化。调用会出错。</span></span><br><span class="line">    <span class="keyword">if</span>(m_instance==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        Lock lock;</span><br><span class="line">        <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            m_instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++ 11版本之后的跨平台实现 (volatile)</span></span><br><span class="line">std::atomic&lt;Singleton*&gt; Singleton::m_instance;</span><br><span class="line">std::mutex Singleton::m_mutex;</span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Singleton* tmp = m_instance.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">    std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_acquire);<span class="comment">//获取内存fence</span></span><br><span class="line">    <span class="keyword">if</span> (tmp == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;<span class="comment">//锁</span></span><br><span class="line">        tmp = m_instance.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">        <span class="keyword">if</span> (tmp == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            tmp = <span class="keyword">new</span> Singleton;</span><br><span class="line">            std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_release);<span class="comment">//释放内存fence</span></span><br><span class="line">            m_instance.<span class="built_in">store</span>(tmp, std::memory_order_relaxed);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="要点-9"><a href="#要点-9" class="headerlink" title="要点"></a>要点</h5><ul><li><code>Singleton</code>模式中的实例构造器可以设置为protected以允许子类派生。</li><li><code>Singleton</code>模式一般<strong>不支持拷贝构造函数和clone接口</strong>，因为这有可能导致多个对象实例，与Singleton模式的初衷违背。</li><li>实现<strong>多线程</strong>环境下安全的<code>Singleton</code>,需要注意对<strong>双检查锁</strong>的正确实现。</li></ul><h4 id="FlyWeight"><a href="#FlyWeight" class="headerlink" title="FlyWeight"></a>FlyWeight</h4><p>享元模式。运行<strong>共享</strong>技术有效地支持大量细粒度的对象。</p><h5 id="动机-10"><a href="#动机-10" class="headerlink" title="动机"></a>动机</h5><p>在软件系统采用纯粹对象方案的问题在于大量细粒度的对象会很快充斥在系统中，从而带来很高的运行时代价——主要指内存需求方面的代价。</p><p>享元模式能够避免大量细粒度对象问题的同时，让外部客户程序仍然能够透明地使用面向对象的方式来进行操作。</p><h5 id="样例-10"><a href="#样例-10" class="headerlink" title="样例"></a>样例</h5><p>创建一个对象池来支持共享。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Font</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//unique object key</span></span><br><span class="line">    string key;    </span><br><span class="line">    <span class="comment">//object state</span></span><br><span class="line">    <span class="comment">//....    </span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Font</span>(<span class="keyword">const</span> string&amp; key)&#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FontFactory</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    map&lt;string,Font* &gt; fontPool;    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Font* <span class="title">GetFont</span><span class="params">(<span class="keyword">const</span> string&amp; key)</span></span>&#123;</span><br><span class="line">        map&lt;string,Font*&gt;::iterator item=fontPool.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span>(item!=footPool.<span class="built_in">end</span>())&#123; <span class="comment">//池中存在则共享</span></span><br><span class="line">            <span class="keyword">return</span> fontPool[key];</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;<span class="comment">//没有则创建</span></span><br><span class="line">            Font* font = <span class="keyword">new</span> <span class="built_in">Font</span>(key);</span><br><span class="line">            fontPool[key]= font;</span><br><span class="line">            <span class="keyword">return</span> font;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="要点-10"><a href="#要点-10" class="headerlink" title="要点"></a>要点</h5><ul><li>面向对象很好地解决了抽象性的问题，但是作为一个运行在机器中的程序实体，我们需要考虑<strong>对象的代价问题</strong>。Flyweight主要解决面向对象的代价问题，一般不触及面向对象的抽象性问题。 </li><li>Flyweight采用<strong>对象共享</strong>的做法来降低系统中对象的<strong>个数</strong>，从而降低细粒度对象给系统带来的压力。在具体实现方面，要注意对象状态的处理（只读）。</li><li>对象的数量太大从而导致对象内存开销加大  —  数量大小需要根据具体应用情况进行评估，而不能凭空臆断。</li></ul><h3 id="接口隔离"><a href="#接口隔离" class="headerlink" title="接口隔离"></a>接口隔离</h3><p>在组件构建过程中，某些<strong>接口之间直接的依赖常常会带来很多问题、甚至根本无法实现</strong>。采用<strong>添加一层间接（稳定）接口</strong>，来<strong>隔离本来互相紧密关联的接口</strong>是一种常见的解决方案。</p><blockquote><p>Facade 系统内外隔离（外对内，单向依赖）</p><p>Proxy 一些特殊原因，隔离实际对象，间接访问</p><p>Adapter 旧接口与需求不太匹配，用旧接口生成新接口</p><p>Mediator 隔离多个对象间的相互交互</p></blockquote><h4 id="Facade"><a href="#Facade" class="headerlink" title="Façade"></a>Façade</h4><p>门面模式。为子系统中的一组接口提供一个一致(稳定)的界面，Façade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用(复用)。</p><h5 id="动机-11"><a href="#动机-11" class="headerlink" title="动机"></a>动机</h5><p>组件的客户和组件中各种复杂的子系统有了过多的耦合，随着外部客户程序和各子系统的演化，这种过多的耦合面临很多变化的挑战。</p><p>门面模式能够简化外部客户程序和系统间的交互接口，解耦合。</p><p>由于门面模式是用于边界划分，用稳定的接口隔离变化体。内外情况多变，无特定类图。</p><h5 id="样例-11"><a href="#样例-11" class="headerlink" title="样例"></a>样例</h5><p>将多个对外接口封装在Facade中(稳定的提供接口的间接层)，将客户和子系统解耦合。</p><h5 id="要点-11"><a href="#要点-11" class="headerlink" title="要点"></a>要点</h5><ul><li>从客户程序角度来看，<code>Façade</code>模式<strong>简化</strong>了整个组件<strong>系统的接口</strong></li><li>对于组件内部与外部的客户程序来说，达到了一种”解耦“的效果  —  内部子系统的任何变化不会影响到<code>Façade</code>接口的变化。</li><li><code>Façade</code>设计模式更注重<strong>架构</strong>的层次去看整个系统，而不是单个类的层次。<code>Façade</code>很多时候是一种架构设计模式。</li><li><code>Façade</code>设计模式并非一个集装箱，不可以任意地放进任何多个对象。<code>Façade</code>模式组件中的内部应该是”相互耦合关系比较大的一系列组件“，而不是一个简单的功能集合。</li><li><code>Façade</code>实现松耦合，高内聚。(内部高内聚，对外松耦合)</li></ul><h4 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h4><p>代理模式。为其他对象提供一种代理以控制(<strong>隔离，使用接口</strong>)对这对象的访问。（核心在增加<strong>间接层</strong>）</p><h5 id="动机-12"><a href="#动机-12" class="headerlink" title="动机"></a>动机</h5><p>在面向对象系统中，有些对象由于某种原因(比如对象创建的开销很大，或者某些操作需要安全控制，或者需要进程外的访问等)，直接访问会给使用者、或者系统结构带来很多麻烦。</p><p>代理模式提供一个间接层在不失去透明操作对象(一致性)的同时来管理/控制这些对象特有的复杂性。</p><h5 id="样例-12"><a href="#样例-12" class="headerlink" title="样例"></a>样例</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ISubject</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//实际对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span>:</span> <span class="keyword">public</span> ISubject&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Proxy的设计</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubjectProxy</span>:</span> <span class="keyword">public</span> ISubject&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//对RealSubject的一种间接访问</span></span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientApp</span>&#123;</span></span><br><span class="line">    ISubject* subject;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ClientApp</span>()&#123;</span><br><span class="line">        subject=<span class="keyword">new</span> <span class="built_in">SubjectProxy</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoTask</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        subject-&gt;<span class="built_in">process</span>();</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="要点-12"><a href="#要点-12" class="headerlink" title="要点"></a>要点</h5><ul><li><p>「增加一层间接层」是软件系统中对许多复杂问题的一种常见解决方法。</p></li><li><p>在面向对象系统中，直接使用某些对象会带来很多问题，作为<strong>间接层的proxy对象</strong>便是解决这一问题的常用手段。</p></li><li><p>具体proxy设计模式的实现方法、实现粒度都相差很大。有些可能对单个对象做细粒度的控制（copy-on-write技术），有些可能对组件模块提供抽象代理层（在架构层次对对象做proxy）</p></li><li><p>Proxy并不一定要求保持接口完整的一致性，只要能够实现间接控制，有时候<strong>损及一些透明性是可以接受的</strong>。</p></li></ul><h4 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h4><p>适配器。将一个类的接口转换成客户希望的另一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><h5 id="动机-13"><a href="#动机-13" class="headerlink" title="动机"></a>动机</h5><p>由于应用环境的变化，常常需要将「一些现存的对象」放在新的环境中应用，但是新环境要求的接口是这些现存对象所不满足。</p><p>适配器能够应对这种「迁移的变化」，既能利用现有对象的良好实现，同时又能满足新的应用环境所要求的接口。</p><h5 id="样例-13"><a href="#样例-13" class="headerlink" title="样例"></a>样例</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//目标接口（新接口）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ITarget</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//遗留接口（老接口）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IAdaptee</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> data)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">bar</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//遗留类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OldClass</span>:</span> <span class="keyword">public</span> IAdaptee&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//对象适配器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span>:</span> <span class="keyword">public</span> ITarget&#123; <span class="comment">//继承</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    IAdaptee* pAdaptee;<span class="comment">//组合</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Adapter</span>(IAdaptee* pAdaptee)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;pAdaptee=pAdaptee;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> data=pAdaptee-&gt;<span class="built_in">bar</span>();</span><br><span class="line">        pAdaptee-&gt;<span class="built_in">foo</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类适配器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span>:</span> <span class="keyword">public</span> ITarget,</span><br><span class="line">               <span class="keyword">protected</span> OldClass&#123; <span class="comment">//多继承</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    IAdaptee* pAdaptee=<span class="keyword">new</span> <span class="built_in">OldClass</span>();</span><br><span class="line">    ITarget* pTarget=<span class="keyword">new</span> <span class="built_in">Adapter</span>(pAdaptee);</span><br><span class="line">    pTarget-&gt;<span class="built_in">process</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">stack</span>&#123;</span></span><br><span class="line">    deqeue container;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">queue</span>&#123;</span></span><br><span class="line">    deqeue container;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="要点-13"><a href="#要点-13" class="headerlink" title="要点"></a>要点</h5><ul><li>Adapter模式主要应用于「希望复用一些现存的类，但是接口又与复用环境要求不一致的情况」，在遗留代码复用、类库迁移等方面非常有用。</li><li><code>GoF23</code>定义了两种Adapter模式的实现结构：对象适配器和类适配器。但<strong>类适配器</strong>采用“<strong>多继承</strong>”的实现方式，一般<strong>不推荐</strong>使用。对象适配器采用“对象组合”的方式，更符合松耦合精神。</li><li>Adapter模式可以实现的非常灵活，不必拘泥于<code>GoF23</code>中定义的两种结构。例如，完全可以将Adapter模式中的“现存对象”作为新的接口方法参数，来达到适配的目的。</li></ul><h4 id="Mediator"><a href="#Mediator" class="headerlink" title="Mediator"></a>Mediator</h4><p>中介者。用一个中介对象来封装(封装变化)<strong>一系列的对象交互</strong>。中介者使各对象不需要显式的相互引用(编译时依赖-&gt;运行时依赖)，从而使其耦合松散(管理变化)，并且可以独立地改变它们之间的交互。（多对象间的依赖倒置原则）</p><h5 id="动机-14"><a href="#动机-14" class="headerlink" title="动机"></a>动机</h5><p><strong>多个对象相互关联</strong>的情况，对象之间常常会维持一种<strong>复杂的引用关系</strong>，如果遇到一些需求的更改，这种直接的引用关系将面临不断的变化。</p><p>中介者在这种情况下，可以使用一种”<strong>中介对象</strong>“来<strong>管理对象间的关联关系</strong>，避免相互交互的对象之间的紧耦合引用关系，从而更好地抵御变化。</p><h5 id="样例-14"><a href="#样例-14" class="headerlink" title="样例"></a>样例</h5><p>相互间存在依赖的五个对象<code>1  2  3  4  5</code>增加中介层<code>Mediator</code>从而使得对象间解耦合。</p><p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ExpMediator.png" alt="ExpMediator"></p><h5 id="要点-14"><a href="#要点-14" class="headerlink" title="要点"></a>要点</h5><ul><li>将多个对象间发杂的关联关系解耦。Mediator模式将多个对象间的控制逻辑进行集中管理，变「多个对象互相关联」为「多个对象和一个中介者关联」，简化了系统的维护，抵御了可能的变化。</li><li>随着控制逻辑的复杂化，Mediator具体对象的实现可能相当复杂。这时候可以对Mediator对象进行分解处理。</li><li>Facade模式是解耦<strong>系统间(单向)的对象</strong>关联关系；Mediator模式是解耦系统内**各个对象之间(双向)**的关联关系。</li></ul><h3 id="状态变化"><a href="#状态变化" class="headerlink" title="状态变化"></a>状态变化</h3><p>在组件构建过程中，某些对象的状态经常面临变化，如何对这些变化进行有效的管理？同时又维持高层模块的稳定？“状态变化”模式为这一问题提供了一种解决方案。</p><h4 id="State"><a href="#State" class="headerlink" title="State"></a>State</h4><p>状态模式。允许一个对象在其内部状态改变时改变它的行为。从而使对象看起来似乎修改了其行为。</p><h5 id="动机-15"><a href="#动机-15" class="headerlink" title="动机"></a>动机</h5><p>软件构建过程中，对象<strong>状态如果改变</strong>，其<strong>行为也会随之而发生变化</strong>，比如文档处于只读状态，其支持的行为和读写状态支持的行为就可能完全不同。</p><p>状态模式可以在运行时根据对象的状态来透明地改变对象的行为。</p><blockquote><p>Strategy与State可以理解为多种类型的if-else操作，如果用<code>枚举 + if-else</code>增加新的类型会更改源码，使用这两种模式可以在增加新类型时，仅在客户程序中增加相应的类重写相应的函数，而无需去更改流程操作。</p></blockquote><h5 id="样例-15"><a href="#样例-15" class="headerlink" title="样例"></a>样例</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkState</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NetworkState* pNext;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Operation1</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Operation2</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Operation3</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">NetworkState</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenState</span> :</span><span class="keyword">public</span> NetworkState&#123;</span><br><span class="line">    <span class="keyword">static</span> NetworkState* m_instance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> NetworkState* <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            m_instance = <span class="keyword">new</span> <span class="built_in">OpenState</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">        pNext = CloseState::<span class="built_in">getInstance</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//..........</span></span><br><span class="line">        pNext = ConnectState::<span class="built_in">getInstance</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//$$$$$$$$$$</span></span><br><span class="line">        pNext = OpenState::<span class="built_in">getInstance</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CloseState</span>:</span><span class="keyword">public</span> NetworkState&#123; &#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkProcessor</span>&#123;</span></span><br><span class="line">    NetworkState* pState;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NetworkProcessor</span>(NetworkState* pState)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;pState = pState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        pState-&gt;<span class="built_in">Operation1</span>();</span><br><span class="line">        pState = pState-&gt;pNext;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        pState-&gt;<span class="built_in">Operation2</span>();</span><br><span class="line">        pState = pState-&gt;pNext;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        pState-&gt;<span class="built_in">Operation3</span>();</span><br><span class="line">        pState = pState-&gt;pNext;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="要点-15"><a href="#要点-15" class="headerlink" title="要点"></a>要点</h5><ul><li>State模式将所有与一个特定状态相关的行为都放入一个State的子对象中，在对象状态切换时，切换相应的对象；但同时维持State的接口，这样实现了具体操作与状态转换之间的解耦。</li><li>为不同的状态引入不同的对象使得状态转换变得更加明确，而且可以保证不会出现状态不一致的情况。转换是原子性的(要么彻底转换过来，要么不转换。)</li><li>与Strategy模式类似，如果State对象没有实例变量，那么各个上下文可以共享同一个State对象，从而节省对象开销。（Singleton）</li></ul><h4 id="Memento"><a href="#Memento" class="headerlink" title="Memento"></a>Memento</h4><p>备忘录。在不破坏封装性的前提下，捕获一个对象的内部状态，并在该<strong>对象之外保存这个状态</strong>。这样以后就可以将该对象恢复到原先保存的状态。</p><h5 id="动机-16"><a href="#动机-16" class="headerlink" title="动机"></a>动机</h5><p>某些对象的状态转换过程中，可能由于某中需要，要求程序能够回溯到对象之前处于某个点的状态。如果使用一些公开接口来让其他对象得到对象的状态，便会暴露对象的细节实现。</p><p>备忘录能够实现对象状态的良好保存与恢复，同时又不会因此而破坏对象本身的封装性。</p><h5 id="样例-16"><a href="#样例-16" class="headerlink" title="样例"></a>样例</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//备忘录</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Memento</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    string state;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Memento</span>(<span class="keyword">const</span> string &amp; s) : <span class="built_in">state</span>(s) &#123;&#125;</span><br><span class="line">    <span class="function">string <span class="title">getState</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> state; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">const</span> string &amp; s)</span> </span>&#123; state = s; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//使用备忘录的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Originator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    string state;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Originator</span>() &#123;&#125;</span><br><span class="line">    <span class="function">Memento <span class="title">createMomento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">Memento <span class="title">m</span><span class="params">(state)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setMomento</span><span class="params">(<span class="keyword">const</span> Memento &amp; m)</span> </span>&#123;</span><br><span class="line">        state = m.<span class="built_in">getState</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Originator orginator;</span><br><span class="line">    <span class="comment">//捕获对象状态，存储到备忘录</span></span><br><span class="line">    Memento mem = orginator.<span class="built_in">createMomento</span>();</span><br><span class="line">    <span class="comment">//... 改变orginator状态</span></span><br><span class="line">    <span class="comment">//从备忘录中恢复</span></span><br><span class="line">    orginator.<span class="built_in">setMomento</span>(memento);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="要点-16"><a href="#要点-16" class="headerlink" title="要点"></a>要点</h5><ul><li>备忘录存储原发器对象的内部状态，在需要时恢复原发器状态。</li><li>Memento模式的核心是<strong>信息隐藏</strong>，即原发器需要向外接隐藏信息，保持其封装性，但同时又需要将状态保持到外界。</li><li>由于现代语言运行时(如C#、Java等)都具有相当的对象序列化支持，因此往往采用效率较高、又较容易正确实现的序列化方案来实现Memento模式。</li></ul><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>常常有一些组件在内部具有特定的数据结构，如果让客户程序依赖这些特定的数据结构，将极大地破坏组件的复用。</p><p>这时候，将这些特定数据结构封装在内部，在外部提供统一的接口，来实现与特定数据结构无关的访问，是一种行之有效的解决方案。</p><blockquote><p>Composite 树形结构</p><p>Iterator 在内部不可见的情况下，处理内部数据</p><p>Chain of Responsibility 链表结构</p></blockquote><h4 id="Composite"><a href="#Composite" class="headerlink" title="Composite"></a>Composite</h4><p>组合模式。将<strong>对象组合成树形结构</strong>以表示「部分-整体」的层次结构。</p><p>Composite使得用户对单个对象和组合对象的使用具有<strong>一致性</strong>(稳定)。</p><h5 id="动机-17"><a href="#动机-17" class="headerlink" title="动机"></a>动机</h5><p>客户代码过多地依赖于对象容器复杂的内部实现结构，对象容器内部实现结构(而非抽象结构)的变化引起客户代码的频繁变化，带来了代码的维护性、扩展性等弊端。</p><p>组合模式将「客户代码与复杂的对象容器结构」解耦，让对象容器自己来实现自身的复杂结构，从而使得客户代码就像处理简单对象一样来处理复杂的对象容器。</p><h5 id="样例-17"><a href="#样例-17" class="headerlink" title="样例"></a>样例</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Component</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Composite</span> :</span> <span class="keyword">public</span> Component&#123;</span><br><span class="line">    string name;</span><br><span class="line">    list&lt;Component*&gt; elements;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Composite</span>(<span class="keyword">const</span> string &amp; s) : <span class="built_in">name</span>(s) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Component* element)</span> </span>&#123;</span><br><span class="line">        elements.<span class="built_in">push_back</span>(element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component* element)</span></span>&#123;</span><br><span class="line">        elements.<span class="built_in">remove</span>(element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//1. process current node</span></span><br><span class="line">        <span class="comment">//2. process leaf nodes</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;e : elements)</span><br><span class="line">            e-&gt;<span class="built_in">process</span>(); <span class="comment">//多态调用</span></span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//叶子节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> :</span> <span class="keyword">public</span> Component&#123;</span><br><span class="line">    string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Leaf</span>(string s) : <span class="built_in">name</span>(s) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//process current node</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Invoke</span><span class="params">(Component &amp; c)</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    c.<span class="built_in">process</span>();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Composite <span class="title">root</span><span class="params">(<span class="string">&quot;root&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Composite <span class="title">treeNode1</span><span class="params">(<span class="string">&quot;treeNode1&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Composite <span class="title">treeNode2</span><span class="params">(<span class="string">&quot;treeNode2&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Composite <span class="title">treeNode3</span><span class="params">(<span class="string">&quot;treeNode3&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Composite <span class="title">treeNode4</span><span class="params">(<span class="string">&quot;treeNode4&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Leaf <span class="title">leat1</span><span class="params">(<span class="string">&quot;left1&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Leaf <span class="title">leat2</span><span class="params">(<span class="string">&quot;left2&quot;</span>)</span></span>;</span><br><span class="line">    root.<span class="built_in">add</span>(&amp;treeNode1);</span><br><span class="line">    treeNode1.<span class="built_in">add</span>(&amp;treeNode2);</span><br><span class="line">    treeNode2.<span class="built_in">add</span>(&amp;leaf1);</span><br><span class="line">    root.<span class="built_in">add</span>(&amp;treeNode3);</span><br><span class="line">    treeNode3.<span class="built_in">add</span>(&amp;treeNode4);</span><br><span class="line">    treeNode4.<span class="built_in">add</span>(&amp;leaf2);</span><br><span class="line">    <span class="built_in">process</span>(root);</span><br><span class="line">    <span class="built_in">process</span>(leaf2);</span><br><span class="line">    <span class="built_in">process</span>(treeNode3);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="要点-17"><a href="#要点-17" class="headerlink" title="要点"></a>要点</h5><ul><li>Composite模式采用<strong>树性结构</strong>来实现普遍存在的对象容器，从而<strong>将”一对多“的关系转化为”一对一“的关系</strong>（递归调用所有子节点），使得客户代码可以<strong>一致地</strong>(复用)<strong>处理对象和对象容器</strong>，无需关心处理的是单个的对象，还是组合的对象容器。</li><li>将「客户代码与复杂的对象容器结构」解耦是<code>Composite</code>的核心思想。</li><li>客户代码与纯粹的抽象接口（而非对象容器的内部实现结构）发生依赖，从而更能”应对变化“。</li><li>Composite模式在具体实现中，可以让父对象中的子对象反向追溯；如果父对象有频繁的遍历需求，可使用缓存技术来改善效率。</li></ul><h4 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h4><p>迭代器。提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露(稳定)该对象的内部表示。</p><h5 id="动机-18"><a href="#动机-18" class="headerlink" title="动机"></a>动机</h5><p>集合对象内部结构常常变化异常。但对于这些集合对象，我们希望<strong>不暴露其内部结构</strong>的同时，可以让<strong>外部客户代码透明地访问其中包含的元素</strong>；<br>同时这种”透明遍历“也为”同一种算法在多种集合对象上进行操作“提供了可能。</p><p>使用面向对象技术将这种遍历机制抽象为”迭代器对象“为”应对变化中的集合对象“提供了一种优雅的方式。</p><h5 id="样例-18"><a href="#样例-18" class="headerlink" title="样例"></a>样例</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Iterator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">isDone</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> T&amp; <span class="title">current</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCollection</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Iterator&lt;T&gt; <span class="title">GetIterator</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollectionIterator</span> :</span> <span class="keyword">public</span> Iterator&lt;T&gt;&#123;</span><br><span class="line">    MyCollection&lt;T&gt; mc;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CollectionIterator</span>(<span class="keyword">const</span> MyCollection&lt;T&gt; &amp; c): <span class="built_in">mc</span>(c)&#123; &#125;</span><br><span class="line">    <span class="comment">//虚函数根据具体类型去重载</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">first</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isDone</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function">T&amp; <span class="title">current</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyAlgorithm</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyCollection&lt;<span class="keyword">int</span>&gt; mc;</span><br><span class="line">    Iterator&lt;<span class="keyword">int</span>&gt; iter= mc.<span class="built_in">GetIterator</span>();</span><br><span class="line">    <span class="keyword">for</span> (iter.<span class="built_in">first</span>(); !iter.<span class="built_in">isDone</span>(); iter.<span class="built_in">next</span>())&#123;</span><br><span class="line">        cout &lt;&lt; iter.<span class="built_in">current</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="要点-18"><a href="#要点-18" class="headerlink" title="要点"></a>要点</h5><ul><li><p>迭代抽象：访问一个聚合对象的内容而无需暴露它的内部表示。</p></li><li><p>迭代多态：为遍历不同的集合对象提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作。。</p></li><li><p>迭代器的健壮性考虑：遍历的同时更改迭代器所在的集合结构，会导致问题。</p></li><li><p>对C++来说是过时的，面向对象的方式性能低，现在迭代器用模板。</p></li></ul><h4 id="Chain-of-Resposibility"><a href="#Chain-of-Resposibility" class="headerlink" title="Chain of Resposibility"></a>Chain of Resposibility</h4><p>职责链。使<strong>多个对象都有机会处理请求</strong>，从而避免请求的发送者和接收者之间的耦合关系。将这些对象<strong>连成一条链</strong>，并<strong>沿着这条链传递请求</strong>，直到有一个对象处理它为止。</p><h5 id="动机-19"><a href="#动机-19" class="headerlink" title="动机"></a>动机</h5><p>一个请求可能被多个对象处理，但是每个请求在运行时只能有一个接收者，如果显式指定，将必不可少地带来请求发送者与接收者的紧耦合。</p><p>职责链使请求的发送者<strong>不需要指定具体的接收者</strong>，让请求的接收者自己在运行时决定来处理请求，从而使两者解耦。</p><h5 id="样例-19"><a href="#样例-19" class="headerlink" title="样例"></a>样例</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">RequestType</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    REQ_HANDLER1,</span><br><span class="line">    REQ_HANDLER2,</span><br><span class="line">    REQ_HANDLER3</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//请求</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reqest</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    string description;</span><br><span class="line">    RequestType reqType;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Reqest</span>(<span class="keyword">const</span> string &amp; desc, RequestType type) : <span class="built_in">description</span>(desc), <span class="built_in">reqType</span>(type) &#123;&#125;</span><br><span class="line">    <span class="function">RequestType <span class="title">getReqType</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> reqType; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> string&amp; <span class="title">getDescription</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> description; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//接收者 基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChainHandler</span>&#123;</span></span><br><span class="line">    <span class="comment">//成链，多个对象接收。</span></span><br><span class="line">    ChainHandler *nextChain;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendReqestToNextHandler</span><span class="params">(<span class="keyword">const</span> Reqest &amp; req)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nextChain != <span class="literal">nullptr</span>)</span><br><span class="line">            nextChain-&gt;<span class="built_in">handle</span>(req);<span class="comment">//传递给下一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">canHandleRequest</span><span class="params">(<span class="keyword">const</span> Reqest &amp; req)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(<span class="keyword">const</span> Reqest &amp; req)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ChainHandler</span>() &#123; nextChain = <span class="literal">nullptr</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setNextChain</span><span class="params">(ChainHandler *next)</span> </span>&#123; nextChain = next; &#125;</span><br><span class="line">    <span class="comment">//处理请求链</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">const</span> Reqest &amp; req)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">canHandleRequest</span>(req))</span><br><span class="line">            <span class="built_in">processRequest</span>(req);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">sendReqestToNextHandler</span>(req);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler1</span> :</span> <span class="keyword">public</span> ChainHandler&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canHandleRequest</span><span class="params">(<span class="keyword">const</span> Reqest &amp; req)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> req.<span class="built_in">getReqType</span>() == RequestType::REQ_HANDLER1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(<span class="keyword">const</span> Reqest &amp; req)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Handler1 is handle reqest: &quot;</span> &lt;&lt; req.<span class="built_in">getDescription</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler2</span> :</span> <span class="keyword">public</span> ChainHandler&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canHandleRequest</span><span class="params">(<span class="keyword">const</span> Reqest &amp; req)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> req.<span class="built_in">getReqType</span>() == RequestType::REQ_HANDLER2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(<span class="keyword">const</span> Reqest &amp; req)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Handler2 is handle reqest: &quot;</span> &lt;&lt; req.<span class="built_in">getDescription</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler3</span> :</span> <span class="keyword">public</span> ChainHandler&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canHandleRequest</span><span class="params">(<span class="keyword">const</span> Reqest &amp; req)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> req.<span class="built_in">getReqType</span>() == RequestType::REQ_HANDLER3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(<span class="keyword">const</span> Reqest &amp; req)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Handler3 is handle reqest: &quot;</span> &lt;&lt; req.<span class="built_in">getDescription</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Handler1 h1;</span><br><span class="line">    Handler2 h2;</span><br><span class="line">    Handler3 h3;</span><br><span class="line">    h1.<span class="built_in">setNextChain</span>(&amp;h2);</span><br><span class="line">    h2.<span class="built_in">setNextChain</span>(&amp;h3);</span><br><span class="line">    </span><br><span class="line">    <span class="function">Reqest <span class="title">req</span><span class="params">(<span class="string">&quot;process task ... &quot;</span>, RequestType::REQ_HANDLER3)</span></span>;</span><br><span class="line">    h1.<span class="built_in">handle</span>(req);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="要点-19"><a href="#要点-19" class="headerlink" title="要点"></a>要点</h5><ul><li><code>Chain of Responsibility</code>模式的应用场合在于「一个请求<strong>可能有多个接受者</strong>，但是最后<strong>真正的接受者只有一个</strong>」，这时候请求发送者与接受者的耦合有可能出现“变化脆弱”的症状，职责链的目的就是将二者解耦，从而更好地应对变化。</li><li>应用了<code>Chain of Responsibility</code>模式后，对象的<strong>职责分派将更具灵活性</strong>。我们可以在<strong>运行时动态</strong>添加/修改请求的处理职责。</li><li>如果请求传递到职责链的末尾仍得不到处理，应该有一个合理的缺省机制。这也是每一个接受对象的责任，而不是发出请求的对象的责任。</li></ul><h3 id="行为变化"><a href="#行为变化" class="headerlink" title="行为变化"></a>行为变化</h3><p>在组件的构建过程中，组件行为的变化经常导致组件本身剧烈的变化。“行为变化”模式将<strong>组件的行为和组件本身进行解耦</strong>，从而支持组件行为的变化，实现两者之间的松耦合。</p><h4 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h4><p>命令模式。<strong>将</strong>一个<strong>请求(行为)封装成</strong>一个<strong>对象</strong>，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。</p><h5 id="动机-20"><a href="#动机-20" class="headerlink" title="动机"></a>动机</h5><p>”行为请求者“与”行为实现者“通常呈现一种”紧耦合“。但在某些场合（对行为进行”记录、撤销、事务“等处理）无法抵御变化的紧耦合是不合适的。</p><p>命令模式将”行为请求者“与”行为实现者“解耦。将一组行为抽象为对象，实现二者之间的松耦合。</p><h5 id="样例-20"><a href="#样例-20" class="headerlink" title="样例"></a>样例</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Command</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//行为对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand1</span> :</span> <span class="keyword">public</span> Command</span><br><span class="line">&#123;</span><br><span class="line">    string arg;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteCommand1</span>(<span class="keyword">const</span> string &amp; a) : <span class="built_in">arg</span>(a) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;#1 process...&quot;</span>&lt;&lt;arg&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand2</span> :</span> <span class="keyword">public</span> Command</span><br><span class="line">&#123;</span><br><span class="line">    string arg;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteCommand2</span>(<span class="keyword">const</span> string &amp; a) : <span class="built_in">arg</span>(a) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;#2 process...&quot;</span>&lt;&lt;arg&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MacroCommand</span> :</span> <span class="keyword">public</span> Command</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;Command*&gt; commands;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addCommand</span><span class="params">(Command *c)</span> </span>&#123; commands.<span class="built_in">push_back</span>(c); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : commands)</span><br><span class="line">        &#123;</span><br><span class="line">            c-&gt;<span class="built_in">execute</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ConcreteCommand1 <span class="title">command1</span><span class="params">(receiver, <span class="string">&quot;Arg ###&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">ConcreteCommand2 <span class="title">command2</span><span class="params">(receiver, <span class="string">&quot;Arg $$$&quot;</span>)</span></span>;</span><br><span class="line">    MacroCommand macro;</span><br><span class="line">    macro.<span class="built_in">addCommand</span>(&amp;command1);</span><br><span class="line">    macro.<span class="built_in">addCommand</span>(&amp;command2);</span><br><span class="line">    <span class="comment">//macro命令包含多个子命令</span></span><br><span class="line">    <span class="comment">//指令以对象的形式存在具备灵活性</span></span><br><span class="line">    macro.<span class="built_in">execute</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="要点-20"><a href="#要点-20" class="headerlink" title="要点"></a>要点</h5><ul><li>Command模式的根本目的在于将”行为请求者“与”行为实现者“解耦，在面向对象语言中，常见的实现手段是”将行为抽象为对象“。</li><li>实现Command接口的具体命令对象有时候根据需要可能会保存一些额外的状态信息。</li><li>通过使用Composite模式可以「将多个命令封装为一个复合命令」。</li><li>Command模式与C++中的函数对象(<code>functor</code>)类似，Command以面向对象中的“接口-实现”来定义行为接口规范，更严格，但有性能损失；C++函数对象以函数签名来定义行为接口规范，更灵活性能更高。</li></ul><blockquote><p><code>GoF-23</code>设计模式出现时，C++泛型编程还没有普及。因而，出现了Command、Iterator等用面向对象实现的（相比于泛型编程）性能较差的版本。</p></blockquote><h4 id="Visitor"><a href="#Visitor" class="headerlink" title="Visitor"></a>Visitor</h4><p>访问器。表示一个作用于某对象结构中的各元素的操作。使得可以在不改变(稳定)各元素的类的前提下定义(扩展)作用于这些元素的新操作(变化)。</p><h5 id="动机-21"><a href="#动机-21" class="headerlink" title="动机"></a>动机</h5><p>由于<strong>需求的变化</strong>，某些类层次结构中常常<strong>需要增加新的行为</strong>(方法)，如果直接在基类中做这样的更改，将会给子类带来很繁重的变更负担，甚至破坏原有设计。</p><p>访问器能够在不更改类层次结构的前提下，运行时根据需要透明地为类层次结构上的各个类动态添加新的操作。</p><h5 id="样例-21"><a href="#样例-21" class="headerlink" title="样例"></a>样例</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Visitor</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Element</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor&amp; visitor)</span> </span>= <span class="number">0</span>; <span class="comment">//第一次多态辨析</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Element</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ElementA</span> :</span> <span class="keyword">public</span> Element</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor &amp;visitor)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        visitor.<span class="built_in">visitElementA</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ElementB</span> :</span> <span class="keyword">public</span> Element</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor &amp;visitor)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        visitor.<span class="built_in">visitElementB</span>(*<span class="keyword">this</span>); <span class="comment">//第二次多态辨析</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Visitor</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">visitElementA</span><span class="params">(ElementA&amp; element)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">visitElementB</span><span class="params">(ElementB&amp; element)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Visitor</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//==================================</span></span><br><span class="line"><span class="comment">//扩展</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Visitor1</span> :</span> <span class="keyword">public</span> Visitor&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visitElementA</span><span class="params">(ElementA&amp; element)</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Visitor1 is processing ElementA&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visitElementB</span><span class="params">(ElementB&amp; element)</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Visitor1 is processing ElementB&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;         </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Visitor1 visitor;</span><br><span class="line">    ElementB elementB;</span><br><span class="line">    elementB.<span class="built_in">accept</span>(visitor);<span class="comment">// double dispatch</span></span><br><span class="line">    </span><br><span class="line">    ElementA elementA;</span><br><span class="line">    elementA.<span class="built_in">accept</span>(visitor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="要点-21"><a href="#要点-21" class="headerlink" title="要点"></a>要点</h5><ul><li>Visitor模式通过所谓的双重分发来实现在不更改(编译时)Element类层次结构的前提下，在运行时透明地为类层次结构上的各个类动态添加新的操作(支持变化)。</li><li>所谓双重分发Visitor模式中间包括了两个多态分发：第一个为accept方法的多态辨析；第二个为visitElement方法的多态辨析。</li><li>Visitor模式的最大缺点在于扩展类层次结构(添加新的Element子类)，会导致Visitor类的改变，因此Visitor模式<strong>适用于“Element类层次结构稳定</strong>，而其中的<strong>操作却经常面临频繁改动</strong>”。</li></ul><h3 id="领域规则"><a href="#领域规则" class="headerlink" title="领域规则"></a>领域规则</h3><p>在特定领域中，某些变化虽然频繁，但可以抽象为某种规则。这时候，结合特定领域，将问题抽象为语法规则，从而给出在该领域下的一般性解决方案。</p><h4 id="Interpreter"><a href="#Interpreter" class="headerlink" title="Interpreter"></a>Interpreter</h4><p>解析器。给定一个语言，定义它的文法的一种表示，并定义一种解释器，这个解释器使用该表示来解释语言中的句子。</p><h5 id="动机-22"><a href="#动机-22" class="headerlink" title="动机"></a>动机</h5><p>如果某一特定领域的问题比较复杂，类似的结构不断重复出现，如果使用普通的编程方式来实现将面临非常频繁的变化。</p><p>在这种情况下，将特定领域的问题表达为某种语法规则下的句子，然后构建一个解释器来解释这样的句子，从而达到解决问题的目的。</p><h5 id="样例-22"><a href="#样例-22" class="headerlink" title="样例"></a>样例</h5><p>加减运算解释器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Expression</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">interpreter</span><span class="params">(map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; var)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Expression</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//变量表达式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VarExpression</span>:</span> <span class="keyword">public</span> Expression &#123;</span><br><span class="line">    <span class="keyword">char</span> key;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">VarExpression</span>(<span class="keyword">const</span> <span class="keyword">char</span>&amp; key)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;key = key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">interpreter</span><span class="params">(map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; var)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> var[key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//符号表达式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SymbolExpression</span> :</span> <span class="keyword">public</span> Expression &#123;</span><br><span class="line">    <span class="comment">// 运算符左右两个参数</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Expression* left;</span><br><span class="line">    Expression* right;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SymbolExpression</span>( Expression* left,  Expression* right):</span><br><span class="line">        <span class="built_in">left</span>(left),<span class="built_in">right</span>(right)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加法运算</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddExpression</span> :</span> <span class="keyword">public</span> SymbolExpression &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AddExpression</span>(Expression* left, Expression* right):</span><br><span class="line">        <span class="built_in">SymbolExpression</span>(left,right)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">interpreter</span><span class="params">(map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; var)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left-&gt;<span class="built_in">interpreter</span>(var) + right-&gt;<span class="built_in">interpreter</span>(var);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减法运算</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubExpression</span> :</span> <span class="keyword">public</span> SymbolExpression &#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SubExpression</span>(Expression* left, Expression* right):</span><br><span class="line">        <span class="built_in">SymbolExpression</span>(left,right)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">interpreter</span><span class="params">(map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; var)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left-&gt;<span class="built_in">interpreter</span>(var) - right-&gt;<span class="built_in">interpreter</span>(var);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Expression*  <span class="title">analyse</span><span class="params">(string expStr)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    stack&lt;Expression*&gt; expStack;</span><br><span class="line">    Expression* left = <span class="literal">nullptr</span>;</span><br><span class="line">    Expression* right = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;expStr.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span>(expStr[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                <span class="comment">// 加法运算</span></span><br><span class="line">                left = expStack.<span class="built_in">top</span>();</span><br><span class="line">                right = <span class="keyword">new</span> <span class="built_in">VarExpression</span>(expStr[++i]);</span><br><span class="line">                expStack.<span class="built_in">push</span>(<span class="keyword">new</span> <span class="built_in">AddExpression</span>(left, right));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                <span class="comment">// 减法运算</span></span><br><span class="line">                left = expStack.<span class="built_in">top</span>();</span><br><span class="line">                right = <span class="keyword">new</span> <span class="built_in">VarExpression</span>(expStr[++i]);</span><br><span class="line">                expStack.<span class="built_in">push</span>(<span class="keyword">new</span> <span class="built_in">SubExpression</span>(left, right));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// 变量表达式</span></span><br><span class="line">                expStack.<span class="built_in">push</span>(<span class="keyword">new</span> <span class="built_in">VarExpression</span>(expStr[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Expression* expression = expStack.<span class="built_in">top</span>();</span><br><span class="line">    <span class="keyword">return</span> expression;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">(Expression* expression)</span></span>&#123;</span><br><span class="line">    <span class="comment">//释放表达式树的节点内存...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    string expStr = <span class="string">&quot;a+b-c+d-e&quot;</span>;</span><br><span class="line">    map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; var;</span><br><span class="line">    var.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&#x27;a&#x27;</span>,<span class="number">5</span>));</span><br><span class="line">    var.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&#x27;b&#x27;</span>,<span class="number">2</span>));</span><br><span class="line">    var.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&#x27;c&#x27;</span>,<span class="number">1</span>));</span><br><span class="line">    var.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&#x27;d&#x27;</span>,<span class="number">6</span>));</span><br><span class="line">    var.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&#x27;e&#x27;</span>,<span class="number">10</span>));</span><br><span class="line">    Expression* expression= <span class="built_in">analyse</span>(expStr);</span><br><span class="line">    <span class="keyword">int</span> result=expression-&gt;<span class="built_in">interpreter</span>(var);</span><br><span class="line">    cout&lt;&lt;result&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">release</span>(expression);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="要点-22"><a href="#要点-22" class="headerlink" title="要点"></a>要点</h5><ul><li>Interpreter模式的<strong>应用场合</strong>是Interpreter模式应用中的难点，只有满足「业务规则频繁变化，且类似的结构不断重复出现，<br>并且容易抽象为语法规则的问题」才适合使用Interpreter模式。</li><li>使用Interpreter模式来表示文法规则，从而可以使用面向对象技巧来方便地“扩展”文法。</li><li>Interpreter模式适合简单的文法表示，对于复杂的文法表示需要求助语法分析器标准工具。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 八股 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022护网</title>
      <link href="/2022HVV/"/>
      <url>/2022HVV/</url>
      
        <content type="html"><![CDATA[<p>这篇文章主要介绍实习经历  —  2022年在某部委护网。写的很杂，很乱。</p><span id="more"></span><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>总的来说，体验感极佳(和其他项目组对比)。</p><ul><li>甲方  —  由于是夜班，和甲方没太多接触。</li><li>友商  —  友商提供了很多的物资，每晚会给我们订夜宵和早饭。告诉我们大胆弄，出事他们扛着（他们是主防）</li><li>驻场  —  驻场大哥各方面都很照顾我们</li><li>环境  —  环境还可以，起码每天都能吹空调（有些甲方是中央空调，晚上、周末不开。）</li></ul><p>本来给我安排的是另一个项目组（比较坑的那种），但是这边的驻场拿到的名单和安恒那边负责人给分配的不一样，阴差阳错的来到了这边。</p><h3 id="待遇"><a href="#待遇" class="headerlink" title="待遇"></a>待遇</h3><p>300/day，吃住报销。每晚<code>00:00~2:00</code>左右有夜宵，早晨有早饭。白天的吃饭、打车、地铁、往返车票给报销。(公司报销流程比较慢，但驻场大哥给力。提完流程直接给我们结钱。)</p><p>零食  —  友商的物资很充足随便吃，美中不足的是小鱼干、豆干、鸭货之类的小零食比较少，饮料和泡面过多。</p><p>夜宵  —  14晚夜宵吃过：炸串、披萨、牛肉汤、饺子、驴肉汤、驴肉火烧、烧烤、小龙虾、牛肉面。</p><p>早饭  —  麦当劳套餐吃到吐</p><h3 id="驻场"><a href="#驻场" class="headerlink" title="驻场"></a>驻场</h3><p>驻场大哥第一天就和我们说「我也是从实习生走过来的，每天被骂的狗血淋头。只要甲方没问题，我这就没问题。」相处了二十天，驻场大哥非常照顾我们。</p><p>有什么需要销售解决的东西，大哥直接帮我们弄。然后给销售展示一手<strong>先斩后奏</strong>（相比于其他项目组，我们基本不需要和销售求福利）。</p><p>关于20天的饭补，也并没有像其他项目组那样，必须拿着发票才给报销。大哥让我们给个数字，提完流程然后直接结账，缺的发票他去凑。（还特意告诉了护网前几天的饭补不要和其他项目组透露）甚至还告诉我们，延期导致多的那一周出去吃喝玩乐，干饭门票啥的也给报销。</p><p>正常规定的换班时间是9:00，其他项目组有些驻场每天都回迟到几分钟，而这大哥每天8:30基本就来了。（有几天比较早，甚至8:00就到了）</p><p>我觉得，今后会遇到的导师怕是不会再这么友善了。</p><h3 id="夜班"><a href="#夜班" class="headerlink" title="夜班"></a>夜班</h3><p>刚开始的时候异常的忙碌，由于工作中很多都是重复的操作，大家都化身<code>Script Kiddie</code>，疯狂写脚本来减少工作量。</p><p>不过，当甲方摆烂了、RT刷够分了，夜班可谓是质变。最后几天相当于带薪耍手机。</p><p>还遇到了几个大哥，劝我能去互联网厂做安全就不要来安全厂商。</p><h3 id="微步"><a href="#微步" class="headerlink" title="微步"></a>微步</h3><p>本来是抱着抄大佬们作业的目的去的。结果整个社区（包括平台）都非常的和谐。虽然大家都是陌生人、都在匿名，但也和谐至极。平台还会给出相应的标语激励我们。无论是夜班炫零食YT、还是日常写段子、再到大家的告别，都很让人难忘。</p><h3 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h3><ol><li>公务员真香</li><li>甲方:您哪位？<ul><li>谁鸟你一个部门的外包？</li></ul></li><li>男人之间的友谊来的那么快，没有什么人是一根烟不能认识的。</li><li>坚定了跑路做开发的信念</li></ol><h3 id="护网我到底干了啥？"><a href="#护网我到底干了啥？" class="headerlink" title="护网我到底干了啥？"></a>护网我到底干了啥？</h3><p>简单来讲，负责写防火墙过滤规则。具体内容</p><blockquote><p>「技不外传，海不露底。千两黄金不卖道，十字街头送故交。各位，高抬贵手。金盆打水银盆装，原谅  原谅。」</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 社畜养成计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL源码-算法</title>
      <link href="/STL%E6%BA%90%E7%A0%81-%E7%AE%97%E6%B3%95/"/>
      <url>/STL%E6%BA%90%E7%A0%81-%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>本文是在阅读SGI STL v3.3源码中关于<code>algorithm</code>部分，遇到的一些问题及有意思的点。</p><p>至此，STL六大件告一段落。（源码中，还有一些实现相应辅助功能的其他文件在此假装没有）。</p><span id="more"></span><h2 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h2><p>从实现角度看，STL算法实质上也是一种模板类。</p><p>STL中所有的算法前两个参数都是一对迭代器，所包含的元素都是左闭右开$\left[first,last\right)$</p><p>最后一个可选参数一般都是自定义规则（仿函数传入点），鉴于仿函数(<code> _Compare __comp</code>)传入进来只是比较规则位置发生变化，下文中以默认带有仿函数的为准。</p><blockquote><p>max/min/swap略过</p></blockquote><p>此外，在众多的函数中有着如下规律：</p><blockquote><p><code>xxx </code>和<code>xxx_if</code></p></blockquote><ul><li><code>xxx</code>一般为对值为<code>value</code>的元素进行操作</li><li><code>xxx_if</code>则是对<code>value</code>满足一定条件(<code>__pred</code>)的元素进行操作</li></ul><blockquote><p><code>xxx </code>和 <code>xxx_n</code></p></blockquote><ul><li><code>xxx</code>一般前两个参数为<code>iter first</code>和<code>iter last</code>表示对一个区间内进行操作</li><li><code>xxx_n</code>则是<code>iter first</code>和<code>size_t n</code>是以<code>first</code>为首的<code>n</code>个元素进行操作(也是一个区间)</li></ul><blockquote><p><code>xxx </code>和<code>xxx_copy</code></p></blockquote><ul><li><code>xxx</code>一般是对原数组$\left[first,last\right)$进行操作。</li><li><code>xxx_copy</code>是将操作的结果保存到$\left[result,result+last-first\right)$中。</li></ul><h3 id="accumulate"><a href="#accumulate" class="headerlink" title="accumulate"></a>accumulate</h3><p>将$\left[first,last\right)$的值累加到<code>init</code>上。（<code>init</code>在原基础上增加区间和。）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用二元函数 op 计算</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIterator</span>, <span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">BinaryOperation</span>&gt;</span></span><br><span class="line"><span class="function">_Tp <span class="title">accumulate</span><span class="params">(_InputIterator __first, _InputIterator __last, _Tp __init,</span></span></span><br><span class="line"><span class="params"><span class="function">               _BinaryOperation __binary_op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> ( ; __first != __last; ++__first)</span><br><span class="line">      __init = __binary_op(__init, *__first);</span><br><span class="line">    <span class="comment">//    __init = __init + *__first;</span></span><br><span class="line">    <span class="keyword">return</span> __init;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>__binary_op</code>  —  累加方式</li></ul><h3 id="inner-product"><a href="#inner-product" class="headerlink" title="inner_product"></a>inner_product</h3><p>我们知道两个向量的内积公式：已知两个向量：$\vec a =\left(a_1,a_2,\dots,a_i\right )\qquad\qquad\vec b =\left(b_1,b_2,\dots,b_i\right )$</p><p>两个向量的内积：$\vec a \cdot \vec b =a_1b_1+a_2b_2+\dots+a_ib_i$</p><p>两个数组的内积公式依然，数组中元素的个数类比向量的维度。</p><p>将$\left[first1,last1\right)$与$\left[first2,first2+last1-first1\right)$两个区间做内积，并将结果累加到<code>init</code>。</p><p>由于第二区间只给了首迭代器(<code>first2</code>)，要保证容器中的元素个数充足。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIterator1</span>, <span class="keyword">class</span> _<span class="title">InputIterator2</span>, <span class="keyword">class</span> _<span class="title">Tp</span>,</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> _<span class="title">BinaryOperation1</span>, <span class="keyword">class</span> _<span class="title">BinaryOperation2</span>&gt;</span></span><br><span class="line"><span class="function">_Tp <span class="title">inner_product</span><span class="params">(_InputIterator1 __first1, _InputIterator1 __last1,</span></span></span><br><span class="line"><span class="params"><span class="function">                  _InputIterator2 __first2, _Tp __init, </span></span></span><br><span class="line"><span class="params"><span class="function">                  _BinaryOperation1 __binary_op1,</span></span></span><br><span class="line"><span class="params"><span class="function">                  _BinaryOperation2 __binary_op2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; __first1 != __last1; ++__first1, ++__first2)</span><br><span class="line">        __init = __binary_op1(__init, __binary_op2(*__first1, *__first2));</span><br><span class="line">        <span class="comment">//     __init = __init + (*__first1 * *__first2);</span></span><br><span class="line">    <span class="keyword">return</span> __init;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>__binary_op1</code>  —  累加方式</li><li><code>__binary_op2</code>  —  内积方式</li></ul><h3 id="partial-sum"><a href="#partial-sum" class="headerlink" title="partial_sum"></a>partial_sum</h3><p>计算范围$\left[first,last\right)$的子范围中元素的部分和，并写入到始于 result 的范围</p><p>假设$\left[first,last\right)$表示数组$X=\left[x_1,x_2,\dots,x_i,\dots,x_n\right]$，由result开始的数组$Y=\left[y_1,y_2,\dots,y_i,\dots,y_n\right]$。则该函数实现的功能是$y_i = \sum_{n=0}^{i}x_n $。</p><p>类似于数列的$a_i \qquad S_i$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIterator</span>, <span class="keyword">class</span> _<span class="title">OutputIterator</span>, <span class="keyword">class</span> _<span class="title">Tp</span>,</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> _<span class="title">BinaryOperation</span>&gt;</span></span><br><span class="line">_OutputIterator </span><br><span class="line">__partial_sum(_InputIterator __first, _InputIterator __last, </span><br><span class="line">              _OutputIterator __result, _Tp*, _BinaryOperation __binary_op)</span><br><span class="line">&#123;</span><br><span class="line">    _Tp __value = *__first;</span><br><span class="line">    <span class="keyword">while</span> (++__first != __last) &#123;</span><br><span class="line">        __value = __binary_op(__value, *__first);</span><br><span class="line">        <span class="comment">//__value = __value + *__first;</span></span><br><span class="line">        *++__result = __value;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">return</span> ++__result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIterator</span>, <span class="keyword">class</span> _<span class="title">OutputIterator</span>, <span class="keyword">class</span> _<span class="title">BinaryOperation</span>&gt;</span></span><br><span class="line"><span class="function">_OutputIterator </span></span><br><span class="line"><span class="function"><span class="title">partial_sum</span><span class="params">(_InputIterator __first, _InputIterator __last,</span></span></span><br><span class="line"><span class="params"><span class="function">            _OutputIterator __result, _BinaryOperation __binary_op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (__first == __last) <span class="keyword">return</span> __result;<span class="comment">//首尾指针重合 含有0个元素 无操作</span></span><br><span class="line">    *__result = *__first;</span><br><span class="line">    <span class="keyword">return</span> __partial_sum(__first, __last, __result, __VALUE_TYPE(__first), </span><br><span class="line">                         __binary_op);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>__binary_op</code>  —  累加方式</li></ul><h3 id="adjacent-difference"><a href="#adjacent-difference" class="headerlink" title="adjacent_difference"></a>adjacent_difference</h3><p>计算范围$\left[first,last\right)$的相邻元素的差值，并写入到始于 result 的范围。</p><p>假设$\left[first,last\right)$表示数组$X=\left[x_1,x_2,\dots,x_i,\dots,x_n\right]$，由result开始的数组$Y=\left[y_1,y_2,\dots,y_i,\dots,y_n\right]$。则该函数实现的功能是$y_i = x_i - x_{i-1}$，特例$y_0=x_0$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIterator</span>, <span class="keyword">class</span> _<span class="title">OutputIterator</span>, <span class="keyword">class</span> _<span class="title">Tp</span>, </span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> _<span class="title">BinaryOperation</span>&gt;</span></span><br><span class="line">_OutputIterator</span><br><span class="line">__adjacent_difference(_InputIterator __first, _InputIterator __last, </span><br><span class="line">                      _OutputIterator __result, _Tp*,</span><br><span class="line">                      _BinaryOperation __binary_op) &#123;</span><br><span class="line">    _Tp __value = *__first;<span class="comment">// x_&#123;i-1&#125;</span></span><br><span class="line">    <span class="keyword">while</span> (++__first != __last) &#123;</span><br><span class="line">        _Tp __tmp = *__first;</span><br><span class="line">        *++__result = __binary_op(__tmp, __value);</span><br><span class="line">        <span class="comment">// *++__result = __tmp - __value; </span></span><br><span class="line">        __value = __tmp;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">return</span> ++__result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIterator</span>, <span class="keyword">class</span> _<span class="title">OutputIterator</span>, <span class="keyword">class</span> _<span class="title">BinaryOperation</span>&gt;</span></span><br><span class="line"><span class="function">_OutputIterator </span></span><br><span class="line"><span class="function"><span class="title">adjacent_difference</span><span class="params">(_InputIterator __first, _InputIterator __last,</span></span></span><br><span class="line"><span class="params"><span class="function">                    _OutputIterator __result, _BinaryOperation __binary_op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (__first == __last) <span class="keyword">return</span> __result;<span class="comment">//重合无任何操作</span></span><br><span class="line">    *__result = *__first;<span class="comment">//y0 = x0</span></span><br><span class="line">    <span class="keyword">return</span> __adjacent_difference(__first, __last, __result,</span><br><span class="line">                                 __VALUE_TYPE(__first),</span><br><span class="line">                                 __binary_op);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>__binary_op</code>  —  作差方式</li></ul><h3 id="power"><a href="#power" class="headerlink" title="power"></a>power</h3><p>快速幂求$x^n$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Integer</span>, <span class="keyword">class</span> _<span class="title">MonoidOperation</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> _Tp <span class="title">power</span><span class="params">(_Tp __x, _Integer __n, _MonoidOperation __opr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __power(__x, __n, __opr);</span><br><span class="line">    <span class="comment">//return __power(__x, __n, multiplies&lt;_Tp&gt;());  </span></span><br><span class="line">    <span class="comment">//不传操作符默认调用算数仿函数multiplies</span></span><br><span class="line">    <span class="comment">//影响的是移位时值改变的方式。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Integer</span>, <span class="keyword">class</span> _<span class="title">MonoidOperation</span>&gt;</span></span><br><span class="line">_Tp __power(_Tp __x, _Integer __n, _MonoidOperation __opr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (__n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">identity_element</span>(__opr);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> ((__n &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            __n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            __x = __opr(__x, __x);</span><br><span class="line">            <span class="comment">//默认传参multiplies是相乘，在此可更改</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _Tp __result = __x;</span><br><span class="line">        __n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (__n != <span class="number">0</span>) &#123;</span><br><span class="line">            __x = __opr(__x, __x);</span><br><span class="line">            <span class="keyword">if</span> ((__n &amp; <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">                __result = __opr(__result, __x);</span><br><span class="line">            __n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> __result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h3><p>将$\left[value,value+last-first\right)$元素的值赋给$\left[fist,last\right)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">iota</span><span class="params">(_ForwardIter __first, _ForwardIter __last, _Tp __value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (__first != __last)</span><br><span class="line">        *__first++ = __value++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="iter-swap"><a href="#iter-swap" class="headerlink" title="iter_swap"></a>iter_swap</h3><p>交换所指向的元素。（指向的内存不变）</p><blockquote><p>以下几个copy/fill函数均有针对字符串的重载，调用<code>memset</code>去赋值。</p><p>由于实现的功能是赋值，也没有额外增加运算规则的重载。</p></blockquote><h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><p>正向拷贝（<mark>从前往后</mark>读取并赋值）。有<code>random_access_iterator_tag</code>、<code>input_iterator_tag</code>、<code>__copy_trivial</code>等多个版本所实现的功能均为将$\left[first,last\right)$区域的内容拷贝至$\left[result,result+last-first\right)$内。</p><h3 id="copy-backward"><a href="#copy-backward" class="headerlink" title="copy_backward"></a>copy_backward</h3><p>反向拷贝（<mark>从后往前</mark>读取并赋值）。同样有多个重载版本，但实现的功能一样。</p><p>将$\left[first,last\right)$区域的内容拷贝至$\left[result-\left(last-first\right),result\right)$内。</p><h3 id="copy-n"><a href="#copy-n" class="headerlink" title="copy_n"></a>copy_n</h3><p>将$\left[first,first+n\right)$拷贝给$\left[result,result+n\right)$</p><h3 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h3><p>将$\left[first,last\right)$的值赋为<code>value</code></p><h3 id="fill-n"><a href="#fill-n" class="headerlink" title="fill_n"></a>fill_n</h3><p>将$\left[first,first+n\right)$的值赋为<code>value</code></p><h3 id="mismatch"><a href="#mismatch" class="headerlink" title="mismatch"></a>mismatch</h3><p>将$\left[first1,last1\right)$与$\left[first2,first2+last1-first1\right)$中对应位置的元素进行对比。返回 值不相等时的<mark>两个迭代器</mark></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter1</span>, <span class="keyword">class</span> _<span class="title">InputIter2</span>, <span class="keyword">class</span> _<span class="title">BinaryPredicate</span>&gt;</span></span><br><span class="line"><span class="function">pair&lt;_InputIter1, _InputIter2&gt; <span class="title">mismatch</span><span class="params">(_InputIter1 __first1,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        _InputIter1 __last1,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        _InputIter2 __first2,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        _BinaryPredicate __binary_pred)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (__first1 != __last1 &amp;&amp; __binary_pred(*__first1, *__first2)) &#123;</span><br><span class="line">        <span class="comment">//*__first1 == *__first2</span></span><br><span class="line">        ++__first1;</span><br><span class="line">        ++__first2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pair&lt;_InputIter1, _InputIter2&gt;(__first1, __first2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>__binary_pred</code>  —  自定义的比较规则</li></ul><h3 id="equal"><a href="#equal" class="headerlink" title="equal"></a>equal</h3><p>对比$\left[first1,last1\right)$与$\left[first2,first2+last1-first1\right)$对应位置的元素是否相等，完全相等返回<code>true</code></p><h3 id="lexicographical-compare"><a href="#lexicographical-compare" class="headerlink" title="lexicographical_compare"></a>lexicographical_compare</h3><p>以字典序对比$\left[first1,last1\right)$与$\left[first2,last2\right)$。区间1小于区间2则返回<code>true</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter1</span>, <span class="keyword">class</span> _<span class="title">InputIter2</span>, <span class="keyword">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">lexicographical_compare</span><span class="params">(_InputIter1 __first1, _InputIter1 __last1,</span></span></span><br><span class="line"><span class="params"><span class="function">                             _InputIter2 __first2, _InputIter2 __last2,</span></span></span><br><span class="line"><span class="params"><span class="function">                             _Compare __comp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; __first1 != __last1 &amp;&amp; __first2 != __last2</span><br><span class="line">          ; ++__first1, ++__first2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (__comp(*__first1, *__first2))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//字符小于</span></span><br><span class="line">        <span class="keyword">if</span> (__comp(*__first2, *__first1))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;<span class="comment">//前面字符相等 但2长（1为2的前缀）</span></span><br><span class="line">    <span class="keyword">return</span> __first1 == __last1 &amp;&amp; __first2 != __last2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="median"><a href="#median" class="headerlink" title="__median"></a>__median</h3><p>一个辅助函数，用于寻找3个元素中的最小值。</p><ul><li>可传入第四个参数<code>__comp</code>，用于更改元素间的比对规则。</li></ul><h3 id="for-each"><a href="#for-each" class="headerlink" title="for_each"></a>for_each</h3><p>遍历。遍历$\left[first,last\right)$区间，并对每个元素执行<code>_Function __f</code></p><blockquote><p>以下 find/count函数针对<code>iterator_category</code>不同</p><p>分为<code>input_iterator_tag</code>和<code>random_access_iterator_tag</code>两个版本</p></blockquote><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>在$\left[first,last\right)$中查找第一个值为<code>val</code>的位置。</p><h3 id="find-if"><a href="#find-if" class="headerlink" title="find_if"></a>find_if</h3><p>在$\left[first,last\right)$中查找第一个值满足<code>__pred</code>条件的位置。</p><h3 id="adjacent-find"><a href="#adjacent-find" class="headerlink" title="adjacent_find"></a>adjacent_find</h3><p>在$\left[first,last\right)$中查找 2 个连续相等的元素。如果能找到返回前一个元素位置的迭代器。</p><p>允许自定义判断规则<code>__binary_pred</code></p><h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><p>判断$\left[first,last\right)$中<code>val</code>出现的次数，并将值加在<code>n</code>上。</p><h3 id="count-if"><a href="#count-if" class="headerlink" title="count_if"></a>count_if</h3><p>判断$\left[first,last\right)$中元素满足<code>__pred</code>条件的个数，并将值加在<code>n</code>上。</p><h3 id="search"><a href="#search" class="headerlink" title="search"></a>search</h3><p>在$\left[first1,last1\right)$中寻找第一个与$\left[first2,last2\right)$相等（或满足<code>__predicate</code>条件）的子数组，返回首个元素的位置。</p><h3 id="search-n"><a href="#search-n" class="headerlink" title="search_n"></a>search_n</h3><p>在$\left[first,last\right)$中寻找第一次连续出现<code>__count</code>个元素值等于<code>__val</code>（或满足<code>__binary_pred</code>条件的<code>__val</code>）的位置。（返回首元素位置）</p><h3 id="swap-ranges"><a href="#swap-ranges" class="headerlink" title="swap_ranges"></a>swap_ranges</h3><p>调用[iter_swap](# iter_swap)实现，互换$\left[first1,last1\right)$与$\left[first2,first2+last1-first1\right)$区间元素（交换所存的值）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter1</span>, <span class="keyword">class</span> _<span class="title">ForwardIter2</span>&gt;</span></span><br><span class="line"><span class="function">_ForwardIter2 <span class="title">swap_ranges</span><span class="params">(_ForwardIter1 __first1, _ForwardIter1 __last1,</span></span></span><br><span class="line"><span class="params"><span class="function">                          _ForwardIter2 __first2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; __first1 != __last1; ++__first1, ++__first2)</span><br><span class="line">        <span class="built_in">iter_swap</span>(__first1, __first2);</span><br><span class="line">    <span class="keyword">return</span> __first2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h3><p>将函数<code>__opr</code>(可一元和二元)应用到序列$\left[first1,last1\right)$的元素上，并将这个函数返回的值保存到另一个序列中$\left[result,result+last1-first1\right)$。</p><p>当传入二元仿函数时，需要额外传入一个迭代器<code>first2</code>，所实现的功能是：将$\left[first1,last1\right)$与$\left[first2,first2+last1-first1\right)$进行<code>__binary_op</code>运算并将结果存储在$\left[result,result+last1-first1\right)$</p><blockquote><p>transform与for_each的区别</p></blockquote><ul><li>for_each所调用的仿函数没有返回值，且只能在原位置上修改。</li><li>transform所调用的函数必须有返回值（要依次赋值给另一区间），原位置元素不受影响。</li></ul><h3 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h3><p>将$\left[first,last\right)$中值等于<code>__old_value</code>的元素（满足<code>pred</code>条件的元素）替换为<code>__new_value</code></p><h3 id="replace-copy-if"><a href="#replace-copy-if" class="headerlink" title="replace_copy(_if)"></a>replace_copy(_if)</h3><p><code>replace</code>中的替换是在原位置上进行，该函数是以原数组为基础进行操作，并将结果存在新位置。</p><p>将$\left[first,last\right)$中的值赋值到$\left[result,result+last-first\right)$中，并将其中等于<code>__old_value</code>的元素（满足<code>pred</code>条件的元素，增加<code>_if</code>）替换为<code>__new_value</code>。</p><h3 id="generate-n"><a href="#generate-n" class="headerlink" title="generate(_n)"></a>generate(_n)</h3><p>为$\left[first,last\right)$（或$\left[first,first+n\right)$）中元素赋值为<code>__gen</code>。<code>__gen</code>要求为lambda表达式。</p><blockquote><p>generate与for_each区别</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//generate</span></span><br><span class="line"><span class="keyword">for</span> ( ; __first != __last; ++__first)</span><br><span class="line">    *__first = __gen();</span><br><span class="line"><span class="comment">//for_each</span></span><br><span class="line"><span class="keyword">for</span> ( ; __first != __last; ++__first)</span><br><span class="line">    __f(*__first);</span><br></pre></td></tr></table></figure><p>因为函数调用的形式不同，进而对输入的要求也不同。for_each传入的是一个仿函数，而generate传入的是lambda表达式。</p><h3 id="remove-copy-if"><a href="#remove-copy-if" class="headerlink" title="remove(_copy) (_if)"></a><code>remove(_copy) (_if)</code></h3><blockquote><p>值为<code>__value</code>可以替换成满足<code>__pred</code>条件（函数名增加<code>_if</code>）</p></blockquote><h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h4><p>在$\left[first,last\right)$中删除掉值为<code>__value</code>的元素（后面元素前移实现覆盖。）</p><p>为实现后面元素前移的覆盖，使用的是<code>remove_copy</code>函数</p><h4 id="remove-copy"><a href="#remove-copy" class="headerlink" title="remove_copy"></a>remove_copy</h4><p>在$\left[first,last\right)$中删除掉值为<code>__value</code>的元素并将结果保存到以<code>__result</code>为首地址的容器中。</p><h3 id="unique-copy"><a href="#unique-copy" class="headerlink" title="unique_copy"></a>unique_copy</h3><p>将$\left[first,last\right)$，拷贝到$\left[result,result+last-first\right)$中，并将连续相等元素删除后者。</p><p>(相邻且满足<code>__binary_pred</code>条件的后者)</p><h3 id="unique"><a href="#unique" class="headerlink" title="unique"></a>unique</h3><p>对$\left[first,last\right)$中连续相等的元素删除后者(相邻且满足<code>__binary_pred</code>条件的后者)</p><h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h3><p>翻转$\left[first,last\right)$区间内的元素。（从两端向中间，依次交换所存储的值）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(_BidirectionalIter __first, _BidirectionalIter __last)</span> </span>&#123;</span><br><span class="line">    __reverse(__first, __last, __ITERATOR_CATEGORY(__first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> __reverse(_RandomAccessIter __first, _RandomAccessIter __last,</span><br><span class="line">               random_access_iterator_tag) &#123;</span><br><span class="line">    <span class="keyword">while</span> (__first &lt; __last)</span><br><span class="line">        <span class="built_in">iter_swap</span>(__first++, --__last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="reverse-copy"><a href="#reverse-copy" class="headerlink" title="reverse_copy"></a>reverse_copy</h3><blockquote><p>与先<code>reverse</code>后拷贝实现上有些差别</p></blockquote><p>逆序读取$\left[first,last\right)$区间的值，并写入$\left[result,result+last-first\right)$中</p><h3 id="rotate"><a href="#rotate" class="headerlink" title="rotate"></a>rotate</h3><p>将$\left[first,last\right)$中的元素以<code>middle</code>断开。先存放$\left[middle,last\right)$再存放$\left[first,middle\right)$。返回，开始时first指向的元素现在的位置。（底层实现上疯狂转轮，看不懂）</p><h3 id="rotate-copy"><a href="#rotate-copy" class="headerlink" title="rotate_copy"></a>rotate_copy</h3><blockquote><p>与先<code>rotate</code>后拷贝实现上有些差别</p></blockquote><p>先调用<code>copy(__middle, __last, __result)</code>将$\left[middle,last\right)$的元素存放在以<code>result</code>开始的空间，然后利用copy返回值<code>iter</code>（result开始的数组下一可存放位置）再次调用<code>copy(__first, __middle,iter)</code>将$\left[first,middle\right)$中的元素拷贝到剩余部分。</p><blockquote><p>下述扰乱函数 可加入一个生成随机数的仿函数<code>__rand</code></p></blockquote><h3 id="random-shuffle"><a href="#random-shuffle" class="headerlink" title="random_shuffle"></a>random_shuffle</h3><p>将$\left[first,last\right)$中的元素随机扰乱。（随机洗牌）有$\left(last-first\right)!$种可能。</p><h3 id="random-sample-n"><a href="#random-sample-n" class="headerlink" title="random_sample_n"></a>random_sample_n</h3><p>将$\left[first,last\right)$中的$\min\left(last-first,n\right)$个元素随机的复制到$\left[out,out+n\right)$中。（原数组中每个位置的元素仅能出现一次。）</p><h3 id="random-sample"><a href="#random-sample" class="headerlink" title="random_sample"></a>random_sample</h3><p>将$\left[first,last\right)$中的$\min\left(last-first, olast-ofirst\right)$个元素随机的复制到$\left[olast,ofirst\right)$中。（原数组中每个位置的元素仅能出现一次。）</p><p>以$n =olast-ofirst$ 为参数调用<code>random_sample_n</code></p><h3 id="partition"><a href="#partition" class="headerlink" title="partition"></a>partition</h3><p>以<code>__pred</code>为规则对$\left[first,last\right)$中的元素进行分组（不保证顺序）满足条件的移动至前半部分。</p><h3 id="stable-partition"><a href="#stable-partition" class="headerlink" title="stable_partition"></a>stable_partition</h3><p>同样执行<code>partition</code>相关功能，但保证各自分组内元素的相对顺序。</p><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p>对$\left[first,last\right)$进行升序排序。所使用的底层排序算法为插入排序、堆排序（调用<code>partial_sort</code>函数，底层堆排序）。</p><blockquote><p>值相同的元素再排序后，不保证其相对位置。</p></blockquote><h3 id="stable-sort"><a href="#stable-sort" class="headerlink" title="stable_sort"></a>stable_sort</h3><p>对$\left[first,last\right)$进行升序排序。底层排序算法 归并排序。值相同会保证相对位置。</p><h3 id="partial-sort"><a href="#partial-sort" class="headerlink" title="partial_sort"></a>partial_sort</h3><p>在$\left[first,last\right)$中选出<code>middle - first</code>个最小元素存放在$\left[first,middle\right)$中。</p><h3 id="partial-sort-copy"><a href="#partial-sort-copy" class="headerlink" title="partial_sort_copy"></a>partial_sort_copy</h3><p>在$\left[first,last\right)$中选出$rfirst-rlast$个最小元素，存放在$\left[rfirst,rlast\right)$中</p><h3 id="nth-element"><a href="#nth-element" class="headerlink" title="nth_element"></a>nth_element</h3><p>在$\left[first,last\right)$中找到第n小的元素，并将其移动到第n个位置（$first+n-1$）</p><h3 id="lower-bound"><a href="#lower-bound" class="headerlink" title="lower_bound"></a>lower_bound</h3><p>在$\left[first,last\right)$中寻找第一个不小于<code>val</code>的元素。（<code>__comp</code>重载比较规则）</p><h3 id="upper-bound"><a href="#upper-bound" class="headerlink" title="upper_bound"></a>upper_bound</h3><p>在$\left[first,last\right)$中寻找第一个大于<code>val</code>的元素。（<code>__comp</code>重载比较规则）</p><h3 id="equal-range"><a href="#equal-range" class="headerlink" title="equal_range"></a>equal_range</h3><p>在$\left[first,last\right)$中寻找等于<code>val</code>的<mark>所有</mark>元素。（<code>__comp</code>重载比较规则）</p><h3 id="binary-search"><a href="#binary-search" class="headerlink" title="binary_search"></a>binary_search</h3><p>在$\left[first,last\right)$中二分查找是否存在元素<code>val</code></p><h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><p>将$\left[first1,last1\right)$与$\left[first2,last2\right)$归并排序后存在$\left[result,result+last1-first1+last2-first2\right)$中</p><p>需要注意$\left[first1,last1\right)$与$\left[first2,last2\right)$均为升序。</p><h3 id="inplace-merge"><a href="#inplace-merge" class="headerlink" title="inplace_merge"></a>inplace_merge</h3><p>同样是归并排序。所不同的是该函数是在一个数组中间选定一个中间值，分成前后两个子数组，两个子数组进行归并排序，最终结果存在原数组中。由于涉及到元素换位置问题，故和merge有些出入。</p><p>$\left[first,middle\right)$和$\left[middle,last\right)$进行排序。</p><h3 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h3><p>判断$\left[first2,last2\right)$是否存在于$\left[first1,last1\right)$中，返回T/F</p><h3 id="set-union"><a href="#set-union" class="headerlink" title="set_union"></a>set_union</h3><p>实现两个有序集合$\left[first1,last1\right)$和$\left[first2,last2\right)$的并集操作，并将结果（仍有序）保存在以<code>result</code>开始的数组中。</p><p>$\alpha \cup \beta$</p><blockquote><p> 与<code>merge</code>不同点在于，<code>set_union</code>遇到相同元素会去重。</p></blockquote><h3 id="set-intersection"><a href="#set-intersection" class="headerlink" title="set_intersection"></a>set_intersection</h3><p>求两个集合$\left[first1,last1\right)$和$\left[first2,last2\right)$中相同的元素（或<code>comp(1,2)</code>与<code>comp(2,1)</code>均不满足的）。并将结果（仍有序）保存在以<code>result</code>开始的数组中。</p><p>$\alpha \cap \beta $</p><h3 id="set-difference"><a href="#set-difference" class="headerlink" title="set_difference"></a>set_difference</h3><p>求在$\left[first1,last1\right)$不在$\left[first2,last2\right)$中的元素。并将结果（仍有序）保存在以<code>result</code>开始的数组中。</p><p>$\alpha -\beta $</p><h3 id="set-symmetric-difference"><a href="#set-symmetric-difference" class="headerlink" title="set_symmetric_difference"></a>set_symmetric_difference</h3><p>$\left[first1,last1\right)$与$\left[first2,last2\right)$不重复的元素。</p><p>$\alpha \cup\beta - \alpha \cap\beta$</p><h3 id="max-element"><a href="#max-element" class="headerlink" title="max_element"></a>max_element</h3><p>返回$\left[first,last\right)$中元素值最大的元素的迭代器（重定义比较规则<code>comp</code>）</p><h3 id="min-element"><a href="#min-element" class="headerlink" title="min_element"></a>min_element</h3><p>返回$\left[first,last\right)$中元素值最小的元素的迭代器（重定义比较规则<code>comp</code>）</p><h3 id="next-permutation"><a href="#next-permutation" class="headerlink" title="next_permutation"></a>next_permutation</h3><p>由$\left[first,last\right)$中所有元素组成的排列中，按照从小到大排序后，当前的下一个排列。</p><h3 id="prev-permutation"><a href="#prev-permutation" class="headerlink" title="prev_permutation"></a>prev_permutation</h3><p>由$\left[first,last\right)$中所有元素组成的排列中，按照从小到大排序后，当前的上一个排列。</p><h3 id="find-first-of"><a href="#find-first-of" class="headerlink" title="find_first_of"></a>find_first_of</h3><p>寻找$\left[first2,last2\right)$中的（任意）字符在$\left[first1,last1\right)$中出现最早的位置。返回该位置的下一位置。（或$\left[first2,last2\right)$）中满足<code>__comp</code>条件的元素。</p><p>$\left[first1,last1\right)$中每读取一个元素便与$\left[first2,last2\right)$中所有元素比对一次。</p><h3 id="find-end"><a href="#find-end" class="headerlink" title="find_end"></a>find_end</h3><p>在$\left[first1,last1\right)$中寻找最后一个与$\left[first2,last2\right)$相等（或满足<code>__predicate</code>条件）的子数组，返回首个元素的位置。</p><h3 id="is-sorted"><a href="#is-sorted" class="headerlink" title="is_sorted"></a>is_sorted</h3><p>$\left[first,last\right)$是否有序(或 任意相邻元素满足<code>__comp</code>关系)</p>]]></content>
      
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> SGI_STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL源码-仿函数</title>
      <link href="/STL%E6%BA%90%E7%A0%81-%E4%BB%BF%E5%87%BD%E6%95%B0/"/>
      <url>/STL%E6%BA%90%E7%A0%81-%E4%BB%BF%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>本文是阅读<code>SGI STL</code>源码中关于<code>functor</code>部分的笔记</p><p>同样，本文仍然是建立在已经观看过<a href="https://endgame.cc/2022/06/23/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">侯捷老师STL源码剖析课程</a>的基础上。是在阅读源码过程中，对其中的内容进行补充、修饰。</p><span id="more"></span><h2 id="functor"><a href="#functor" class="headerlink" title="functor"></a>functor</h2><p>仿函数的行为类似于函数，但其可以作为算法的比较策略（优化算法的使用）</p><p>仿函数是一种重载了<code>operator()</code>的模板类，主要用于STL中作为算法的判断条件。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>从<mark>操作数的个数</mark>上分，可以将仿函数划分为一元仿函数和二元仿函数。</p><h4 id="unary-function"><a href="#unary-function" class="headerlink" title="unary_function"></a>unary_function</h4><p>一元仿函数，呈现一元函数的参数类型和返回值类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Arg</span>, <span class="keyword">class</span> _<span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">unary_function</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> _Arg argument_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Result result_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="binary-function"><a href="#binary-function" class="headerlink" title="binary_function"></a>binary_function</h4><p>二元仿函数，呈现二元函数的第一参数类型、第二参数类型，以及返回值类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Arg1</span>, <span class="keyword">class</span> _<span class="title">Arg2</span>, <span class="keyword">class</span> _<span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binary_function</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> _Arg1 first_argument_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Arg2 second_argument_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Result result_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>从所实现的功能上划分，可以分为算数类、逻辑运算类、关系运算类。</p></blockquote><ul><li>算数类  —  加法(plus)、减法(minus)、乘法(multiplies)、除法(divides)</li><li>逻辑运算类  —  与（logical_and）、或(logical_or)、非(logical_not)</li><li>关系运算类  —  等于（equal_to）、大于等于（greater_equal）、小于（less）</li></ul><p>下面具体介绍相关仿函数。</p><h4 id="算数类仿函数"><a href="#算数类仿函数" class="headerlink" title="算数类仿函数"></a>算数类仿函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">plus</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Tp,_Tp&gt; &#123;</span><br><span class="line">    <span class="function">_Tp <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x + __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 减</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">minus</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Tp,_Tp&gt; &#123;</span><br><span class="line">    <span class="function">_Tp <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x - __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 乘</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">multiplies</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Tp,_Tp&gt; &#123;</span><br><span class="line">    <span class="function">_Tp <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x * __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 除</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">divides</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Tp,_Tp&gt; &#123;</span><br><span class="line">    <span class="function">_Tp <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x / __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//取余</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">modulus</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Tp,_Tp&gt; </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">_Tp <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x % __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 取反</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">negate</span> :</span> <span class="keyword">public</span> unary_function&lt;_Tp,_Tp&gt; </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">_Tp <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> -__x; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="关系运算类仿函数"><a href="#关系运算类仿函数" class="headerlink" title="关系运算类仿函数"></a>关系运算类仿函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等于</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">equal_to</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Tp,<span class="keyword">bool</span>&gt; </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x == __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不等于</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">not_equal_to</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Tp,<span class="keyword">bool</span>&gt; </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x != __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大于</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">greater</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Tp,<span class="keyword">bool</span>&gt; </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x &gt; __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 小于</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">less</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Tp,<span class="keyword">bool</span>&gt; </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x &lt; __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大于等于</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">greater_equal</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Tp,<span class="keyword">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x &gt;= __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小于等于</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">less_equal</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Tp,<span class="keyword">bool</span>&gt; </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x &lt;= __y; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="逻辑运算类仿函数"><a href="#逻辑运算类仿函数" class="headerlink" title="逻辑运算类仿函数"></a>逻辑运算类仿函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逻辑与</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">logical_and</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Tp,<span class="keyword">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x &amp;&amp; __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逻辑或</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">logical_or</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Tp,<span class="keyword">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x || __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逻辑非</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">logical_not</span> :</span> <span class="keyword">public</span> unary_function&lt;_Tp,<span class="keyword">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> !__x; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Functor-Adapter"><a href="#Functor-Adapter" class="headerlink" title="Functor Adapter"></a>Functor Adapter</h4><h5 id="not1"><a href="#not1" class="headerlink" title="not1"></a>not1</h5><p>创建返回传递的一元谓词的反义的函数对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unary_negate</span> :</span> <span class="keyword">public</span> unary_function&lt;<span class="keyword">typename</span> _Predicate::argument_type, <span class="keyword">bool</span>&gt; &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    _Predicate _M_pred;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">unary_negate</span><span class="params">(<span class="keyword">const</span> _Predicate&amp; __x)</span> : _M_pred(__x) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">typename</span> _Predicate::argument_type&amp; __x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !_M_pred(__x);</span><br><span class="line">        <span class="comment">//operator()重载</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> unary_negate&lt;_Predicate&gt;  <span class="title">not1</span><span class="params">(<span class="keyword">const</span> _Predicate&amp; __pred)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unary_negate&lt;_Predicate&gt;(__pred);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="not2"><a href="#not2" class="headerlink" title="not2"></a>not2</h5><p>同理，创建返回传递的二元谓词的反义的函数对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Predicate</span>&gt;</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">binary_negate</span> </span></span><br><span class="line"><span class="class">  :</span> <span class="keyword">public</span> binary_function&lt;<span class="keyword">typename</span> _Predicate::first_argument_type,</span><br><span class="line">                           <span class="keyword">typename</span> _Predicate::second_argument_type,</span><br><span class="line">                           <span class="keyword">bool</span>&gt; &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    _Predicate _M_pred;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">binary_negate</span><span class="params">(<span class="keyword">const</span> _Predicate&amp; __x)</span> : _M_pred(__x) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">typename</span> _Predicate::first_argument_type&amp; __x, </span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">const</span> <span class="keyword">typename</span> _Predicate::second_argument_type&amp; __y)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !_M_pred(__x, __y); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> binary_negate&lt;_Predicate&gt;  <span class="title">not2</span><span class="params">(<span class="keyword">const</span> _Predicate&amp; __pred)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> binary_negate&lt;_Predicate&gt;(__pred);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="bind1st"><a href="#bind1st" class="headerlink" title="bind1st"></a>bind1st</h5><p>bind1st,bind2nd要求传入两个参数 第一参数为<code>functor</code>、第二参数为<code>value</code>。</p><p>将一个二元仿函数转化为一元，并将<code>value</code>绑定为<code>functor</code>的第一参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Operation</span>&gt;</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">binder1st</span></span></span><br><span class="line"><span class="class">  :</span> <span class="keyword">public</span> unary_function&lt;<span class="keyword">typename</span> _Operation::second_argument_type,</span><br><span class="line">                          <span class="keyword">typename</span> _Operation::result_type&gt; &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    _Operation op;</span><br><span class="line">    <span class="keyword">typename</span> _Operation::first_argument_type value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">binder1st</span>(<span class="keyword">const</span> _Operation&amp; __x,</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">typename</span> _Operation::first_argument_type&amp; __y)</span><br><span class="line">      : <span class="built_in">op</span>(__x), <span class="built_in">value</span>(__y) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">typename</span> _Operation::result_type</span></span><br><span class="line"><span class="function">    <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">typename</span> _Operation::second_argument_type&amp; __x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">op</span>(value, __x); </span><br><span class="line">        <span class="comment">//这里调用op和传入的值value，可见第一参数op应为仿函数</span></span><br><span class="line">        <span class="comment">//和仿函数一起传入的参数value，作为仿函数的第一参数。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Operation</span>, <span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> binder1st&lt;_Operation&gt; </span></span><br><span class="line"><span class="function"><span class="title">bind1st</span><span class="params">(<span class="keyword">const</span> _Operation&amp; __fn, <span class="keyword">const</span> _Tp&amp; __x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Operation::first_argument_type _Arg1_type;</span><br><span class="line">    <span class="keyword">return</span> binder1st&lt;_Operation&gt;(__fn, _Arg1_type(__x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="bind2nd"><a href="#bind2nd" class="headerlink" title="bind2nd"></a>bind2nd</h5><p>将一个二元仿函数转化为一元，并将<code>value</code>绑定为<code>functor</code>的第二参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Operation</span>&gt;</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">binder2nd</span></span></span><br><span class="line"><span class="class">  :</span> <span class="keyword">public</span> unary_function&lt;<span class="keyword">typename</span> _Operation::first_argument_type,</span><br><span class="line">                          <span class="keyword">typename</span> _Operation::result_type&gt; &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    _Operation op;</span><br><span class="line">    <span class="keyword">typename</span> _Operation::second_argument_type value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">binder2nd</span>(<span class="keyword">const</span> _Operation&amp; __x,</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">typename</span> _Operation::second_argument_type&amp; __y) </span><br><span class="line">      : <span class="built_in">op</span>(__x), <span class="built_in">value</span>(__y) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">typename</span> _Operation::result_type</span></span><br><span class="line"><span class="function">    <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">typename</span> _Operation::first_argument_type&amp; __x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">op</span>(__x, value); </span><br><span class="line">        <span class="comment">//value作为仿函数的第二参数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Operation</span>, <span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> binder2nd&lt;_Operation&gt;  <span class="title">bind2nd</span><span class="params">(<span class="keyword">const</span> _Operation&amp; __fn, <span class="keyword">const</span> _Tp&amp; __x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Operation::second_argument_type _Arg2_type;</span><br><span class="line">    <span class="keyword">return</span> binder2nd&lt;_Operation&gt;(__fn, _Arg2_type(__x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>bind1st</code>将操作数作为二元仿函数的第一个参数，<code>bind2nd</code>将操作数作为二元仿函数的第二个参数。</p><p>样例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> pos1 = <span class="built_in">find_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">bind1st</span>(less&lt;<span class="keyword">int</span>&gt;(), <span class="number">2</span>));</span><br><span class="line">    cout &lt;&lt; pos1 - vec.<span class="built_in">begin</span>() &lt;&lt; endl;<span class="comment">// 3</span></span><br><span class="line">    <span class="comment">//bind1st 作为第一参数，调用时为 2 &lt; vec[i] ?   角标3时满足条件，返回。</span></span><br><span class="line">    <span class="keyword">auto</span> pos2 = <span class="built_in">find_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(less&lt;<span class="keyword">int</span>&gt;(), <span class="number">2</span>));</span><br><span class="line">    cout &lt;&lt; pos2 - vec.<span class="built_in">begin</span>() &lt;&lt; endl;<span class="comment">// 0</span></span><br><span class="line">    <span class="comment">//bind2nd 作为第二参数，调用时为 vec[i] &lt; 2 ? 角标0即满足条件，返回。 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="compose1"><a href="#compose1" class="headerlink" title="compose1"></a>compose1</h5><p>一元组合仿函数适配器。将两个函数嵌套。</p><p>传入$f\left(x\right),g\left(x\right)$实现$f\left(g\left(x\right)\right)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Operation1</span>, <span class="keyword">class</span> _<span class="title">Operation2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unary_compose</span></span></span><br><span class="line"><span class="class">  :</span> <span class="keyword">public</span> unary_function&lt;<span class="keyword">typename</span> _Operation2::argument_type,</span><br><span class="line">                          <span class="keyword">typename</span> _Operation1::result_type&gt; </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    _Operation1 _M_fn1;</span><br><span class="line">    _Operation2 _M_fn2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unary_compose</span>(<span class="keyword">const</span> _Operation1&amp; __x, <span class="keyword">const</span> _Operation2&amp; __y) </span><br><span class="line">        : _M_fn1(__x), _M_fn2(__y) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">typename</span> _Operation1::result_type</span></span><br><span class="line"><span class="function">    <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">typename</span> _Operation2::argument_type&amp; __x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _M_fn1(_M_fn2(__x));<span class="comment">//实现f(g(x))</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Operation1</span>, <span class="keyword">class</span> _<span class="title">Operation2</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> unary_compose&lt;_Operation1,_Operation2&gt; </span></span><br><span class="line"><span class="function"><span class="title">compose1</span><span class="params">(<span class="keyword">const</span> _Operation1&amp; __fn1, <span class="keyword">const</span> _Operation2&amp; __fn2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unary_compose&lt;_Operation1,_Operation2&gt;(__fn1, __fn2);<span class="comment">//传入两个一元仿函数f(x),g(x)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="compose2"><a href="#compose2" class="headerlink" title="compose2"></a>compose2</h5><p>传入三个参数$f\left(x,y\right),g\left(x\right),h\left(x\right)$实现$f\left(g\left(x\right),h\left(x\right)\right)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Operation1</span>, <span class="keyword">class</span> _<span class="title">Operation2</span>, <span class="keyword">class</span> _<span class="title">Operation3</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">binary_compose</span></span></span><br><span class="line"><span class="class">  :</span> <span class="keyword">public</span> unary_function&lt;<span class="keyword">typename</span> _Operation2::argument_type,</span><br><span class="line">                          <span class="keyword">typename</span> _Operation1::result_type&gt; &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    _Operation1 _M_fn1;</span><br><span class="line">    _Operation2 _M_fn2;</span><br><span class="line">    _Operation3 _M_fn3;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">binary_compose</span>(<span class="keyword">const</span> _Operation1&amp; __x, <span class="keyword">const</span> _Operation2&amp; __y, </span><br><span class="line">                 <span class="keyword">const</span> _Operation3&amp; __z) </span><br><span class="line">      : _M_fn1(__x), _M_fn2(__y), _M_fn3(__z) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">typename</span> _Operation1::result_type</span></span><br><span class="line"><span class="function">    <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">typename</span> _Operation2::argument_type&amp; __x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _M_fn1(_M_fn2(__x), _M_fn3(__x));</span><br><span class="line">        实现<span class="built_in">fn1</span>(<span class="built_in">fn2</span>(x),<span class="built_in">fn3</span>(x));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Operation1</span>, <span class="keyword">class</span> _<span class="title">Operation2</span>, <span class="keyword">class</span> _<span class="title">Operation3</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> binary_compose&lt;_Operation1, _Operation2, _Operation3&gt; </span></span><br><span class="line"><span class="function"><span class="title">compose2</span><span class="params">(<span class="keyword">const</span> _Operation1&amp; __fn1, <span class="keyword">const</span> _Operation2&amp; __fn2, </span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="keyword">const</span> _Operation3&amp; __fn3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> binary_compose&lt;_Operation1,_Operation2,_Operation3&gt;</span><br><span class="line">        (__fn1, __fn2, __fn3);<span class="comment">//传入三个仿函数，其中fn1为二元，fn2,fn3为一元</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ptr-fun"><a href="#ptr-fun" class="headerlink" title="ptr_fun"></a>ptr_fun</h5><p>c++11被弃用，被<code>std::function</code>替代。</p><p>用于将函数包装成仿函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//包装一元函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Arg</span>, <span class="keyword">class</span> _<span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">pointer_to_unary_function</span> :</span> <span class="keyword">public</span> unary_function&lt;_Arg, _Result&gt; &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    _Result (*_M_ptr)(_Arg);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">pointer_to_unary_function</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">pointer_to_unary_function</span><span class="params">(_Result (*__x)(_Arg))</span> : _M_ptr(__x) &#123;</span>&#125;</span><br><span class="line">    <span class="function">_Result <span class="title">operator</span><span class="params">()</span><span class="params">(_Arg __x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _M_ptr(__x); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Arg</span>, <span class="keyword">class</span> _<span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> pointer_to_unary_function&lt;_Arg, _Result&gt; <span class="title">ptr_fun</span><span class="params">(_Result (*__x)(_Arg))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pointer_to_unary_function&lt;_Arg, _Result&gt;(__x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//包装二元函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Arg1</span>, <span class="keyword">class</span> _<span class="title">Arg2</span>, <span class="keyword">class</span> _<span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">pointer_to_binary_function</span> :</span> </span><br><span class="line"><span class="keyword">public</span> binary_function&lt;_Arg1,_Arg2,_Result&gt; &#123;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    _Result (*_M_ptr)(_Arg1, _Arg2);</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">pointer_to_binary_function</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">pointer_to_binary_function</span><span class="params">(_Result (*__x)(_Arg1, _Arg2))</span> </span></span><br><span class="line"><span class="function">        : _M_ptr(__x) &#123;</span>&#125;</span><br><span class="line">    <span class="function">_Result <span class="title">operator</span><span class="params">()</span><span class="params">(_Arg1 __x, _Arg2 __y)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _M_ptr(__x, __y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Arg1</span>, <span class="keyword">class</span> _<span class="title">Arg2</span>, <span class="keyword">class</span> _<span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> pointer_to_binary_function&lt;_Arg1,_Arg2,_Result&gt; </span></span><br><span class="line"><span class="function"><span class="title">ptr_fun</span><span class="params">(_Result (*__x)(_Arg1, _Arg2))</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pointer_to_binary_function&lt;_Arg1,_Arg2,_Result&gt;(__x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="identity"><a href="#identity" class="headerlink" title="identity"></a>identity</h5><p>将参数返回。接受任意类型的参数并使用完美转发，避免了在异构上下文中使用函数对象或带有右值参数时不必要的复制和转换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Identity</span> :</span> <span class="keyword">public</span> unary_function&lt;_Tp,_Tp&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> _Tp&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span> <span class="class"><span class="keyword">struct</span> <span class="title">identity</span> :</span> <span class="keyword">public</span> _Identity&lt;_Tp&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><h5 id="select1st-selece2nd"><a href="#select1st-selece2nd" class="headerlink" title="select1st/selece2nd"></a>select1st/selece2nd</h5><p>获取键值对中的第1/2个元素（map中获取<code>Key</code>  <code>Value</code>）<code>x.first /x.second</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// select1st and select2nd are extensions: they are not part of the standard.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Pair</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Select1st</span> :</span> <span class="keyword">public</span> unary_function&lt;_Pair, <span class="keyword">typename</span> _Pair::first_type&gt; &#123;</span><br><span class="line">        <span class="function"><span class="keyword">const</span> <span class="keyword">typename</span> _Pair::first_type&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Pair&amp; __x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> __x.first;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Pair</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Select2nd</span> :</span> <span class="keyword">public</span> unary_function&lt;_Pair, <span class="keyword">typename</span> _Pair::second_type&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">typename</span> _Pair::second_type&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Pair&amp; __x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __x.second;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Pair</span>&gt;</span> <span class="class"><span class="keyword">struct</span> <span class="title">select1st</span> :</span> <span class="keyword">public</span> _Select1st&lt;_Pair&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Pair</span>&gt;</span> <span class="class"><span class="keyword">struct</span> <span class="title">select2nd</span> :</span> <span class="keyword">public</span> _Select2nd&lt;_Pair&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><h5 id="project1st-project2nd"><a href="#project1st-project2nd" class="headerlink" title="project1st/project2nd"></a>project1st/project2nd</h5><p>获取第1/2个元素，<code>project1st/2nd(x,y)  ---  x/y</code> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Arg1</span>, <span class="keyword">class</span> _<span class="title">Arg2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Project1st</span> :</span> <span class="keyword">public</span> binary_function&lt;_Arg1, _Arg2, _Arg1&gt; &#123;</span><br><span class="line">    <span class="function">_Arg1 <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Arg1&amp; __x, <span class="keyword">const</span> _Arg2&amp;)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Arg1</span>, <span class="keyword">class</span> _<span class="title">Arg2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Project2nd</span> :</span> <span class="keyword">public</span> binary_function&lt;_Arg1, _Arg2, _Arg2&gt; &#123;</span><br><span class="line">    <span class="function">_Arg2 <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Arg1&amp;, <span class="keyword">const</span> _Arg2&amp; __y)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> __y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Arg1</span>, <span class="keyword">class</span> _<span class="title">Arg2</span>&gt;</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">project1st</span> :</span> <span class="keyword">public</span> _Project1st&lt;_Arg1, _Arg2&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Arg1</span>, <span class="keyword">class</span> _<span class="title">Arg2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">project2nd</span> :</span> <span class="keyword">public</span> _Project2nd&lt;_Arg1, _Arg2&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><h5 id="constant0-1-2"><a href="#constant0-1-2" class="headerlink" title="constant0/1/2"></a>constant0/1/2</h5><p>0/1/2元常(<code>const</code>)仿函数（只返回一个常量，与参数具体值无关。）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//void</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Constant_void_fun</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> _Result result_type;</span><br><span class="line">    result_type _M_val;</span><br><span class="line"></span><br><span class="line">    _Constant_void_fun(<span class="keyword">const</span> result_type&amp; __v) : _M_val(__v) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> result_type&amp; <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _M_val; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">constant_void_fun</span> :</span> <span class="keyword">public</span> _Constant_void_fun&lt;_Result&gt; &#123;</span><br><span class="line">    <span class="built_in">constant_void_fun</span>(<span class="keyword">const</span> _Result&amp; __v) : _Constant_void_fun&lt;_Result&gt;(__v) &#123;&#125;</span><br><span class="line">&#125;;  </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Result</span>&gt;</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> constant_void_fun&lt;_Result&gt; <span class="title">constant0</span><span class="params">(<span class="keyword">const</span> _Result&amp; __val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> constant_void_fun&lt;_Result&gt;(__val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//unary</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Result</span>, <span class="keyword">class</span> _<span class="title">Argument</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Constant_unary_fun</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> _Argument argument_type;</span><br><span class="line">    <span class="keyword">typedef</span>  _Result  result_type;</span><br><span class="line">    result_type _M_val;</span><br><span class="line"></span><br><span class="line">    _Constant_unary_fun(<span class="keyword">const</span> result_type&amp; __v) : _M_val(__v) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> result_type&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Argument&amp;)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _M_val; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Result</span>,</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> _<span class="title">Argument</span> __<span class="title">STL_DEPENDENT_DEFAULT_TMPL</span>(_<span class="title">Result</span>)&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">constant_unary_fun</span> :</span> <span class="keyword">public</span> _Constant_unary_fun&lt;_Result, _Argument&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">constant_unary_fun</span>(<span class="keyword">const</span> _Result&amp; __v)</span><br><span class="line">    : _Constant_unary_fun&lt;_Result, _Argument&gt;(__v) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Result</span>&gt;</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> constant_unary_fun&lt;_Result,_Result&gt; <span class="title">constant1</span><span class="params">(<span class="keyword">const</span> _Result&amp; __val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> constant_unary_fun&lt;_Result,_Result&gt;(__val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//binary</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Result</span>, <span class="keyword">class</span> _<span class="title">Arg1</span>, <span class="keyword">class</span> _<span class="title">Arg2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Constant_binary_fun</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span>  _Arg1   first_argument_type;</span><br><span class="line">    <span class="keyword">typedef</span>  _Arg2   second_argument_type;</span><br><span class="line">    <span class="keyword">typedef</span>  _Result result_type;</span><br><span class="line">    _Result _M_val;</span><br><span class="line"></span><br><span class="line">    _Constant_binary_fun(<span class="keyword">const</span> _Result&amp; __v) : _M_val(__v) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> result_type&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Arg1&amp;, <span class="keyword">const</span> _Arg2&amp;)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _M_val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Result</span>,</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> _<span class="title">Arg1</span> __<span class="title">STL_DEPENDENT_DEFAULT_TMPL</span>(_<span class="title">Result</span>),</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> _<span class="title">Arg2</span> __<span class="title">STL_DEPENDENT_DEFAULT_TMPL</span>(_<span class="title">Arg1</span>)&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">constant_binary_fun</span></span></span><br><span class="line"><span class="class">  :</span> <span class="keyword">public</span> _Constant_binary_fun&lt;_Result, _Arg1, _Arg2&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">constant_binary_fun</span>(<span class="keyword">const</span> _Result&amp; __v)</span><br><span class="line">    : _Constant_binary_fun&lt;_Result, _Arg1, _Arg2&gt;(__v) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Result</span>&gt;</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> constant_binary_fun&lt;_Result,_Result,_Result&gt; </span></span><br><span class="line"><span class="function">    <span class="title">constant2</span><span class="params">(<span class="keyword">const</span> _Result&amp; __val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> constant_binary_fun&lt;_Result,_Result,_Result&gt;(__val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="subtractive-rng"><a href="#subtractive-rng" class="headerlink" title="subtractive_rng"></a>subtractive_rng</h5><p>目前看来，传入一个随机种子，生成一个随机数。（具体作用不详）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">subtractive_rng</span> :</span> <span class="keyword">public</span> unary_function&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> _M_table[<span class="number">55</span>];</span><br><span class="line">    <span class="keyword">size_t</span> _M_index1;</span><br><span class="line">    <span class="keyword">size_t</span> _M_index2;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> __limit)</span> </span>&#123;</span><br><span class="line">        _M_index1 = (_M_index1 + <span class="number">1</span>) % <span class="number">55</span>;</span><br><span class="line">        _M_index2 = (_M_index2 + <span class="number">1</span>) % <span class="number">55</span>;</span><br><span class="line">        _M_table[_M_index1] = _M_table[_M_index1] - _M_table[_M_index2];</span><br><span class="line">        <span class="keyword">return</span> _M_table[_M_index1] % __limit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> _M_initialize(<span class="keyword">unsigned</span> <span class="keyword">int</span> __seed)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> __k = <span class="number">1</span>;</span><br><span class="line">        _M_table[<span class="number">54</span>] = __seed;</span><br><span class="line">        <span class="keyword">size_t</span> __i;</span><br><span class="line">        <span class="keyword">for</span> (__i = <span class="number">0</span>; __i &lt; <span class="number">54</span>; __i++) &#123;</span><br><span class="line">            <span class="keyword">size_t</span> __ii = (<span class="number">21</span> * (__i + <span class="number">1</span>) % <span class="number">55</span>) - <span class="number">1</span>;</span><br><span class="line">            _M_table[__ii] = __k;</span><br><span class="line">            __k = __seed - __k;</span><br><span class="line">            __seed = _M_table[__ii];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> __loop = <span class="number">0</span>; __loop &lt; <span class="number">4</span>; __loop++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (__i = <span class="number">0</span>; __i &lt; <span class="number">55</span>; __i++)</span><br><span class="line">                _M_table[__i] = _M_table[__i] - _M_table[(<span class="number">1</span> + __i + <span class="number">30</span>) % <span class="number">55</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        _M_index1 = <span class="number">0</span>;</span><br><span class="line">        _M_index2 = <span class="number">31</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">subtractive_rng</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> __seed) &#123; _M_initialize(__seed); &#125;</span><br><span class="line">    <span class="built_in">subtractive_rng</span>() &#123; _M_initialize(<span class="number">161803398u</span>); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="const-mem-fun-1-t"><a href="#const-mem-fun-1-t" class="headerlink" title="(const_)mem_fun(1)_t"></a><code>(const_)mem_fun(1)_t</code></h5><p>允许使用指针参数初始化时不调用任何参数作为一元函数对象的成员函数。</p><p>（假定容器中所有的<mark>指针</mark>所指向的类都包含相同的函数，借此可以在算法中均调用相应函数。如for_each遍历时，执行一些函数。）</p><p>对外接口形式<code> mem_fun(1)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用的是不带参数的非const函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ret</span>, <span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mem_fun_t</span> :</span> <span class="keyword">public</span> unary_function&lt;_Tp*,_Ret&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">mem_fun_t</span><span class="params">(_Ret (_Tp::*__pf)())</span> : _M_f(__pf) &#123;</span>&#125;</span><br><span class="line">    <span class="function">_Ret <span class="title">operator</span><span class="params">()</span><span class="params">(_Tp* __p)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (__p-&gt;*_M_f)(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    _Ret (_Tp::*_M_f)();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//不带参数的const函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ret</span>, <span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">const_mem_fun_t</span> :</span> <span class="keyword">public</span> unary_function&lt;<span class="keyword">const</span> _Tp*,_Ret&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">const_mem_fun_t</span><span class="params">(_Ret (_Tp::*__pf)() <span class="keyword">const</span>)</span> : _M_f(__pf) &#123;</span>&#125;</span><br><span class="line">    <span class="function">_Ret <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp* __p)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (__p-&gt;*_M_f)(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    _Ret (_Tp::*_M_f)() <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//带一个参数是非const函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ret</span>, <span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Arg</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mem_fun1_t</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp*,_Arg,_Ret&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">mem_fun1_t</span><span class="params">(_Ret (_Tp::*__pf)(_Arg))</span> : _M_f(__pf) &#123;</span>&#125;</span><br><span class="line">    <span class="function">_Ret <span class="title">operator</span><span class="params">()</span><span class="params">(_Tp* __p, _Arg __x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (__p-&gt;*_M_f)(__x); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    _Ret (_Tp::*_M_f)(_Arg);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//带一个参数的const函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ret</span>, <span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Arg</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">const_mem_fun1_t</span> :</span> <span class="keyword">public</span> binary_function&lt;<span class="keyword">const</span> _Tp*,_Arg,_Ret&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">const_mem_fun1_t</span><span class="params">(_Ret (_Tp::*__pf)(_Arg) <span class="keyword">const</span>)</span> : _M_f(__pf) &#123;</span>&#125;</span><br><span class="line">    <span class="function">_Ret <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp* __p, _Arg __x)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> (__p-&gt;*_M_f)(__x); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    _Ret (_Tp::*_M_f)(_Arg) <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试样例如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">DoSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;do something&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;A*&gt; vec;</span><br><span class="line">    A* a = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">    A *b = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">    A *c = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line"></span><br><span class="line">    vec.<span class="built_in">push_back</span>(a);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(b);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(c);</span><br><span class="line">    for_each(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">mem_fun</span>(&amp;A::DoSomething));</span><br><span class="line">    <span class="keyword">delete</span> a;</span><br><span class="line">    <span class="keyword">delete</span> b;</span><br><span class="line">    <span class="keyword">delete</span> c;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="const-mem-fun-1-ref-t"><a href="#const-mem-fun-1-ref-t" class="headerlink" title="(const_)mem_fun(1)_ref_t"></a><code>(const_)mem_fun(1)_ref_t</code></h5><p>与前文中<code>(const_)mem_fun(1)_t</code>所实现的功能相同。不同之处:前面(无<code>_ref</code>)在容器中存指针，这里(<code>_ref</code>)在容器里存引用。</p><p>最终对外接口形式<code>mem_fun(1)_ref</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ret</span>, <span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mem_fun_ref_t</span> :</span> <span class="keyword">public</span> unary_function&lt;_Tp,_Ret&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">mem_fun_ref_t</span><span class="params">(_Ret (_Tp::*__pf)())</span> : _M_f(__pf) &#123;</span>&#125;</span><br><span class="line">    <span class="function">_Ret <span class="title">operator</span><span class="params">()</span><span class="params">(_Tp&amp; __r)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (__r.*_M_f)(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    _Ret (_Tp::*_M_f)();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ret</span>, <span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">const_mem_fun_ref_t</span> :</span> <span class="keyword">public</span> unary_function&lt;_Tp,_Ret&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">const_mem_fun_ref_t</span><span class="params">(_Ret (_Tp::*__pf)() <span class="keyword">const</span>)</span> : _M_f(__pf) &#123;</span>&#125;</span><br><span class="line">    <span class="function">_Ret <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __r)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (__r.*_M_f)(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    _Ret (_Tp::*_M_f)() <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ret</span>, <span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Arg</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mem_fun1_ref_t</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Arg,_Ret&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">mem_fun1_ref_t</span><span class="params">(_Ret (_Tp::*__pf)(_Arg))</span> : _M_f(__pf) &#123;</span>&#125;</span><br><span class="line">    <span class="function">_Ret <span class="title">operator</span><span class="params">()</span><span class="params">(_Tp&amp; __r, _Arg __x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (__r.*_M_f)(__x); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    _Ret (_Tp::*_M_f)(_Arg);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ret</span>, <span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Arg</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">const_mem_fun1_ref_t</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp,_Arg,_Ret&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">const_mem_fun1_ref_t</span><span class="params">(_Ret (_Tp::*__pf)(_Arg) <span class="keyword">const</span>)</span> : _M_f(__pf) &#123;</span>&#125;</span><br><span class="line">    <span class="function">_Ret <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __r, _Arg __x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (__r.*_M_f)(__x); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    _Ret (_Tp::*_M_f)(_Arg) <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> SGI_STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL源码-迭代器</title>
      <link href="/STL%E6%BA%90%E7%A0%81-%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
      <url>/STL%E6%BA%90%E7%A0%81-%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>本文是阅读<code>SGI STL</code>源码中关于<code>iterator</code>部分的笔记</p><p>同样，本文仍然是建立在已经观看过<a href="https://endgame.cc/2022/06/23/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">侯捷老师STL源码剖析课程</a>的基础上。是在阅读源码过程中，对其中的内容进行补充、修饰。</p><p>另外<code>SGI STL</code>源码中关于<code>Adapter</code>部分没有严格的文件进行描述，在其出现的相应位置，对相关的类模板进行了改造（如：<code>container adapter</code>中有  <code>stack  queue</code>，<code>iterator adapter</code>中有<code>istream_iterator</code>等）</p><span id="more"></span><h2 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h2><p><code>iterator</code>充当容器与算法之间的桥梁，使算法不需要了解具体的算法底层实现即能操作容器中的元素。迭代器可以理解为智能指针，原生指针(<code>native pointer</code>)也是迭代器的一种。</p><h3 id="stl-iterator-base-h"><a href="#stl-iterator-base-h" class="headerlink" title="stl_iterator_base.h"></a>stl_iterator_base.h</h3><p>这个文件定义了迭代器的类型，以及针对不同类型迭代器的<code>associated types</code>。（所回答的问题）</p><h4 id="iterator-category"><a href="#iterator-category" class="headerlink" title="iterator_category"></a>iterator_category</h4><p>迭代器一共有<mark>五种类型</mark>(<code>iterator_category</code>)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_iterator_tag</span> &#123;</span>&#125;;<span class="comment">//</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">output_iterator_tag</span> &#123;</span>&#125;;<span class="comment">//</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">forward_iterator_tag</span>:</span> <span class="keyword">public</span> input_iterator_tag&#123;&#125;;<span class="comment">//单向</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bidirectional_iterator_tag</span>:</span> <span class="keyword">public</span> forward_iterator_tag&#123;&#125;;<span class="comment">//双向</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">random_access_iterator_tag</span>:</span> <span class="keyword">public</span> bidirectional_iterator_tag&#123;&#125;;<span class="comment">//随机访问</span></span><br></pre></td></tr></table></figure><h4 id="associated-type"><a href="#associated-type" class="headerlink" title="associated type"></a>associated type</h4><p>迭代器所回答的问题，有<code>iterator_category  value_type  difference_type  pointer  reference</code>五个</p><p>下面是针对五种基础类型的迭代器进行定义的问题答案:</p><p>以<code>input_iterator_tag</code>为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Distance</span>&gt;</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_iterator</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> input_iterator_tag iterator_category; <span class="comment">// 迭代器类别</span></span><br><span class="line">    <span class="keyword">typedef</span> _Tp                value_type;<span class="comment">// 解引用所得到的值的类型</span></span><br><span class="line">    <span class="keyword">typedef</span> _Distance          difference_type;<span class="comment">// 迭代器之间的距离</span></span><br><span class="line">    <span class="keyword">typedef</span> _Tp*               pointer;<span class="comment">// 指向被迭代类型的指针</span></span><br><span class="line">    <span class="keyword">typedef</span> _Tp&amp;               reference;   <span class="comment">// 被迭代类型的引用类型</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Distance</span>&gt;</span> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> input_iterator_tag  <span class="title">iterator_category</span><span class="params">(<span class="keyword">const</span> input_iterator&lt;_Tp, _Distance&gt;&amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="built_in">input_iterator_tag</span>(); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Distance</span>&gt;</span> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> _Tp* <span class="title">value_type</span><span class="params">(<span class="keyword">const</span> input_iterator&lt;_Tp, _Distance&gt;&amp;)</span></span></span><br><span class="line"><span class="function">  </span>&#123; <span class="keyword">return</span> (_Tp*)(<span class="number">0</span>); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Distance</span>&gt;</span> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> _Distance* <span class="title">distance_type</span><span class="params">(<span class="keyword">const</span> input_iterator&lt;_Tp, _Distance&gt;&amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (_Distance*)(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于<code>value_type  distance_type iterator_category</code> 的回答方式，除<code>output_iterator_tag</code>外其余几种类型的迭代器<mark>均一致</mark>，在此不再罗列。仅列出<code>output_iterator_tag</code>相关回答函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">output_iterator</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> output_iterator_tag iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">void</span>                value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">void</span>                difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">void</span>                pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">void</span>                reference;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//比起其他类型，无_Distance&gt;&amp;参数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> output_iterator_tag <span class="title">iterator_category</span><span class="params">(<span class="keyword">const</span> output_iterator&amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="built_in">output_iterator_tag</span>(); &#125;</span><br><span class="line"><span class="comment">//output_iterator_tag 无 value_type</span></span><br><span class="line"><span class="comment">//output_iterator_tag 无 distance_type</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Distance</span>&gt;</span> <span class="class"><span class="keyword">struct</span> <span class="title">forward_iterator</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> forward_iterator_tag iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp                  value_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Distance            difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp*                 pointer;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp&amp;                 reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Distance</span>&gt;</span> <span class="class"><span class="keyword">struct</span> <span class="title">bidirectional_iterator</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp                        value_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Distance                  difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp*                       pointer;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp&amp;                       reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Distance</span>&gt;</span> <span class="class"><span class="keyword">struct</span> <span class="title">random_access_iterator</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp                        value_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Distance                  difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp*                       pointer;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp&amp;                       reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="advance-distance"><a href="#advance-distance" class="headerlink" title="advance/distance"></a>advance/distance</h4><p>迭代器的类型不同，其所能移动的方式也不同，进而在移动(advance)/距离(distance)实现的方式上也有着差距:</p><h5 id="advance"><a href="#advance" class="headerlink" title="advance"></a>advance</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIterator</span>, <span class="keyword">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">advance</span><span class="params">(_InputIterator&amp; __i, _Distance __n)</span> </span>&#123;</span><br><span class="line">    __STL_REQUIRES(_InputIterator, _InputIterator);</span><br><span class="line">    __advance(__i, __n, <span class="built_in">iterator_category</span>(__i));</span><br><span class="line">&#125;<span class="comment">//总体调用这个函数</span></span><br><span class="line"><span class="comment">//根据iterator_category 的差异  定义不同类型迭代器的行为</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类似于 vector中的迭代器 支持跳跃，直接移动相应的距离</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __advance(_RandomAccessIterator&amp; __i, _Distance __n, </span><br><span class="line">                          random_access_iterator_tag) &#123;</span><br><span class="line">    __STL_REQUIRES(_RandomAccessIterator, _RandomAccessIterator);</span><br><span class="line">    __i += __n;  <span class="comment">// 双向，跳跃前进，加上标记 random_access_iterator_tag</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类似于slist、stack、queue中的迭代器，仅能单向单步移动</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="keyword">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __advance(_InputIter&amp; __i, _Distance __n, input_iterator_tag) &#123;</span><br><span class="line">    <span class="keyword">while</span> (__n--) ++__i;  <span class="comment">// 单向，加上标记 input_iterator_tag </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类似于list、deque中的迭代器，支持双向 单步移动</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIterator</span>, <span class="keyword">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __advance(_BidirectionalIterator&amp; __i, _Distance __n, </span><br><span class="line">                      bidirectional_iterator_tag) &#123;</span><br><span class="line">    __STL_REQUIRES(_BidirectionalIterator, _BidirectionalIterator);</span><br><span class="line">    <span class="keyword">if</span> (__n &gt;= <span class="number">0</span>)    <span class="comment">// 双向，加上标记 bidirectional_iterator_tag</span></span><br><span class="line">        <span class="keyword">while</span> (__n--) ++__i;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">while</span> (__n++) --__i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="distance"><a href="#distance" class="headerlink" title="distance"></a>distance</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIterator</span>, <span class="keyword">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">distance</span><span class="params">(_InputIterator __first, </span></span></span><br><span class="line"><span class="params"><span class="function">                         _InputIterator __last, _Distance&amp; __n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __STL_REQUIRES(_InputIterator, _InputIterator);</span><br><span class="line">    __distance(__first, __last, __n, <span class="built_in">iterator_category</span>(__first));</span><br><span class="line">&#125;<span class="comment">//总体调用这个函数</span></span><br><span class="line"><span class="comment">//根据iterator_category 的差异  定义不同类型迭代器的行为</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//vector中的 随机访问迭代器 可以直接通过迭代器相减计算距离</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __distance(_RandomAccessIterator __first, </span><br><span class="line">                       _RandomAccessIterator __last, </span><br><span class="line">                       _Distance&amp; __n, random_access_iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line">    __STL_REQUIRES(_RandomAccessIterator, _RandomAccessIterator);</span><br><span class="line">    __n += __last - __first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其余类型迭代器需要单步移动至重合</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIterator</span>, <span class="keyword">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __distance(_InputIterator __first, _InputIterator __last,</span><br><span class="line">                       _Distance&amp; __n, input_iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (__first != __last) &#123; ++__first; ++__n; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="native-pointer"><a href="#native-pointer" class="headerlink" title="native pointer"></a>native pointer</h4><p>前文说原生指针也是一种迭代器，故在此对其也进行了相应的回答</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> random_access_iterator_tag <span class="title">iterator_category</span><span class="params">(<span class="keyword">const</span> _Tp*)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="built_in">random_access_iterator_tag</span>(); &#125;<span class="comment">//原生指针支持随机访问</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> _Tp* <span class="title">value_type</span><span class="params">(<span class="keyword">const</span> _Tp*)</span> </span>&#123; <span class="keyword">return</span> (_Tp*)(<span class="number">0</span>); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">ptrdiff_t</span>* <span class="title">distance_type</span><span class="params">(<span class="keyword">const</span> _Tp*)</span> </span>&#123; <span class="keyword">return</span> (<span class="keyword">ptrdiff_t</span>*)(<span class="number">0</span>); &#125;</span><br></pre></td></tr></table></figure><h4 id="std-iterator"><a href="#std-iterator" class="headerlink" title="std::iterator"></a>std::iterator</h4><p>除了默认的五种类型的迭代器外，还规定了另外一种<code>std::iterator</code>该迭代器用于支撑用户自定义的迭代器相应规则的答案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_USE_NAMESPACES</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Category</span>, <span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Distance</span> =</span> <span class="keyword">ptrdiff_t</span>,</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">Pointer</span> =</span> _Tp*, <span class="class"><span class="keyword">class</span> _<span class="title">Reference</span> =</span> _Tp&amp;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator</span> &#123;</span></span><br><span class="line">        <span class="keyword">typedef</span> _Category  iterator_category;</span><br><span class="line">        <span class="keyword">typedef</span> _Tp        value_type;</span><br><span class="line">        <span class="keyword">typedef</span> _Distance  difference_type;</span><br><span class="line">        <span class="keyword">typedef</span> _Pointer   pointer;</span><br><span class="line">        <span class="keyword">typedef</span> _Reference reference;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __STL_USE_NAMESPACES */</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="traits机制"><a href="#traits机制" class="headerlink" title="traits机制"></a>traits机制</h3><p>通过萃取机制，使得使用更加灵活。</p><p><code>iterator_traits </code>负责萃取迭代器的特性，<code>__type_traits </code>负责萃取类型的特性。</p><h4 id="iterator-traits"><a href="#iterator-traits" class="headerlink" title="iterator_traits"></a>iterator_traits</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::iterator_category iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::value_type        value_type;  </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::difference_type   difference_type; </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::pointer           pointer;      </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::reference         reference;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// native_pointer</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>&lt;</span>_Tp*&gt; &#123;</span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp                         value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>                   difference_type;  <span class="comment">// C++ 内建的 ptrdiff_t 类型</span></span><br><span class="line">    <span class="keyword">typedef</span> _Tp*                        pointer;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp&amp;                        reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// native_pointer-to-const </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>&lt;</span><span class="keyword">const</span> _Tp*&gt; &#123;</span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp                         value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>                   difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> _Tp*                  pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> _Tp&amp;                  reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>以下是通过萃取机去询问相应问题</p></blockquote><h5 id="iterator-category-1"><a href="#iterator-category-1" class="headerlink" title="iterator_category"></a>iterator_category</h5><p>获取迭代器类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Iter</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;_Iter&gt;::iterator_category</span><br><span class="line">__iterator_category(<span class="keyword">const</span> _Iter&amp;)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;_Iter&gt;::iterator_category _Category;</span><br><span class="line">    <span class="keyword">return</span> _Category();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Iter</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;_Iter&gt;::<span class="function">iterator_category</span></span><br><span class="line"><span class="function"><span class="title">iterator_category</span><span class="params">(<span class="keyword">const</span> _Iter&amp; __i)</span> </span>&#123; <span class="keyword">return</span> __iterator_category(__i); &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="difference-type"><a href="#difference-type" class="headerlink" title="difference_type"></a>difference_type</h5><p>获取迭代器间距离</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Iter</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;_Iter&gt;::difference_type*</span><br><span class="line">__distance_type(<span class="keyword">const</span> _Iter&amp;)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> iterator_traits&lt;_Iter&gt;::difference_type*&gt;(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Iter</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;_Iter&gt;::<span class="function">difference_type*</span></span><br><span class="line"><span class="function"><span class="title">distance_type</span><span class="params">(<span class="keyword">const</span> _Iter&amp; __i)</span> </span>&#123; <span class="keyword">return</span> __distance_type(__i); &#125;</span><br></pre></td></tr></table></figure><h5 id="value-type"><a href="#value-type" class="headerlink" title="value_type"></a>value_type</h5><p>获取值类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Iter</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;_Iter&gt;::value_type*</span><br><span class="line">__value_type(<span class="keyword">const</span> _Iter&amp;)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> iterator_traits&lt;_Iter&gt;::value_type*&gt;(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Iter</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;_Iter&gt;::<span class="function">value_type*</span></span><br><span class="line"><span class="function"><span class="title">value_type</span><span class="params">(<span class="keyword">const</span> _Iter&amp; __i)</span> </span>&#123; <span class="keyword">return</span> __value_type(__i); &#125;</span><br></pre></td></tr></table></figure><h4 id="type-traits"><a href="#type-traits" class="headerlink" title="__type_traits"></a>__type_traits</h4><p>提供了一种机制，允许针对不同的类型属性，在编译时期完成函数派送(function dispatch)</p><h5 id="true-false"><a href="#true-false" class="headerlink" title="true/false"></a>true/false</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class 没有任何成员，不会带来额外负担，却又能够标示真假。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">true_type</span> &#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">false_type</span> &#123;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="基础traits定义"><a href="#基础traits定义" class="headerlink" title="基础traits定义"></a>基础traits定义</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span> &#123;</span> </span><br><span class="line">    <span class="keyword">typedef</span> __true_type     this_dummy_member_must_be_first;</span><br><span class="line">    <span class="keyword">typedef</span> __false_type    has_trivial_default_constructor;<span class="comment">//有 平凡 默认 构造函数</span></span><br><span class="line">    <span class="keyword">typedef</span> __false_type    has_trivial_copy_constructor;  <span class="comment">//有 平凡 拷贝构造函数</span></span><br><span class="line">    <span class="keyword">typedef</span> __false_type    has_trivial_assignment_operator;<span class="comment">//有 平凡 赋值操作</span></span><br><span class="line">    <span class="keyword">typedef</span> __false_type    has_trivial_destructor;<span class="comment">//有 平凡 析构函数</span></span><br><span class="line">    <span class="keyword">typedef</span> __false_type    is_POD_type;   <span class="comment">// Plain Old Data 是普通旧数据</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//默认均为false类型</span></span><br></pre></td></tr></table></figure><p>除了默认外，对传统数据类型进行了重载，进行重载的类型有:</p><blockquote><p><code>bool</code>、<code> char</code>  、<code>signed char</code>、<code>unsigned char</code>、<code>wchar_t</code>、<code>short</code>、<code>unsigned short</code>、<code>int</code>、<code>unsigned int</code>、<code>long</code>、<code>unsigned long</code>、<code>long long</code>、<code>unsigned long long</code>、<code>float</code>、<code>double</code>、<code>long double</code>、<code>char*</code>、<code>signed char*</code>、<code>unsigned char*</code>、<code>const char*</code>、<code>const signed char*</code>、<code>const unsigned char*</code>、<code>template &lt;class _Tp&gt; _Tp*</code></p></blockquote><p>以上类型默认<code>__type_traits</code>各成员均为<code>true</code></p><p>除此之外，关于数组大小的限制，要求是<code>int</code>型，故也有<code>_Is_integer</code>类型萃取。</p><blockquote><p><code>bool</code>、<code> char</code>  、<code>signed char</code>、<code>unsigned char</code>、<code>wchar_t</code>、<code>short</code>、<code>unsigned short</code>、<code>int</code>、<code>unsigned int</code>、<code>long</code>、<code>unsigned long</code>、<code>long long</code>、<code>unsigned long long</code></p></blockquote><h3 id="raw-storage-iterator"><a href="#raw-storage-iterator" class="headerlink" title="raw_storage_iterator"></a>raw_storage_iterator</h3><p>使标准算法可以将结果存储在未初始化的内存中。其相关基础定义如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIterator</span>, <span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">raw_storage_iterator</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    _ForwardIterator _M_iter;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> output_iterator_tag iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">void</span>                value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">void</span>                difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">void</span>                pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">void</span>                reference;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">raw_storage_iterator</span><span class="params">(_ForwardIterator __x)</span> : _M_iter(__x) &#123;</span>&#125;</span><br><span class="line">    raw_storage_iterator&amp; <span class="keyword">operator</span>*() &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    raw_storage_iterator&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> _Tp&amp; __element) &#123;</span><br><span class="line">        <span class="built_in">construct</span>(&amp;*_M_iter, __element);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;        </span><br><span class="line">    raw_storage_iterator&lt;_ForwardIterator, _Tp&gt;&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">        ++_M_iter;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    raw_storage_iterator&lt;_ForwardIterator, _Tp&gt; <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">        raw_storage_iterator&lt;_ForwardIterator, _Tp&gt; __tmp = *<span class="keyword">this</span>;</span><br><span class="line">        ++_M_iter;</span><br><span class="line">        <span class="keyword">return</span> __tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIterator</span>, <span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> output_iterator_tag</span></span><br><span class="line"><span class="function"><span class="title">iterator_category</span><span class="params">(<span class="keyword">const</span> raw_storage_iterator&lt;_ForwardIterator, _Tp&gt;&amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">output_iterator_tag</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a>auto_ptr</h3><p>前面说道 迭代器可以理解为智能指针，这里将介绍一下智能指针。</p><blockquote><p><code>auto_ptr</code>在c++11弃用，在c++17已移出</p></blockquote><h4 id="基础结构"><a href="#基础结构" class="headerlink" title="基础结构"></a>基础结构</h4><p>进行封装后的原生指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span> <span class="class"><span class="keyword">class</span> <span class="title">auto_ptr</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    _Tp* _M_ptr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _Tp element_type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p><code>explicit</code>关键字用于防止隐式类型转换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">auto_ptr</span><span class="params">(_Tp* __p = <span class="number">0</span>)</span> __STL_NOTHROW : _M_ptr(__p) &#123;</span>&#125;</span><br><span class="line"><span class="built_in">auto_ptr</span>(auto_ptr&amp; __a) __STL_NOTHROW : _M_ptr(__a.<span class="built_in">release</span>()) &#123;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp1</span>&gt;</span> <span class="built_in">auto_ptr</span>(auto_ptr&lt;_Tp1&gt;&amp; __a) __STL_NOTHROW  : _M_ptr(__a.<span class="built_in">release</span>()) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">_Tp* <span class="title">release</span><span class="params">()</span> __STL_NOTHROW </span>&#123;</span><br><span class="line">    _Tp* __tmp = _M_ptr;</span><br><span class="line">    _M_ptr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> __tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="拷贝赋值"><a href="#拷贝赋值" class="headerlink" title="拷贝赋值"></a>拷贝赋值</h4><p>后续实现的功能除有<code>__STL_NOTHROW</code>修饰外，即正常实现，不过多叙述</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">auto_ptr&amp; <span class="keyword">operator</span>=(auto_ptr&amp; __a) __STL_NOTHROW &#123;</span><br><span class="line">    <span class="keyword">if</span> (&amp;__a != <span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> _M_ptr;</span><br><span class="line">        _M_ptr = __a.<span class="built_in">release</span>();</span><br><span class="line">    &#125;<span class="comment">//防止自赋值导致 先资源释放 后 无法赋值</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp1</span>&gt;</span></span><br><span class="line">auto_ptr&amp; <span class="keyword">operator</span>=(auto_ptr&lt;_Tp1&gt;&amp; __a) __STL_NOTHROW &#123;</span><br><span class="line">    <span class="keyword">if</span> (__a.<span class="built_in">get</span>() != <span class="keyword">this</span>-&gt;<span class="built_in">get</span>()) &#123;</span><br><span class="line">        <span class="keyword">delete</span> _M_ptr;</span><br><span class="line">        _M_ptr = __a.<span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">_Tp* <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> __STL_NOTHROW </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _M_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="iterator-adapter"><a href="#iterator-adapter" class="headerlink" title="iterator  adapter"></a>iterator  adapter</h3><h4 id="back-insert-iterator"><a href="#back-insert-iterator" class="headerlink" title="back_insert_iterator"></a>back_insert_iterator</h4><p>用于在指定容器的末尾处添加新元素。它的唯一数据成员是指向容器的指针，不指向容器内的任何元素，故<code>++</code>操作对其没有意义。由于它会调用底层容器的<code>push_back()</code>函数，故其只适用于含有该函数的容器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Container</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">back_insert_iterator</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    _Container* container;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _Container          container_type;  <span class="comment">//所包含的容器类型</span></span><br><span class="line">    <span class="keyword">typedef</span> output_iterator_tag iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">void</span>                value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">void</span>                difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">void</span>                pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">void</span>                reference;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">back_insert_iterator</span><span class="params">(_Container&amp; __x)</span> : container(&amp;__x) &#123;</span>&#125;</span><br><span class="line">back_insert_iterator&lt;_Container&gt;&amp;</span><br><span class="line"><span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">typename</span> _Container::value_type&amp; __value) &#123; </span><br><span class="line">    container-&gt;<span class="built_in">push_back</span>(__value);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;<span class="comment">//调用底层容器的push_back</span></span><br><span class="line">back_insert_iterator&lt;_Container&gt;&amp; <span class="keyword">operator</span>*() &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">back_insert_iterator&lt;_Container&gt;&amp; <span class="keyword">operator</span>++() &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">back_insert_iterator&lt;_Container&gt;&amp; <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line"><span class="comment">//++运算符直接返回自身，能使用但并未指向下一个。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __STL_CLASS_PARTIAL_SPECIALIZATION</span></span><br><span class="line"><span class="comment">//基础iterator类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Container</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> output_iterator_tag</span></span><br><span class="line"><span class="function"><span class="title">iterator_category</span><span class="params">(<span class="keyword">const</span> back_insert_iterator&lt;_Container&gt;&amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">output_iterator_tag</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __STL_CLASS_PARTIAL_SPECIALIZATION */</span></span></span><br><span class="line"><span class="comment">//对外接口 传入的是支持push_back的容器 如 vector</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Container</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> back_insert_iterator&lt;_Container&gt; <span class="title">back_inserter</span><span class="params">(_Container&amp; __x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> back_insert_iterator&lt;_Container&gt;(__x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="front-insert-iterator"><a href="#front-insert-iterator" class="headerlink" title="front_insert_iterator"></a>front_insert_iterator</h4><p>除了只能调用<code>push_front()</code>函数与<code>back_insert_iterator</code>完全一致。也提供对外接口<code>front_inserter</code></p><h4 id="insert-iterator"><a href="#insert-iterator" class="headerlink" title="insert_iterator"></a>insert_iterator</h4><p>该适配器允许在任意位置插入元素。故其底层比头插、尾插的类模板多一个迭代器用来调整插入位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Container</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">insert_iterator</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    _Container* container;</span><br><span class="line">    <span class="keyword">typename</span> _Container::iterator iter;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同样的，对外接口<code>inserter</code>除了要传容器外，还需要传一个迭代器（指明插入位置）</p><h4 id="reverse-bidirectional-iterator"><a href="#reverse-bidirectional-iterator" class="headerlink" title="reverse_bidirectional_iterator"></a>reverse_bidirectional_iterator</h4><p>双向翻转迭代器，可双向访问。<code>++  -- </code>和实际恰好相反。<code>*iter</code>原本返回的是左侧元素，现在也随之翻转，返回右侧。由于是<code>bidirectional_iterator_tag</code>的翻转版，仅支持<mark>单步移动</mark>（类似于list）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">reverse_bidirectional_iterator</span> &#123;</span></span><br><span class="line"><span class="keyword">typedef</span> reverse_bidirectional_iterator</span><br><span class="line">            &lt;_BidirectionalIterator, _Tp, _Reference, _Distance&gt;  _Self;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    _BidirectionalIterator current;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp                        value_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Distance                  difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp*                       pointer;</span><br><span class="line">    <span class="keyword">typedef</span> _Reference                 reference;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">reverse_bidirectional_iterator</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">reverse_bidirectional_iterator</span><span class="params">(_BidirectionalIterator __x)</span></span></span><br><span class="line"><span class="function">      : current(__x) &#123;</span>&#125;</span><br><span class="line">    <span class="function">_BidirectionalIterator <span class="title">base</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> current; &#125;<span class="comment">//不打破封装得到底层</span></span><br><span class="line">    _Reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;</span><br><span class="line">      _BidirectionalIterator __tmp = current;</span><br><span class="line">      <span class="keyword">return</span> *--__tmp;</span><br><span class="line">  &#125;<span class="comment">//正常end()的返回形式，不过--已重载</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SGI_STL_NO_ARROW_OPERATOR</span></span><br><span class="line">    pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __SGI_STL_NO_ARROW_OPERATOR */</span></span></span><br><span class="line">    _Self&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">      --current;</span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;<span class="comment">//反向移动</span></span><br><span class="line">    _Self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">        _Self __tmp = *<span class="keyword">this</span>;</span><br><span class="line">        --current;</span><br><span class="line">        <span class="keyword">return</span> __tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    _Self&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">        ++current;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _Self <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123;</span><br><span class="line">        _Self __tmp = *<span class="keyword">this</span>;</span><br><span class="line">        ++current;</span><br><span class="line">        <span class="keyword">return</span> __tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//迭代器类型 bidirectional_iterator_tag</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIterator</span>, <span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Reference</span>, <span class="keyword">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> bidirectional_iterator_tag <span class="title">iterator_category</span><span class="params">(<span class="keyword">const</span> reverse_bidirectional_iterator</span></span></span><br><span class="line"><span class="params"><span class="function">                                                    &lt;_BidirectionalIterator, _Tp, _Reference, _Distance&gt;&amp;)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bidirectional_iterator_tag</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//value_type</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIterator</span>, <span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Reference</span>, <span class="keyword">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> _Tp* <span class="title">value_type</span><span class="params">(<span class="keyword">const</span> reverse_bidirectional_iterator</span></span></span><br><span class="line"><span class="params"><span class="function">           &lt;_BidirectionalIterator, _Tp,_Reference, _Distance&gt;&amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (_Tp*) <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//distance_type</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIterator</span>, <span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Reference</span>, <span class="keyword">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> _Distance* <span class="title">distance_type</span><span class="params">(<span class="keyword">const</span> reverse_bidirectional_iterator</span></span></span><br><span class="line"><span class="params"><span class="function">              &lt;_BidirectionalIterator, _Tp,_Reference, _Distance&gt;&amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (_Distance*) <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运算符重载 ==</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BiIter</span>, <span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Ref</span>, <span class="keyword">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(</span><br><span class="line">    <span class="keyword">const</span> reverse_bidirectional_iterator&lt;_BiIter, _Tp, _Ref, _Distance&gt;&amp; __x, </span><br><span class="line">    <span class="keyword">const</span> reverse_bidirectional_iterator&lt;_BiIter, _Tp, _Ref, _Distance&gt;&amp; __y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> __x.<span class="built_in">base</span>() == __y.<span class="built_in">base</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同理 还重载了!= 返回为 !(x==y)</span></span><br></pre></td></tr></table></figure><h4 id="reverse-iterator"><a href="#reverse-iterator" class="headerlink" title="reverse_iterator"></a>reverse_iterator</h4><p>同样，是双向均翻转的迭代器。</p><p>与<code>reverse_bidirectional_iterator</code>不同的是其翻转的是<code>random_access_iterator_tag</code>，故支持移动多个位置及随机访问。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">_Self <span class="keyword">operator</span>+(_Distance __n) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _Self(current - __n);</span><br><span class="line">&#125;</span><br><span class="line">_Self&amp; <span class="keyword">operator</span>+=(_Distance __n) &#123;</span><br><span class="line">    current -= __n;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">_Self <span class="keyword">operator</span>-(_Distance __n) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _Self(current + __n);</span><br><span class="line">&#125;</span><br><span class="line">_Self&amp; <span class="keyword">operator</span>-=(_Distance __n) &#123;</span><br><span class="line">    current += __n;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">_Reference <span class="keyword">operator</span>[](_Distance __n) <span class="keyword">const</span> &#123; <span class="keyword">return</span> *(*<span class="keyword">this</span> + __n); &#125;</span><br></pre></td></tr></table></figure><h4 id="istream-iterator"><a href="#istream-iterator" class="headerlink" title="istream_iterator"></a>istream_iterator</h4><p>将迭代器绑定到一个 <code>istream </code>对象上，使之具备输入能力。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Dist</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">istream_iterator</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    istream* _M_stream;</span><br><span class="line">    _Tp _M_value;</span><br><span class="line">    <span class="keyword">bool</span> _M_end_marker;</span><br><span class="line">    <span class="keyword">void</span> _M_read() &#123;</span><br><span class="line">        _M_end_marker = (*_M_stream) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (_M_end_marker) *_M_stream &gt;&gt; _M_value;</span><br><span class="line">        _M_end_marker = (*_M_stream) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">istream_iterator</span>() : _M_stream(&amp;cin), _M_end_marker(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">istream_iterator</span>(istream&amp; __s) : _M_stream(&amp;__s) &#123; _M_read(); &#125;</span><br><span class="line">    reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> _M_value; &#125;</span><br><span class="line">    pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//迭代器类型 input_iterator_tag</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Dist</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> input_iterator_tag  <span class="title">iterator_category</span><span class="params">(<span class="keyword">const</span> istream_iterator&lt;_Tp, _Dist&gt;&amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">input_iterator_tag</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="ostream-iterator"><a href="#ostream-iterator" class="headerlink" title="ostream_iterator"></a>ostream_iterator</h4><p>将迭代器绑定到一个 <code>ostream </code>对象上，使之具备输出能力。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ostream_iterator</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    ostream* _M_stream;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* _M_string;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ostream_iterator</span>(ostream&amp; __s) : _M_stream(&amp;__s), _M_string(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ostream_iterator</span>(ostream&amp; __s, <span class="keyword">const</span> <span class="keyword">char</span>* __c) </span><br><span class="line">        : _M_stream(&amp;__s), _M_string(__c)  &#123;&#125;</span><br><span class="line">    ostream_iterator&lt;_Tp&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> _Tp&amp; __value) &#123; </span><br><span class="line">        *_M_stream &lt;&lt; __value;</span><br><span class="line">        <span class="keyword">if</span> (_M_string) *_M_stream &lt;&lt; _M_string;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="istreambuf-iterator"><a href="#istreambuf-iterator" class="headerlink" title="istreambuf_iterator"></a>istreambuf_iterator</h4><p>由于<code>isteam_iterator</code>采用<code>operator&gt;&gt;</code>来读取，而<code>operator&gt;&gt;</code>会忽略<code>空格</code>。因此考虑直接在缓冲区中读取。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">CharT</span>, <span class="keyword">class</span> _<span class="title">Traits</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">istreambuf_iterator</span></span></span><br><span class="line"><span class="class">    :</span> <span class="keyword">public</span> iterator&lt;input_iterator_tag, _CharT,</span><br><span class="line"><span class="keyword">typename</span> _Traits::off_type, _CharT*, _CharT&amp;&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _CharT                           char_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Traits                          traits_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Traits::int_type       int_type;</span><br><span class="line">    <span class="keyword">typedef</span> basic_streambuf&lt;_CharT, _Traits&gt; streambuf_type;</span><br><span class="line">    <span class="keyword">typedef</span> basic_istream&lt;_CharT, _Traits&gt;   istream_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//赋值及*iter</span></span><br><span class="line">    <span class="built_in">istreambuf_iterator</span>(streambuf_type* __p = <span class="number">0</span>) &#123; <span class="keyword">this</span>-&gt;_M_init(__p); &#125;</span><br><span class="line">    <span class="built_in">istreambuf_iterator</span>(istream_type&amp; __is) &#123; <span class="keyword">this</span>-&gt;_M_init(__is.<span class="built_in">rdbuf</span>()); &#125;</span><br><span class="line">    char_type <span class="keyword">operator</span>*() <span class="keyword">const</span> </span><br><span class="line">    &#123; <span class="keyword">return</span> _M_is_initialized ? _M_c : _M_dereference_aux(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    streambuf_type* _M_buf;</span><br><span class="line">    <span class="keyword">mutable</span> _CharT _M_c;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">bool</span> _M_eof : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">bool</span> _M_is_initialized : <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">CharT</span>, <span class="keyword">class</span> _<span class="title">Traits</span>&gt;</span></span><br><span class="line">_CharT istreambuf_iterator&lt;_CharT, _Traits&gt;::_M_dereference_aux() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_M_getc();<span class="comment">//getc函数获取到缓冲区内容</span></span><br><span class="line">    <span class="keyword">return</span> _M_c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//++</span></span><br><span class="line">istreambuf_iterator&amp; <span class="keyword">operator</span>++() &#123; <span class="keyword">this</span>-&gt;_M_nextc(); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">istreambuf_iterator  <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_M_is_initialized)</span><br><span class="line">        _M_postincr_aux();</span><br><span class="line">    istreambuf_iterator __tmp = *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_M_nextc();</span><br><span class="line">    <span class="keyword">return</span> __tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _M_nextc() &#123;</span><br><span class="line">    int_type __c = _M_buf-&gt;<span class="built_in">snextc</span>();</span><br><span class="line">    _M_c = traits_type::<span class="built_in">to_char_type</span>(__c);    </span><br><span class="line">    _M_eof = traits_type::<span class="built_in">eq_int_type</span>(__c, traits_type::<span class="built_in">eof</span>());</span><br><span class="line">    _M_is_initialized = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="mutable关键字"><a href="#mutable关键字" class="headerlink" title="mutable关键字"></a>mutable关键字</h5><p>在<code>const</code>函数中，原则上不能够修改任意变量值。而如果变量是<code>mutable</code>关键字修饰时，则可以在<code>const</code>函数中进行修改。</p><blockquote><p>mutable只能够用于一个类的非静态数据成员</p></blockquote><h4 id="ostreambuf-iterator"><a href="#ostreambuf-iterator" class="headerlink" title="ostreambuf_iterator"></a>ostreambuf_iterator</h4><p>同理，将数据流出至缓冲区。无<code>++</code>运算符（返回自身）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">CharT</span>, <span class="keyword">class</span> _<span class="title">Traits</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ostreambuf_iterator</span></span></span><br><span class="line"><span class="class">:</span> <span class="keyword">public</span> iterator&lt;output_iterator_tag, <span class="keyword">void</span>, <span class="keyword">void</span>, <span class="keyword">void</span>, <span class="keyword">void</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _CharT                           char_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Traits                          traits_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Traits::int_type       int_type;</span><br><span class="line">    <span class="keyword">typedef</span> basic_streambuf&lt;_CharT, _Traits&gt; streambuf_type;</span><br><span class="line">    <span class="keyword">typedef</span> basic_ostream&lt;_CharT, _Traits&gt;   ostream_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ostreambuf_iterator</span>(streambuf_type* __buf) : _M_buf(__buf), _M_ok(__buf) &#123;&#125;</span><br><span class="line">    <span class="built_in">ostreambuf_iterator</span>(ostream_type&amp; __o)</span><br><span class="line">        : _M_buf(__o.<span class="built_in">rdbuf</span>()), _M_ok(__o.<span class="built_in">rdbuf</span>() != <span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ostreambuf_iterator&amp; <span class="keyword">operator</span>=(char_type __c) &#123;</span><br><span class="line">        _M_ok = _M_ok &amp;&amp; !traits_type::<span class="built_in">eq_int_type</span>(_M_buf-&gt;<span class="built_in">sputc</span>(__c),</span><br><span class="line">                                                   traits_type::<span class="built_in">eof</span>());</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">  </span><br><span class="line">    ostreambuf_iterator&amp; <span class="keyword">operator</span>*()     &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    ostreambuf_iterator&amp; <span class="keyword">operator</span>++()    &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    ostreambuf_iterator&amp; <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">failed</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> !_M_ok; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    streambuf_type* _M_buf;</span><br><span class="line">    <span class="keyword">bool</span> _M_ok;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> SGI_STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL源码-分配器</title>
      <link href="/STL%E6%BA%90%E7%A0%81-%E5%88%86%E9%85%8D%E5%99%A8/"/>
      <url>/STL%E6%BA%90%E7%A0%81-%E5%88%86%E9%85%8D%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>本文是阅读<code>SGI STL</code>源码中关于<code>allocator</code>部分的笔记</p><p>同样，本文仍然是建立在已经观看过<a href="https://endgame.cc/2022/06/23/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">侯捷老师STL源码剖析课程</a>的基础上。是在阅读源码过程中，对其中的内容进行补充、修饰。</p><span id="more"></span><h2 id="Allocator"><a href="#Allocator" class="headerlink" title="Allocator"></a>Allocator</h2><p>从实现的角度来看，配置器是一个实现了动态空间配置、空间管理、空间释放的 class template。</p><h3 id="defalloc-h"><a href="#defalloc-h" class="headerlink" title="defalloc.h"></a>defalloc.h</h3><p>标准的空间分配器。只是实现了基层的分配、释放行为（<code>operator new</code> 和 <code>operator delete</code>封装），并没有进行优化</p><h4 id="allocate-deallocate"><a href="#allocate-deallocate" class="headerlink" title="allocate/deallocate"></a>allocate/deallocate</h4><p>基础的分配、释放函数，只是简单的封装了一下<code>operator new</code> 和 <code>operator delete</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> T* <span class="title">allocate</span><span class="params">(<span class="keyword">ptrdiff_t</span> size, T*)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set_new_handler</span>(<span class="number">0</span>);   <span class="comment">// 为了卸载目前的内存分配异常处理函数，强制C++在内存不够的时候抛出std:bad_alloc。</span></span><br><span class="line">    <span class="comment">// 申请size个T类型大小的空间</span></span><br><span class="line">    T* tmp = (T*)(::<span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span>((<span class="keyword">size_t</span>)(size * <span class="built_in"><span class="keyword">sizeof</span></span>(T))));</span><br><span class="line">    <span class="keyword">if</span> (tmp == <span class="number">0</span>) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;out of memory&quot;</span> &lt;&lt; endl; </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(T* buffer)</span> </span>&#123;</span><br><span class="line">    ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(buffer)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="class-allocator"><a href="#class-allocator" class="headerlink" title="class allocator"></a>class allocator</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pointer <span class="title">allocate</span><span class="params">(size_type n)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> ::<span class="built_in">allocate</span>((difference_type)n, (pointer)<span class="number">0</span>);</span><br><span class="line">&#125;<span class="comment">//分配空间，调用上面封装后的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(pointer p)</span> </span>&#123; ::<span class="built_in">deallocate</span>(p); &#125;</span><br><span class="line"><span class="function">pointer <span class="title">address</span><span class="params">(reference x)</span> </span>&#123; <span class="keyword">return</span> (pointer)&amp;x; &#125;<span class="comment">//获取地址</span></span><br><span class="line"><span class="function">const_pointer <span class="title">const_address</span><span class="params">(const_reference x)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> (const_pointer)&amp;x; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">size_type <span class="title">init_page_size</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">size_type</span>(<span class="number">1</span>), <span class="built_in">size_type</span>(<span class="number">4096</span>/<span class="built_in"><span class="keyword">sizeof</span></span>(T))); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">size_type</span>(<span class="number">1</span>), <span class="built_in">size_type</span>(UINT_MAX/<span class="built_in"><span class="keyword">sizeof</span></span>(T))); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="stl-construct-h"><a href="#stl-construct-h" class="headerlink" title="stl_construct.h"></a>stl_construct.h</h3><p>在上述基础上，对对象的构造和析构进行了一定的封装。</p><h4 id="construct"><a href="#construct" class="headerlink" title="construct"></a>construct</h4><p>构造函数除基本的调用外无重要的点。基本调用的函数为<code>inline void _Construct(_T1* __p, const _T2&amp; __value) &#123; new ((void*) __p) _T1(__value); &#125;</code></p><h4 id="destroy"><a href="#destroy" class="headerlink" title="destroy"></a>destroy</h4><p>首先调用萃取机判断是否有析构函数，然后根据反馈分别调用相应的函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;_Tp&gt;::has_trivial_destructor _Trivial_destructor;</span><br><span class="line"><span class="comment">// 若是 __true_type，什么都不做；这是 trivial destructor。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIterator</span>&gt;</span> </span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __destroy_aux(_ForwardIterator, _ForwardIterator, __true_type) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若是 __false_type，这才以循环的方式遍历整个范围，并在循环中每经历一个对象就调用其destory()。（内部调用析构函数）</span></span><br><span class="line"><span class="comment">// 这是 non-trivial destructor</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> __destroy_aux(_ForwardIterator __first, _ForwardIterator __last, __false_type)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; __first != __last; ++__first)</span><br><span class="line">        <span class="built_in">destroy</span>(&amp;*__first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，还有一些特化版本（非类，无需过多特殊处理）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Destroy(<span class="keyword">char</span>*, <span class="keyword">char</span>*) &#123;&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Destroy(<span class="keyword">int</span>*, <span class="keyword">int</span>*) &#123;&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Destroy(<span class="keyword">long</span>*, <span class="keyword">long</span>*) &#123;&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Destroy(<span class="keyword">float</span>*, <span class="keyword">float</span>*) &#123;&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Destroy(<span class="keyword">double</span>*, <span class="keyword">double</span>*) &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="stl-uninitialized-h"><a href="#stl-uninitialized-h" class="headerlink" title="stl_uninitialized.h"></a>stl_uninitialized.h</h3><p>该部分用于copy、fill大块内存中存储的数据。同样的</p><h4 id="uninitialized-copy"><a href="#uninitialized-copy" class="headerlink" title="uninitialized_copy"></a>uninitialized_copy</h4><p>该函数实现<code>copy</code>功能，首先调用萃取机判断是否是POD（传统 旧 数据）数据类型<code> typedef typename __type_traits&lt;_Tp&gt;::is_POD_type _Is_POD;</code>，然后根据返回的结果调用不同的函数<code> return __uninitialized_copy_aux(__first, __last, __result, _Is_POD());</code>。传统旧数据无需过多操作，直接复制即可。否则，循环调用相应的函数进行构造。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="keyword">class</span> _<span class="title">ForwardIter</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> _ForwardIter __uninitialized_copy_aux(_InputIter __first, _InputIter __last,</span><br><span class="line">                         _ForwardIter __result,</span><br><span class="line">                         __true_type)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">copy</span>(__first, __last, __result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="keyword">class</span> _<span class="title">ForwardIter</span>&gt;</span></span><br><span class="line">_ForwardIter  __uninitialized_copy_aux(_InputIter __first, _InputIter __last,</span><br><span class="line">                         _ForwardIter __result,</span><br><span class="line">                         __false_type)</span><br><span class="line">&#123;</span><br><span class="line">    _ForwardIter __cur = __result;</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">        <span class="keyword">for</span> ( ; __first != __last; ++__first, ++__cur)</span><br><span class="line">            _Construct(&amp;*__cur, *__first);</span><br><span class="line">        <span class="keyword">return</span> __cur;</span><br><span class="line">    &#125;</span><br><span class="line">    __STL_UNWIND(_Destroy(__result, __cur));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="uninitialized-fill"><a href="#uninitialized-fill" class="headerlink" title="uninitialized_fill"></a>uninitialized_fill</h4><p>该函数与上述函数同理，所使用的<code>is_POS_type</code>及相关处理策略也相同，再此不赘述。</p><h4 id="uninitialized-copy-copy"><a href="#uninitialized-copy-copy" class="headerlink" title="__uninitialized_copy_copy"></a>__uninitialized_copy_copy</h4><p>该函数实现两个范围的拷贝，即为调用两次<code>uninitialized_copy</code>函数。函数源码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter1</span>, <span class="keyword">class</span> _<span class="title">InputIter2</span>, <span class="keyword">class</span> _<span class="title">ForwardIter</span>&gt;</span></span><br><span class="line">    <span class="keyword">inline</span> _ForwardIter</span><br><span class="line">    __uninitialized_copy_copy(_InputIter1 __first1, _InputIter1 __last1,</span><br><span class="line">                              _InputIter2 __first2, _InputIter2 __last2,</span><br><span class="line">                              _ForwardIter __result)</span><br><span class="line">&#123;</span><br><span class="line">    _ForwardIter __mid = <span class="built_in">uninitialized_copy</span>(__first1, __last1, __result);</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">uninitialized_copy</span>(__first2, __last2, __mid);</span><br><span class="line">    &#125;</span><br><span class="line">    __STL_UNWIND(_Destroy(__result, __mid));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所实现的功能为拷贝两次。在<code>result</code>位置，先插入第一个范围，再在新的位置继续插第二个范围。即:</p><ol><li>首先将$\left[first1,last1\right)$数据拷贝到$\left[result,result+last1-first1\right)$</li><li>然后，再将$\left[first2,last2\right)$数据拷贝到$\left[result+last1-first1,result+last1-first1+last2-first2\right)$</li></ol><h3 id="stl-alloc-h"><a href="#stl-alloc-h" class="headerlink" title="stl_alloc.h"></a>stl_alloc.h</h3><p>定义了一、二级配置器，配置器名为 alloc。设计宗旨：</p><ul><li>向 system heap 要求空间</li><li>考虑多线程(multi-threads)状态</li><li>考虑内存不足时的应变措施</li><li>考虑过多 “小型区块” 可能造成的内存碎片问题</li></ul><h4 id="class-malloc-alloc-template"><a href="#class-malloc-alloc-template" class="headerlink" title="class __malloc_alloc_template"></a>class __malloc_alloc_template</h4><p>第一级配置器，没有模板参数。</p><p><code>allocate  deallocate  reallocate</code>直接调用<code>malloc free realloc</code>。当<mark>可用空间不足</mark>时，调用相应的函数处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">malloc_alloc_template</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下函数将用来处理内存不足的情况</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span>* _S_oom_malloc(<span class="keyword">size_t</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span>* _S_oom_realloc(<span class="keyword">void</span>*, <span class="keyword">size_t</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(* __malloc_alloc_oom_handler)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一级配置器直接调用 malloc()</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">void</span>* __result = <span class="built_in">malloc</span>(__n);</span><br><span class="line">        <span class="comment">// 以下无法满足需求时，改用 _S_oom_malloc()</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == __result) __result = _S_oom_malloc(__n);</span><br><span class="line">        <span class="keyword">return</span> __result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第一级配置器直接调用 free()</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> <span class="comment">/* __n */</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">free</span>(__p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第一级配置器直接调用 realloc()</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">reallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> <span class="comment">/* old_sz */</span>, <span class="keyword">size_t</span> __new_sz)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">void</span>* __result = <span class="built_in">realloc</span>(__p, __new_sz);</span><br><span class="line">        <span class="comment">// 以下无法满足需求时，改用 _S_oom_realloc()</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == __result) __result = _S_oom_realloc(__p, __new_sz);</span><br><span class="line">        <span class="keyword">return</span> __result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以下仿真 C++ 的 set_new_handler()，可以通过它指定自己的 out-of-memory handler</span></span><br><span class="line">    <span class="comment">// 为什么不使用 C++ new-handler 机制，因为第一级配置器并没有 ::operator new 来配置内存</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(* __set_malloc_handler(<span class="keyword">void</span> (*__f)()))</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">void</span></span> (* __old)() = __malloc_alloc_oom_handler;</span><br><span class="line">        __malloc_alloc_oom_handler = __f;</span><br><span class="line">        <span class="keyword">return</span>(__old);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="S-oom-malloc-amp-S-oom-realloc"><a href="#S-oom-malloc-amp-S-oom-realloc" class="headerlink" title="_S_oom_malloc &amp; _S_oom_realloc"></a>_S_oom_malloc &amp; _S_oom_realloc</h5><p>这两个函数在一级分配器可用空间不足时调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">void</span>* __malloc_alloc_template&lt;__inst&gt;::_S_oom_malloc(<span class="keyword">size_t</span> __n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (* __my_malloc_handler)();</span><br><span class="line">    <span class="keyword">void</span>* __result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不断尝试释放、配置</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        __my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == __my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125;</span><br><span class="line">        (*__my_malloc_handler)();  <span class="comment">// 调用处理例程，企图释放内存</span></span><br><span class="line">        __result = <span class="built_in">malloc</span>(__n);   <span class="comment">// 再次尝试配置内存</span></span><br><span class="line">        <span class="keyword">if</span> (__result) <span class="keyword">return</span>(__result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">void</span>* __malloc_alloc_template&lt;__inst&gt;::_S_oom_realloc(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (* __my_malloc_handler)();</span><br><span class="line">    <span class="keyword">void</span>* __result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  给一个已经分配了地址的指针重新分配空间，参数 __p 为原有的空间地址，__n 是重新申请的地址长度</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 当 &quot;内存不足处理例程&quot; 并未被客户设定，便调用 __THROW_BAD_ALLOC，丢出 bad_alloc 异常信息</span></span><br><span class="line">        __my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == __my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125;</span><br><span class="line">        (*__my_malloc_handler)();   <span class="comment">// 调用处理例程，企图释放内存</span></span><br><span class="line">        __result = <span class="built_in">realloc</span>(__p, __n);  <span class="comment">// 再次尝试配置内存，扩大内存大小</span></span><br><span class="line">        <span class="keyword">if</span> (__result) <span class="keyword">return</span>(__result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码中我们可以看出，当内存不足时抛出异常<code>__THROW_BAD_ALLOC</code>。</p><h5 id="malloc-alloc-oom-handler"><a href="#malloc-alloc-oom-handler" class="headerlink" title="__malloc_alloc_oom_handler"></a>__malloc_alloc_oom_handler</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="built_in"><span class="keyword">void</span></span> (* __malloc_alloc_template&lt;__inst&gt;::__malloc_alloc_oom_handler)() = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h4 id="simple-alloc"><a href="#simple-alloc" class="headerlink" title="simple_alloc"></a>simple_alloc</h4><p>该类附加了<code>0  nullptr</code>的检查，主要是为上述实现的功能提供对外接口。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">simple_alloc</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 配置 n 个元素</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> _Tp* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">        </span>&#123; <span class="keyword">return</span> <span class="number">0</span> == __n ? <span class="number">0</span> : (_Tp*) _Alloc::<span class="built_in">allocate</span>(__n * <span class="built_in"><span class="keyword">sizeof</span></span> (_Tp)); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> _Tp* <span class="title">allocate</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">        </span>&#123; <span class="keyword">return</span> (_Tp*) _Alloc::<span class="built_in">allocate</span>(<span class="built_in"><span class="keyword">sizeof</span></span> (_Tp)); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(_Tp* __p, <span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">        </span>&#123; <span class="keyword">if</span> (<span class="number">0</span> != __n) _Alloc::<span class="built_in">deallocate</span>(__p, __n * <span class="built_in"><span class="keyword">sizeof</span></span> (_Tp)); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(_Tp* __p)</span></span></span><br><span class="line"><span class="function">        </span>&#123; _Alloc::<span class="built_in">deallocate</span>(__p, <span class="built_in"><span class="keyword">sizeof</span></span> (_Tp)); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="debug-alloc"><a href="#debug-alloc" class="headerlink" title="debug_alloc"></a>debug_alloc</h4><p>为方便调试，每次分配多分配<code>8Bytes</code>空间，用来存储当前所分配的空间大小。</p><p>多分配的空间在头部存储，返回的是数据的首部，而非从<code>_S_extra</code>开始。故，需要注意的是，当调用<code>deallocate  reallocate</code>时，需要前移找到真正的头部。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span>_S_extra = <span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="default-alloc-template"><a href="#default-alloc-template" class="headerlink" title="__default_alloc_template"></a>__default_alloc_template</h4><p>第二级配置器，GCC 默认使用第二级配置器，其作用是避免太多小额区块造成内存的碎片。</p><p>第二级配置器使用 memory pool 内存池管理。</p><p>第二级配置器的原理：</p><ul><li>当配置区块超过 128 bytes，就使用第一级配置器</li></ul><ul><li>当配置区块小于 128 bytes，使用内存池管理</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span>_ALIGN = <span class="number">8</span>&#125;;  <span class="comment">// 小型区块的上调边界</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span>_MAX_BYTES = <span class="number">128</span>&#125;; <span class="comment">// 小区区块的上限</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span>_NFREELISTS = <span class="number">16</span>&#125;; <span class="comment">// _MAX_BYTES/_ALIGN  free-list 的个数</span></span><br></pre></td></tr></table></figure><p>关于使用<code>enum</code>去定义一些常量，源码中给出的解释：</p><blockquote><p>Really we should use static const int x = N instead of enum { x = N }, but few compilers accept the former.</p></blockquote><h5 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h5><p>将小额区块内存需求量调至8的倍数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> _S_round_up(<span class="keyword">size_t</span> __bytes) </span><br><span class="line">&#123; <span class="keyword">return</span> (((__bytes) + (<span class="keyword">size_t</span>) _ALIGN<span class="number">-1</span>) &amp; ~((<span class="keyword">size_t</span>) _ALIGN - <span class="number">1</span>)); &#125;</span><br></pre></td></tr></table></figure><ul><li><code>&amp; ~((size_t) _ALIGN - 1)</code>。实现取8的倍数  $8-1 = 0000\dots111_{2}$，取反为$11111…1000_{2}$，当与这个数字进行<mark>与操作</mark>时，原始数字的低三位全部丢弃（剩余位数均为8的整数倍，即为8的倍数。）</li><li><code>(__bytes) + (size_t) _ALIGN-1)</code>。为防止取整数倍时，不足以凑成8的部分会被省略，故采取+7后再进行与操作。</li></ul><h4 id="free-list结点"><a href="#free-list结点" class="headerlink" title="free-list结点"></a>free-list结点</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> _<span class="title">Obj</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">Obj</span>* _<span class="title">M_free_list_link</span>;</span>  <span class="comment">// 利用联合体特点</span></span><br><span class="line">    <span class="keyword">char</span> _M_client_data[<span class="number">1</span>];    <span class="comment">/* The client sees this.        */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> _Obj* __STL_VOLATILE _S_free_list[_NFREELISTS];</span><br><span class="line"><span class="comment">// 维护 16 个空闲链表(free list)，初始化为0，即每个链表中都没有空闲数据块</span></span><br></pre></td></tr></table></figure><p>每个内存块分别去管理$8,16,24,32\dots,128 $Bytes</p><h5 id="寻找空闲链表"><a href="#寻找空闲链表" class="headerlink" title="寻找空闲链表"></a>寻找空闲链表</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据申请数据块大小找到相应空闲链表的下标，n 从 0 起算</span></span><br><span class="line"><span class="keyword">static</span>  <span class="keyword">size_t</span> _S_freelist_index(<span class="keyword">size_t</span> __bytes) &#123;</span><br><span class="line">    <span class="keyword">return</span> (((__bytes) + (<span class="keyword">size_t</span>)_ALIGN<span class="number">-1</span>)/(<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="allocate"><a href="#allocate" class="headerlink" title="allocate"></a>allocate</h4><p>申请内存时，首先判断所申请的内存空间是否超过<code>128 Bytes</code>（链表块中能存放的最大空间）。不超过则在内存池中分配，超过调用一级分配器去分配。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* __ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需求区块大于 128 bytes，就转调用第一级配置</span></span><br><span class="line">    <span class="keyword">if</span> (__n &gt; (<span class="keyword">size_t</span>) _MAX_BYTES) &#123;</span><br><span class="line">        __ret = malloc_alloc::<span class="built_in">allocate</span>(__n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 根据申请空间的大小寻找相应的空闲链表（16个空闲链表中的一个）</span></span><br><span class="line">        _Obj* __STL_VOLATILE* __my_free_list = _S_free_list + _S_freelist_index(__n);</span><br><span class="line">        <span class="comment">// Acquire the lock here with a constructor call.</span></span><br><span class="line">        <span class="comment">// This ensures that it is released in exit or during stack</span></span><br><span class="line">        <span class="comment">// unwinding.</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">ifndef</span> _NOTHREADS</span></span><br><span class="line">        <span class="comment">/*REFERENCED*/</span></span><br><span class="line">        _Lock __lock_instance;</span><br><span class="line"><span class="meta">#     <span class="meta-keyword">endif</span></span></span><br><span class="line">        _Obj* __RESTRICT __result = *__my_free_list;</span><br><span class="line">        <span class="comment">// 空闲链表没有可用数据块，就将区块大小先调整至 8 倍数边界，然后调用 _S_refill() 重新填充</span></span><br><span class="line">        <span class="keyword">if</span> (__result == <span class="number">0</span>)</span><br><span class="line">            __ret = _S_refill(_S_round_up(__n));</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果空闲链表中有空闲数据块，则取出一个，并把空闲链表的指针指向下一个数据块  </span></span><br><span class="line">            *__my_free_list = __result -&gt; _M_free_list_link;</span><br><span class="line">            __ret = __result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> __ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="deallocate"><a href="#deallocate" class="headerlink" title="deallocate"></a>deallocate</h4><p>同理，根据大小寻找在哪里分配的空间，然后到相应的位置调用并释放空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (__n &gt; (<span class="keyword">size_t</span>) _MAX_BYTES)   </span><br><span class="line">        malloc_alloc::<span class="built_in">deallocate</span>(__p, __n);   <span class="comment">// 大于 128 bytes，就调用第一级配置器的释放</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        _Obj* __STL_VOLATILE*  __my_free_list = _S_free_list + _S_freelist_index(__n);  </span><br><span class="line">        <span class="comment">// 否则将空间回收到相应空闲链表（由释放块的大小决定）中  </span></span><br><span class="line">        _Obj* __q = (_Obj*)__p;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// acquire lock</span></span><br><span class="line"><span class="meta">#       <span class="meta-keyword">ifndef</span> _NOTHREADS</span></span><br><span class="line">        <span class="comment">/*REFERENCED*/</span></span><br><span class="line">        _Lock __lock_instance;</span><br><span class="line"><span class="meta">#       <span class="meta-keyword">endif</span> <span class="comment">/* _NOTHREADS */</span></span></span><br><span class="line">        __q -&gt; _M_free_list_link = *__my_free_list;   <span class="comment">// 调整空闲链表，回收数据块</span></span><br><span class="line">        *__my_free_list = __q;</span><br><span class="line">        <span class="comment">// lock is released here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>各容器中默认使用的分配器alloc为二级分配器</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> __default_alloc_template&lt;__NODE_ALLOCATOR_THREADS, <span class="number">0</span>&gt; alloc;  <span class="comment">// 令 alloc 为第二级配置器</span></span><br></pre></td></tr></table></figure><h4 id="S-chunk-alloc"><a href="#S-chunk-alloc" class="headerlink" title="_S_chunk_alloc"></a>_S_chunk_alloc</h4><p>该函数是二级分配器<code>__default_alloc_template</code>核心的内存分配函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>* _S_chunk_alloc(<span class="keyword">size_t</span> __size, <span class="keyword">int</span>&amp; __nobjs);</span><br><span class="line"><span class="comment">// Chunk allocation state.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>* _S_start_free;  <span class="comment">// 内存池起始位置。只在 _S_chunk_alloc() 中变化</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>* _S_end_free;    <span class="comment">// 内存池结束位置。只在 _S_chunk_alloc() 中变化</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> _S_heap_size;</span><br></pre></td></tr></table></figure><p>首先向<mark>内存池</mark>中申请<code>__nobjs</code>个空间，如果可用空间足够则返回。可用空间不足再判断可否分配1个<code>__size</code>，可以的话就分配一个，如若仍不可以：将剩余空间分配给<code>free list</code>然后配置 heap 空间，用来补充内存池，如果仍不足：则调用一级分配器去分配。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">char</span>*</span><br><span class="line">__default_alloc_template&lt;__threads, __inst&gt;::_S_chunk_alloc(<span class="keyword">size_t</span> __size,   <span class="keyword">int</span>&amp; __nobjs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span>* __result;</span><br><span class="line">    <span class="keyword">size_t</span> __total_bytes = __size * __nobjs;  <span class="comment">// 需要申请空间的大小 </span></span><br><span class="line">    <span class="keyword">size_t</span> __bytes_left = _S_end_free - _S_start_free;  <span class="comment">// 计算内存池剩余空间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__bytes_left &gt;= __total_bytes) &#123;  <span class="comment">// 内存池剩余空间完全满足申请</span></span><br><span class="line">        __result = _S_start_free;</span><br><span class="line">        _S_start_free += __total_bytes;</span><br><span class="line">        <span class="keyword">return</span>(__result);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__bytes_left &gt;= __size) &#123;  <span class="comment">// 内存池剩余空间不能满足申请，提供一个以上的区块</span></span><br><span class="line">        __nobjs = (<span class="keyword">int</span>)(__bytes_left/__size);</span><br><span class="line">        __total_bytes = __size * __nobjs;</span><br><span class="line">        __result = _S_start_free;</span><br><span class="line">        _S_start_free += __total_bytes;</span><br><span class="line">        <span class="keyword">return</span>(__result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                             <span class="comment">// 内存池剩余空间连一个区块的大小都无法提供                      </span></span><br><span class="line">        <span class="keyword">size_t</span> __bytes_to_get = <span class="number">2</span> * __total_bytes + _S_round_up(_S_heap_size &gt;&gt; <span class="number">4</span>);</span><br><span class="line">        <span class="comment">// Try to make use of the left-over piece.</span></span><br><span class="line">        <span class="comment">// 内存池的剩余空间分给合适的空闲链表</span></span><br><span class="line">        <span class="keyword">if</span> (__bytes_left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            _Obj* __STL_VOLATILE* __my_free_list =</span><br><span class="line">                _S_free_list + _S_freelist_index(__bytes_left);</span><br><span class="line"></span><br><span class="line">            ((_Obj*)_S_start_free) -&gt; _M_free_list_link = *__my_free_list;</span><br><span class="line">            *__my_free_list = (_Obj*)_S_start_free;</span><br><span class="line">        &#125;</span><br><span class="line">        _S_start_free = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(__bytes_to_get);  <span class="comment">// 配置 heap 空间，用来补充内存池</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == _S_start_free) &#123;  <span class="comment">// heap 空间不足，malloc() 失败</span></span><br><span class="line">            <span class="keyword">size_t</span> __i;</span><br><span class="line">            _Obj* __STL_VOLATILE* __my_free_list;</span><br><span class="line">            _Obj* __p;</span><br><span class="line">            <span class="comment">// Try to make do with what we have.  That can&#x27;t</span></span><br><span class="line">            <span class="comment">// hurt.  We do not try smaller requests, since that tends</span></span><br><span class="line">            <span class="comment">// to result in disaster on multi-process machines.</span></span><br><span class="line">            <span class="keyword">for</span> (__i = __size;</span><br><span class="line">                 __i &lt;= (<span class="keyword">size_t</span>) _MAX_BYTES;</span><br><span class="line">                 __i += (<span class="keyword">size_t</span>) _ALIGN) &#123;</span><br><span class="line">                __my_free_list = _S_free_list + _S_freelist_index(__i);</span><br><span class="line">                __p = *__my_free_list;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> != __p) &#123;</span><br><span class="line">                    *__my_free_list = __p -&gt; _M_free_list_link;</span><br><span class="line">                    _S_start_free = (<span class="keyword">char</span>*)__p;</span><br><span class="line">                    _S_end_free = _S_start_free + __i;</span><br><span class="line">                    <span class="keyword">return</span>(_S_chunk_alloc(__size, __nobjs));</span><br><span class="line">                    <span class="comment">// Any leftover piece will eventually make it to the</span></span><br><span class="line">                    <span class="comment">// right free list.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            _S_end_free = <span class="number">0</span>;<span class="comment">// In case of exception.</span></span><br><span class="line">            _S_start_free = (<span class="keyword">char</span>*)malloc_alloc::<span class="built_in">allocate</span>(__bytes_to_get);  <span class="comment">// 调用第一级配置器</span></span><br><span class="line">            <span class="comment">// This should either throw an</span></span><br><span class="line">            <span class="comment">// exception or remedy the situation.  Thus we assume it</span></span><br><span class="line">            <span class="comment">// succeeded.</span></span><br><span class="line">        &#125;</span><br><span class="line">        _S_heap_size += __bytes_to_get;</span><br><span class="line">        _S_end_free = _S_start_free + __bytes_to_get;</span><br><span class="line">        <span class="keyword">return</span>(_S_chunk_alloc(__size, __nobjs));  <span class="comment">// 递归调用自己</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于一次申请<code>__nobjs</code>个空间的意义：1个被交给客户端去使用，剩下19个交给 <code>free-list</code> 维护，要的时候再去取即可。(内存池中也会有一部分)</p><p>当使用空间时，先向<code>free list</code>申请，<code>free list</code>空则向内存池申请，内存池仍然空，则调用一级分配器去分配。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">void</span>*</span><br><span class="line">__default_alloc_template&lt;__threads, __inst&gt;::_S_refill(<span class="keyword">size_t</span> __n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> __nobjs = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">// 调用 _S_chunk_alloc()，缺省取 20 个区块作为 free list 的新节点</span></span><br><span class="line">    <span class="keyword">char</span>* __chunk = _S_chunk_alloc(__n, __nobjs);</span><br><span class="line">    _Obj* __STL_VOLATILE* __my_free_list;</span><br><span class="line">    _Obj* __result;</span><br><span class="line">    _Obj* __current_obj;</span><br><span class="line">    _Obj* __next_obj;</span><br><span class="line">    <span class="keyword">int</span> __i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果只获得一个数据块，那么这个数据块就直接分给调用者，空闲链表中不会增加新节点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == __nobjs) <span class="keyword">return</span>(__chunk);</span><br><span class="line">    __my_free_list = _S_free_list + _S_freelist_index(__n);  <span class="comment">// 否则根据申请数据块的大小找到相应空闲链表  </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Build free list in chunk */</span></span><br><span class="line">    __result = (_Obj*)__chunk;</span><br><span class="line">    *__my_free_list = __next_obj = (_Obj*)(__chunk + __n);  <span class="comment">// 第0个数据块给调用者，地址访问即chunk~chunk + n - 1  </span></span><br><span class="line">    <span class="keyword">for</span> (__i = <span class="number">1</span>; ; __i++) &#123;</span><br><span class="line">        __current_obj = __next_obj;</span><br><span class="line">        __next_obj = (_Obj*)((<span class="keyword">char</span>*)__next_obj + __n);</span><br><span class="line">        <span class="keyword">if</span> (__nobjs - <span class="number">1</span> == __i) &#123;</span><br><span class="line">            __current_obj -&gt; _M_free_list_link = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            __current_obj -&gt; _M_free_list_link = __next_obj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>(__result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> SGI_STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL源码-容器</title>
      <link href="/STL%E6%BA%90%E7%A0%81-%E5%AE%B9%E5%99%A8/"/>
      <url>/STL%E6%BA%90%E7%A0%81-%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>本文是在阅读SGI STL v3.3源码中关于<code>container</code>部分，遇到的一些问题及有意思的点。</p><p>此外，本文建立在已经观看过<a href="https://endgame.cc/2022/06/23/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">侯捷老师STL源码剖析课程</a>的基础上。是在阅读源码过程中，对其中的内容进行补充、修饰。</p><span id="more"></span><h2 id="顺序型容器"><a href="#顺序型容器" class="headerlink" title="顺序型容器"></a>顺序型容器</h2><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><h4 id="pragma-set-woff-XXX"><a href="#pragma-set-woff-XXX" class="headerlink" title="#pragma set woff XXX"></a>#pragma set woff XXX</h4><ul><li><code>#pragma set woff xxx</code>    —-    关闭/抑制 名为<code>xxx</code>的编译器警告</li><li><code>#pragma reset woff xxx</code>    —-    重置命令行中指定的状态的警告（取消set状态）</li></ul><h4 id="static-assert"><a href="#static-assert" class="headerlink" title="static_assert"></a>static_assert</h4><p>C++11 静态断言static_assert，编译期断言。</p><blockquote><p><strong>static_assert</strong>(常量表达式，提示信息)</p></blockquote><p>与断言的区别是，静态断言如果为假，则编译不通过。</p><h4 id="noexcept"><a href="#noexcept" class="headerlink" title="noexcept"></a>noexcept</h4><p><code>noexcept</code> 是C++11中的特性，既是一个说明符，也是一个运算符。<code>noexcept</code>指示函数<strong>不会抛出异常</strong>，编译器可以优化代码。</p><p><code>noexcept</code> 用法：</p><ol><li><code>return_type function() noexcept</code>不会抛出异常</li><li><code>return_type function() noexcept(常量表达式)</code>常量表达式为<code>true</code>，则不会抛出异常。</li></ol><blockquote><p>使用场景：移动构造函数、移动赋值、swap()、析构函数。</p></blockquote><ul><li>==默认==的构造函数、拷贝构造函数、赋值、移动构造、移动赋值均为<code>noexcept</code>。</li><li>c++11仍保留throw()，实现和<code>noexcept</code>类似功能（但throw不会针对编译器优化），但在c++20已删除。</li></ul><h4 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h4><p><code>explicit</code>关键字用于构造函数之前，默认关闭了隐式类型转换。</p><blockquote><p>通过构造函数将相应的数据类型转换成为C++类的对象，给编码带来了方便，但并不是每次都正确，为了避免这种情况引入explicit。</p></blockquote><p>explicit 关键字只能用于修饰<mark>只有一个参数的类构造函数</mark></p><h4 id="const-iterator"><a href="#const-iterator" class="headerlink" title="const_iterator"></a>const_iterator</h4><p><code>const_iterator</code>可以改变<code>iterator</code>的值，但不能通过<code>iterator</code>修改指向元素内容的值。(指向常量的指针)</p><h4 id="max-size"><a href="#max-size" class="headerlink" title="max_size()"></a>max_size()</h4><p><code>max_size()</code>函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span>(<span class="number">-1</span>) / <span class="built_in"><span class="keyword">sizeof</span></span>(_Tp); &#125;</span><br></pre></td></tr></table></figure><p>由源码可以知道，size_type为无符号整形。而<code>-1</code>我们知道其二进制补码为==全1==。<code>size_type(-1)</code>将其强制类型转换为无符号整形的最大值(==全1==)，即表示最大值$2^{32/64}$。然后对应的除以一个元素所占大小，即得出最大存放元素数量。</p><p>根据操作系统的位数自由推断所能存储的最大元素数量。</p><h4 id="copy"><a href="#copy" class="headerlink" title="copy()"></a>copy()</h4><p>这里所写的<code>copy(iter it1,iter it2,iter it3)</code>函数是将<code>vector</code>的拷贝赋值<code>=</code>，目的地址所存在的元素数多于要插入的元素时的状况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;_Tp,_Alloc&gt;::<span class="keyword">operator</span>=(<span class="keyword">const</span> vector&lt;_Tp, _Alloc&gt;&amp; __x)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (&amp;__x != <span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> size_type __xlen = __x.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (__xlen &gt; <span class="built_in">capacity</span>()) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">size</span>() &gt;= __xlen) &#123;</span><br><span class="line">      iterator __i = <span class="built_in">copy</span>(__x.<span class="built_in">begin</span>(), __x.<span class="built_in">end</span>(), <span class="built_in">begin</span>());</span><br><span class="line">      <span class="built_in">destroy</span>(__i, _M_finish);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    _M_finish = _M_start + __xlen;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该<code>copy()</code>函数最终调用的函数如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> _Tp*</span><br><span class="line">__copy_trivial(<span class="keyword">const</span> _Tp* __first, <span class="keyword">const</span> _Tp* __last, _Tp* __result) &#123;</span><br><span class="line">  <span class="built_in">memmove</span>(__result, __first, <span class="built_in"><span class="keyword">sizeof</span></span>(_Tp) * (__last - __first));</span><br><span class="line">  <span class="keyword">return</span> __result + (__last - __first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="construct"><a href="#construct" class="headerlink" title="construct()"></a>construct()</h4><p>该函数存在于<code>stl_construct</code>头文件中，是分配器的一部分。源码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">T1</span>, <span class="keyword">class</span> _<span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">(_T1* __p, <span class="keyword">const</span> _T2&amp; __value)</span> </span>&#123;</span><br><span class="line">  _Construct(__p, __value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">T1</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">(_T1* __p)</span> </span>&#123;</span><br><span class="line">  _Construct(__p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">T1</span>, <span class="keyword">class</span> _<span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Construct(_T1* __p, <span class="keyword">const</span> _T2&amp; __value) &#123;</span><br><span class="line">  <span class="keyword">new</span> ((<span class="keyword">void</span>*) __p) _T1(__value);   <span class="comment">// placement new，调用 _T1::_T1(__value);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">T1</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Construct(_T1* __p) &#123;</span><br><span class="line">  <span class="keyword">new</span> ((<span class="keyword">void</span>*) __p) _T1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>__p  —- 指针</li><li>__value —- 初值</li><li>函数功能 —- 将初值<code> __value</code> 设定到指针<code>__p</code>所指的空间上</li></ul><p>函数的作用在于调用相应的构造函数，将地址进行类型转换。</p><h4 id="copy-backward"><a href="#copy-backward" class="headerlink" title="copy_backward()"></a>copy_backward()</h4><p>copy_backward(iter1 first,iter1 end, iter2 res)将元素$\left[first,end\right)$复制到以res为尾迭代器的位置$\left[res-\left(end -first\right),res\right)$。（当在中间插入元素时，后续部分移动<code>copy_backward(*__position*, _M_finish - 2, _M_finish - 1);</code>）样例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt;v1&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">copy_backward</span>(v1.<span class="built_in">begin</span>()+<span class="number">1</span>,v1.<span class="built_in">begin</span>()+<span class="number">3</span>,v1.<span class="built_in">end</span>());<span class="comment">//1~3号元素的值赋给x~_finish。</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> iter=v1.<span class="built_in">begin</span>();iter!=v1.<span class="built_in">end</span>();++iter)&#123;</span><br><span class="line">    cout&lt;&lt;*iter&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;<span class="comment">//1 2 3 2 3 </span></span><br></pre></td></tr></table></figure><h3 id="bit-vector"><a href="#bit-vector" class="headerlink" title="bit_vector"></a>bit_vector</h3><p>由于<code>bool</code>类型只用<code>1bit</code>就可以表示，不需要<code>1Bytes</code>，因此对<code>vector</code>提供相应的偏特化版本。虽然一个元素只占<code>1bit</code>，但地址空间是按照<code>unsigned int</code>进行分配。</p><p>我们知道，vector由<code>start,finish,end_of_storage</code>三个迭代器组成，大小为<code>12</code>字节。而bit_vector与<code>vector</code>存在着一定的差异：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//与大小无关的代码已省略</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">Bvector_base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _Bit_iterator _M_start;</span><br><span class="line">  _Bit_iterator _M_finish;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>* _M_end_of_storage;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Bit_iterator</span> :</span> <span class="keyword">public</span> _Bit_iterator_base</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Bit_iterator_base</span> :</span> <span class="keyword">public</span> random_access_iterator&lt;<span class="keyword">bool</span>, <span class="keyword">ptrdiff_t</span>&gt; </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>* _M_p;<span class="comment">//指向具体实体</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> _M_offset;<span class="comment">//偏移量(从0开始 用于找到具体bit位)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Bit_reference</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>* _M_p;<span class="comment">//指向具体实体</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> _M_mask;<span class="comment">//vaule(true or false)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>__WORD_BIT</code> —- 由于不同位数的操作系统下<code>unsigned int</code>大小并不固定，因此用来确认具体大小。</li></ul><p>可以看出，每个<code>bit_vector</code>由一个<code>unsigned int*</code>和两个<code>iterator</code>组成，而一个<code>bit_iterator</code>由<code>unsigned int*</code>和<code>unsigned int</code>组成，占大小<code>20Bytes</code></p><p>与<code>bit_iterator</code>相关联的两个函数<code>_M_bump_down</code>和<code>_M_bump_up</code>用来进行移位。基于这两个函数还重写了<code>++ --</code>运算符</p><h4 id="flip"><a href="#flip" class="headerlink" title="flip()"></a>flip()</h4><p>所有元素取反。(<code>true-&gt;false</code>,<code>false-&gt;true</code>)</p><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><h4 id="begin-end"><a href="#begin-end" class="headerlink" title="begin()/end()"></a>begin()/end()</h4><p>双向链表底层存放的是虚拟头部(<code>_M_head</code>)，begin()函数返回的是<code>_M_head-&gt;_M_next</code>。而双向链表涉及的是==循环==结构，尾结点的next指针指向虚拟头部。end()函数返回尾结点的下一个元素，即<code>_M_head</code>。</p><h4 id="transfer"><a href="#transfer" class="headerlink" title="transfer()"></a>transfer()</h4><p>list中存在一个<code>transfer(iter postion,iter first,iter last)</code>函数。用于将$\left[first,last\right)$元素移动到<code>position</code>之前。</p><p>源码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(iterator __position, iterator __first, iterator __last)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (__position != __last) &#123;</span><br><span class="line">    <span class="comment">// Remove [first, last) from its old position.</span></span><br><span class="line">      <span class="comment">//改正序遍历指针</span></span><br><span class="line">    __last._M_node-&gt;_M_prev-&gt;_M_next     = __position._M_node;</span><br><span class="line">    __first._M_node-&gt;_M_prev-&gt;_M_next    = __last._M_node;</span><br><span class="line">    __position._M_node-&gt;_M_prev-&gt;_M_next = __first._M_node; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Splice [first, last) into its new position.</span></span><br><span class="line">      <span class="comment">//改逆序遍历指针</span></span><br><span class="line">    _List_node_base* __tmp      = __position._M_node-&gt;_M_prev;</span><br><span class="line">    __position._M_node-&gt;_M_prev = __last._M_node-&gt;_M_prev;</span><br><span class="line">    __last._M_node-&gt;_M_prev     = __first._M_node-&gt;_M_prev; </span><br><span class="line">    __first._M_node-&gt;_M_prev    = __tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以1~7节点中移动[4,6)为例</p></blockquote><p><img src="/STL%E6%BA%90%E7%A0%81-%E5%AE%B9%E5%99%A8/transfer.png" alt="transfer"></p><h4 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h4><p><code>splice()</code>底层是调用<code>transfer()</code>，将元素(结点、<code>list</code>、起止迭代器)插入到指定位置(<code>position</code>)之前。</p><h4 id="unique"><a href="#unique" class="headerlink" title="unique()"></a>unique()</h4><p>删除==连续==的相同元素（保证唯一）。</p><h4 id="merge"><a href="#merge" class="headerlink" title="merge()"></a>merge()</h4><ul><li><p>将另一个链表<code>list2</code>合并到该链表上。</p></li><li><p>合并有序链表，合并后仍有序。</p></li><li><p>两个指针分别指向两个链表头。以调用函数的list为基准，比较大小决定<code>list2</code>结点插入的位置。</p></li></ul><h4 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h4><p>list::sort本质上是<strong>归并排序</strong>。依次从源链表中取值，放入<code>__counter</code>数组中。<code>__counter</code>数组第$i$层至多存放$2^i$个元素(共可以存放$2^{64}-1$个元素)。在递归过程中，先在第0层插入，然后该层元素满时，向上传递该层的数组，并找到恰当的位置。当一层的元素进入下一层是该层元素构成的数组是有序的，被插入的深层里的元素也是有序的（归并排序）。当所有元素都读取出之后<code>while(!empty())</code>跳出，然后递归遍历，每一层都向上传输并进行归并排序。最终将得到的结果回写给源链表。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> list&lt;T, Alloc&gt;::<span class="built_in">sort</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next == node || <span class="built_in">link_type</span>(node-&gt;next)-&gt;next == node) <span class="keyword">return</span>;</span><br><span class="line">    list&lt;T, Alloc&gt; carry;       <span class="comment">//辅助链表，相当与tmp</span></span><br><span class="line">    list&lt;T, Alloc&gt; counter[<span class="number">64</span>]; <span class="comment">//保存当前递归层次的结果，第i链表保存的元素个数为2的i次方或0</span></span><br><span class="line">    <span class="keyword">int</span> fill = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        carry.<span class="built_in">splice</span>(carry.<span class="built_in">begin</span>(), *<span class="keyword">this</span>, <span class="built_in">begin</span>());  <span class="comment">//将链表的第一个元素移动至carry开头</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//从小到大不断合并非空归并层次直至遇到空层或者到达当前最大归并层次</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; fill &amp;&amp; !counter[i].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            counter[i].<span class="built_in">merge</span>(carry);  <span class="comment">//合并链表，结果链表是有序的，必须保证合并前两链表有序</span></span><br><span class="line">            carry.<span class="built_in">swap</span>(counter[i++]); <span class="comment">//链表元素互换</span></span><br><span class="line">            <span class="comment">//将某一层的元素换出到carry中，去和下一层比对</span></span><br><span class="line">        &#125;</span><br><span class="line">        carry.<span class="built_in">swap</span>(counter[i]);  <span class="comment">//将carry元素放到counter[i]中，相当于将carry情况，带下一次循环使用</span></span><br><span class="line">        <span class="comment">//将carry中的数据换回最深层</span></span><br><span class="line">        <span class="keyword">if</span> (i == fill) ++fill;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将所有归并层次的结果合并得到最终结果counter[fill-1]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; fill; ++i) counter[i].<span class="built_in">merge</span>(counter[i<span class="number">-1</span>]);</span><br><span class="line">    <span class="built_in">swap</span>(counter[fill<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li> fill —- counter数组中最深层的层数</li></ul><h3 id="slist"><a href="#slist" class="headerlink" title="slist"></a>slist</h3><p>slist、forward_list。单向链表。仅有一个虚拟头部，指向实际链表头</p><h4 id="slist-splice-after"><a href="#slist-splice-after" class="headerlink" title="__slist_splice_after()"></a>__slist_splice_after()</h4><p>_Slist_node_base == A</p><ul><li><code>__slist_splice_after(A* pos,A* first,A*last)</code>将$\left(first,last\right]$中的数据移动到<code>pos</code>之后</li><li><code>__slist_splice_after(A* pos,A* node)</code>将$\left(node,\infty\right)$移动到<code>pos</code>之后。（node之后所有元素）</li></ul><h4 id="M-erase-after"><a href="#M-erase-after" class="headerlink" title="_M_erase_after()"></a>_M_erase_after()</h4><ul><li><code>_M_erase_after(A* pos)</code>删除<code>pos</code>位置后的第一个元素</li><li><code>_M_erase_after(A* pos, A* last)</code>删除$\left(post,last\right)$之间全部元素</li></ul><h4 id="begin-end-1"><a href="#begin-end-1" class="headerlink" title="begin()/end()"></a>begin()/end()</h4><ul><li>单向链表的底层仅存在一个虚拟头部(<code>_M_head</code>)指向真正链表的头，begin()函数返回的是<code>_M_head-&gt;_M_next</code></li><li>由于end()应指向最后一个元素的下一个元素(<code>nullptr</code>)，而单链表只能单向访问，直接<code>return nullptr</code></li></ul><h4 id="push-pop"><a href="#push-pop" class="headerlink" title="push/pop"></a>push/pop</h4><p>单链表插入/删除元素是在==头部==进行操作。故，push/pop函数为<code>push_front()/pop_front()</code>，插入/弹出虚拟头部的后一个位置。</p><h4 id="previous"><a href="#previous" class="headerlink" title="previous()"></a>previous()</h4><p><code>previous(iterator pos)</code>返回<code>pos</code>位置的前一个元素。</p><h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p><img src="/STL%E6%BA%90%E7%A0%81-%E5%AE%B9%E5%99%A8/deque.png" alt="deque"></p><h5 id="Deque-iterator"><a href="#Deque-iterator" class="headerlink" title="_Deque_iterator"></a>_Deque_iterator</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Ref</span>, <span class="keyword">class</span> _<span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Deque_iterator</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> _Tp** _Map_pointer;</span><br><span class="line">  _Tp* _M_cur;   <span class="comment">// 迭代器指向缓冲区的当前元素</span></span><br><span class="line">  _Tp* _M_first; <span class="comment">// 迭代器指向缓冲区的头部</span></span><br><span class="line">  _Tp* _M_last;  <span class="comment">// 迭代器指向缓冲区的尾部</span></span><br><span class="line">  _Map_pointer _M_node;  <span class="comment">// 迭代器指向 map 的 node</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="operator"><a href="#operator" class="headerlink" title="operator-"></a>operator-</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">difference_type <span class="keyword">operator</span>-(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()) *(node - x.node - <span class="number">1</span>) + (cur - first) + (x.last - x.cur);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    node - x.node - 1     map中的完整缓冲区个数</span></span><br><span class="line"><span class="comment">    cur - first 尾迭代器buffer元素个数</span></span><br><span class="line"><span class="comment">    x.last - x.cur 头迭代器buffer元素个数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>enum { _S_initial_map_size = 8 };        //默认map大小</p></blockquote><h4 id="M-initialize-map"><a href="#M-initialize-map" class="headerlink" title="_M_initialize_map()"></a>_M_initialize_map()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">_Deque_base&lt;_Tp,_Alloc&gt;::_M_initialize_map(<span class="keyword">size_t</span> __num_elements)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 所需节点数</span></span><br><span class="line">  <span class="keyword">size_t</span> __num_nodes = </span><br><span class="line">    __num_elements / __deque_buf_size(<span class="built_in"><span class="keyword">sizeof</span></span>(_Tp)) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// __num_elements / __deque_buf_size(sizeof(_Tp))满结点个数 + 1未满（或空）</span></span><br><span class="line">  <span class="comment">// 一个 map 要管理几个节点，最少 8 个，最多是所需节点数加 2（首尾两个虚拟节点）</span></span><br><span class="line">  _M_map_size = <span class="built_in">max</span>((<span class="keyword">size_t</span>) _S_initial_map_size, __num_nodes + <span class="number">2</span>);</span><br><span class="line">  _M_map = _M_allocate_map(_M_map_size);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// __nstart、__nfinish 指向 map 的中间位置。方便两端扩充（减少加结点的次数）</span></span><br><span class="line">  _Tp** __nstart = _M_map + (_M_map_size - __num_nodes) / <span class="number">2</span>;</span><br><span class="line">  _Tp** __nfinish = __nstart + __num_nodes;</span><br><span class="line">    </span><br><span class="line">  __STL_TRY &#123;</span><br><span class="line">    _M_create_nodes(__nstart, __nfinish);</span><br><span class="line">  &#125;</span><br><span class="line">  __STL_UNWIND((_M_deallocate_map(_M_map, _M_map_size), </span><br><span class="line">                _M_map = <span class="number">0</span>, _M_map_size = <span class="number">0</span>));</span><br><span class="line">  <span class="comment">// 为 deque 内的两个迭代器 start 和 finish 指向正确位置</span></span><br><span class="line">  _M_start._M_set_node(__nstart);</span><br><span class="line">  _M_finish._M_set_node(__nfinish - <span class="number">1</span>);</span><br><span class="line">  _M_start._M_cur = _M_start._M_first;</span><br><span class="line">  _M_finish._M_cur = _M_finish._M_first +</span><br><span class="line">               __num_elements % __deque_buf_size(<span class="built_in"><span class="keyword">sizeof</span></span>(_Tp));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="erase-iterator-pos"><a href="#erase-iterator-pos" class="headerlink" title="erase(iterator __pos)"></a>erase(iterator __pos)</h4><p>删除指定位置的元素。该函数的有趣之处在于，先判断距离哪一端更近，从近的一侧去移动元素。</p><blockquote><p>insert底层函数insert_aux函数亦然</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator __pos)</span> </span>&#123;</span><br><span class="line">  iterator __next = __pos;</span><br><span class="line">  ++__next;</span><br><span class="line">  difference_type __index = __pos - _M_start; <span class="comment">//与头距离</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">size_type</span>(__index) &lt; (<span class="keyword">this</span>-&gt;<span class="built_in">size</span>() &gt;&gt; <span class="number">1</span>)) &#123;<span class="comment">//距离与总元素个数比较</span></span><br><span class="line">    <span class="built_in">copy_backward</span>(_M_start, __pos, __next);</span><br><span class="line">      <span class="comment">//离头近，将头~pos元素整体向后赋值（覆盖pos），再弹出头</span></span><br><span class="line">    <span class="built_in">pop_front</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">copy</span>(__next, _M_finish, __pos);</span><br><span class="line">      <span class="comment">//离尾部近，</span></span><br><span class="line">    <span class="built_in">pop_back</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _M_start + __index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="M-reserve-map-at-back"><a href="#M-reserve-map-at-back" class="headerlink" title="_M_reserve_map_at_back()"></a>_M_reserve_map_at_back()</h4><p>共有两组函数：</p><ul><li><code>_M_reserve_map_at_back()</code>和<code>_M_reserve_map_at_front()</code>。表示<code>map</code>的一端不够用时，扩充</li><li><code>_M_reserve_element_at_back()</code>和<code>_M_reserve_element_at_front()</code>表示<mark>结点</mark>不够用扩充结点。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">void</span> _M_reserve_map_at_back (size_type __nodes_to_add = <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__nodes_to_add + <span class="number">1</span> &gt; _M_map_size - (_M_finish._M_node - _M_map))</span><br><span class="line">      _M_reallocate_map(__nodes_to_add, <span class="literal">false</span>);</span><br><span class="line">  &#125;<span class="comment">//map尾结点可用空间不足，换个更大空间</span></span><br><span class="line">  <span class="keyword">void</span> _M_reserve_map_at_front (size_type __nodes_to_add = <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__nodes_to_add &gt; <span class="built_in">size_type</span>(_M_start._M_node - _M_map))</span><br><span class="line">      _M_reallocate_map(__nodes_to_add, <span class="literal">true</span>);</span><br><span class="line">  &#125;<span class="comment">//map头结点可用空间不足，换个更大空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> deque&lt;_Tp,_Alloc&gt;::_M_reallocate_map(size_type __nodes_to_add,</span><br><span class="line">                                          <span class="keyword">bool</span> __add_at_front)</span><br><span class="line">&#123;</span><br><span class="line">  size_type __old_num_nodes = _M_finish._M_node - _M_start._M_node + <span class="number">1</span>;</span><br><span class="line">  size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;</span><br><span class="line"></span><br><span class="line">  _Map_pointer __new_nstart;</span><br><span class="line">  <span class="keyword">if</span> (_M_map_size &gt; <span class="number">2</span> * __new_num_nodes) &#123;<span class="comment">//总空间充足（元素偏向一侧）则调整位置</span></span><br><span class="line">    __new_nstart = _M_map + (_M_map_size - __new_num_nodes) / <span class="number">2</span> </span><br><span class="line">                     + (__add_at_front ? __nodes_to_add : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (__new_nstart &lt; _M_start._M_node)</span><br><span class="line">      <span class="built_in">copy</span>(_M_start._M_node, _M_finish._M_node + <span class="number">1</span>, __new_nstart);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">copy_backward</span>(_M_start._M_node, _M_finish._M_node + <span class="number">1</span>, </span><br><span class="line">                    __new_nstart + __old_num_nodes);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="comment">//空间不足 新申请一片空间</span></span><br><span class="line">    size_type __new_map_size = </span><br><span class="line">      _M_map_size + <span class="built_in">max</span>(_M_map_size, __nodes_to_add) + <span class="number">2</span>;</span><br><span class="line">    _Map_pointer __new_map = _M_allocate_map(__new_map_size);<span class="comment">//配置新空间</span></span><br><span class="line">    __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / <span class="number">2</span></span><br><span class="line">                         + (__add_at_front ? __nodes_to_add : <span class="number">0</span>);<span class="comment">//寻找新头</span></span><br><span class="line">    <span class="built_in">copy</span>(_M_start._M_node, _M_finish._M_node + <span class="number">1</span>, __new_nstart);</span><br><span class="line">    _M_deallocate_map(_M_map, _M_map_size);</span><br><span class="line"></span><br><span class="line">    _M_map = __new_map;</span><br><span class="line">    _M_map_size = __new_map_size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _M_start._M_set_node(__new_nstart);</span><br><span class="line">  _M_finish._M_set_node(__new_nstart + __old_num_nodes - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="M-insert-aux"><a href="#M-insert-aux" class="headerlink" title="_M_insert_aux()"></a>_M_insert_aux()</h4><p><code>insert</code>函数底层调用<code>_M_insert_aux()</code>其中有两个重载版本的<code>_M_insert_aux</code>存在一些问题（非不能，个人认为传参有些冗余）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> deque&lt;_Tp,_Alloc&gt;::_M_insert_aux(iterator __pos,</span><br><span class="line">                                      <span class="keyword">const</span> value_type* __first,</span><br><span class="line">                                      <span class="keyword">const</span> value_type* __last,</span><br><span class="line">                                      size_type __n)&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> deque&lt;_Tp,_Alloc&gt;::_M_insert_aux(iterator __pos,</span><br><span class="line">                                      const_iterator __first,</span><br><span class="line">                                      const_iterator __last,</span><br><span class="line">                                      size_type __n)&#123;</span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个函数上层<code>insert()</code>函数重载时，传入的是三个参数（<code>Where</code>,<code>First</code>,<code>Last</code>）。而在调用底层<code>_M_insert_aux</code>时，添加第四参数<code>n = first - last</code>。（个人认为这里不传，底层去计算亦可）</p><h3 id="stack-queue"><a href="#stack-queue" class="headerlink" title="stack/queue"></a>stack/queue</h3><blockquote><p>stack/queue无迭代器</p></blockquote><p>底层容器可以是<code>vector  list  deque</code>。然后采用$Adapter$设计模式，改装成<code>stack/queue</code>。默认底层容器<code>deque</code>。做底层容器要求：拥有<code>empty()  size()  push_back()  pop_back()/pop_front()  back()/front()  operatot==</code>等函数。（改装时，调用底层容器的函数，能够成功调用。）</p><h3 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h3><p>默认底层容器<code>vector</code>，默认规则<code>max-heap</code>。插入、删除、弹出元素时调用<code>make_heap()  push_heap()  pop_heap()</code></p><h3 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h3><blockquote><p>heap无迭代器。</p></blockquote><blockquote><p>heap不提供外部调用接口，仅供<code>priority_queue</code>使用</p></blockquote><p>默认底层容器<code>vector</code>。根节点位于 vector 的头部；</p><p>当 heap 中的某个节点位于 vector 的 $i $处，左子节点位于  $2i+1 $，右子节点位于 $2i+2$ ；然后调整为 heap。</p><p>heap有四个主要函数:<code>push_heap  pop_heap  make_heap  sort_heap</code></p><h4 id="push-heap"><a href="#push-heap" class="headerlink" title="push_heap"></a>push_heap</h4><p>push_heap所做的操作是：向根尾部插入一个元素，然后调整到正确的位置。源码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> _<span class="title">Distance</span>, <span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">__push_heap(_RandomAccessIterator __first,</span><br><span class="line">            _Distance __holeIndex, _Distance __topIndex, _Tp __value)</span><br><span class="line">&#123;</span><br><span class="line">  _Distance __parent = (__holeIndex - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// 找到插入节点的父节点位置</span></span><br><span class="line">  <span class="keyword">while</span> (__holeIndex &gt; __topIndex &amp;&amp; *(__first + __parent) &lt; __value) &#123; <span class="comment">// 当插入值大于其父节点的值</span></span><br><span class="line">    *(__first + __holeIndex) = *(__first + __parent);   <span class="comment">// 将其插入节点的父节点的值赋给插入节点位置</span></span><br><span class="line">    __holeIndex = __parent;  <span class="comment">// 索引位置改变，插入值的索引为父节点索引</span></span><br><span class="line">    __parent = (__holeIndex - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// 插入值的索引的父节点</span></span><br><span class="line">  &#125;    </span><br><span class="line">  *(__first + __holeIndex) = __value; <span class="comment">// 交换完后，找到插入值的真正位置，赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>__first    —    容器首部迭代器，用于定位元素的位置(下面的<code>*(__first + __holeIndex)</code>)</p></li><li><p>__holeIndex    —    容器已使用的长度、也是新插入元素在数组中存放的角标</p></li><li><p>__topIndex    —    允许上升的最大高度，用于控制循环退出条件(一般为根节点高度0)</p></li><li><p>__value    —    新插入元素的值</p></li><li><p>__comp    —    仿函数，用于传入自定义比较规则。（影响上述源码第7行循环中的比较标准）</p><ul><li><code>*(__first + __parent) &lt; __value) </code>$\longrightarrow$<code>__comp(*(__first + __parent), __value))</code></li></ul></li></ul><h4 id="pop-heap"><a href="#pop-heap" class="headerlink" title="pop_heap"></a>pop_heap</h4><p>pop_heap调用<code>__pop_heap</code>实现弹堆顶元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIterator</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pop_heap</span><span class="params">(_RandomAccessIterator __first,_RandomAccessIterator __last)</span></span>&#123;</span><br><span class="line">  __pop_heap_aux(__first, __last, __VALUE_TYPE(__first));   <span class="comment">// pop_heap 调整函数，将 vector 头部元素放到 vector 的尾部</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __pop_heap_aux(_RandomAccessIterator __first, _RandomAccessIterator __last,_Tp*)&#123;</span><br><span class="line">  __pop_heap(__first, __last - <span class="number">1</span>, __last - <span class="number">1</span>, _Tp(*(__last - <span class="number">1</span>)), __DISTANCE_TYPE(__first)); </span><br><span class="line">    <span class="comment">// 调整 heap 后，变为[first, last-1)</span></span><br><span class="line">    <span class="comment">//这里还要注意，第四个参数__value传的是_Tp(*(__last - 1))。也就是原来堆尾的值。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,</span><br><span class="line">           _RandomAccessIterator __result, _Tp __value, _Distance*)</span><br><span class="line">&#123;</span><br><span class="line">  *__result = *__first;  <span class="comment">// 先保存 vector 头部元素，放到 vector 的尾端</span></span><br><span class="line">  __adjust_heap(__first, _Distance(<span class="number">0</span>), _Distance(__last - __first), __value); <span class="comment">// 再做 shift down 操作调整</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>__pop_heap参数如下</p></blockquote><ul><li><p>__first    —    指向堆顶的迭代器。（要弹出元素的位置）</p></li><li><p>__last    —    容器尾部迭代器（实际使用的最后一个元素位置）</p></li><li><p>__result    —    结果保存的位置。由于底层容器为vector，当删除一个元素时，是将其移动到容器尾，然后再移动尾迭代器使其不可见，故默认值为<code>_Tp(*__last )</code></p></li><li><p>__value    —    堆中最小的元素值（堆尾部的值）</p></li><li><p>__comp    —    仿函数，用于传入自定义比较规则。如果有会相应的传给<code>__adjust_heap</code>函数</p></li></ul><h5 id="adjust-heap"><a href="#adjust-heap" class="headerlink" title="__adjust_heap"></a>__adjust_heap</h5><p>pop_heap底层真正调用实现剩余元素维持堆序性的函数。这里以删除结点后的调整为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> _<span class="title">Distance</span>, <span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">__adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,</span><br><span class="line">              _Distance __len, _Tp __value)</span><br><span class="line">&#123;</span><br><span class="line">  _Distance __topIndex = __holeIndex;  <span class="comment">// __holeIndex = 0，为 heap 的根节点</span></span><br><span class="line">  _Distance __secondChild = <span class="number">2</span> * __holeIndex + <span class="number">2</span>; <span class="comment">// 根节点的右节点的索引</span></span><br><span class="line">  <span class="keyword">while</span> (__secondChild &lt; __len) &#123;</span><br><span class="line">      <span class="comment">// __comp传入时，用来修改此处的比较条件</span></span><br><span class="line">    <span class="keyword">if</span> (*(__first + __secondChild) &lt; *(__first + (__secondChild - <span class="number">1</span>))) <span class="comment">// 比较根节点的左右节点值</span></span><br><span class="line">      __secondChild--;<span class="comment">//__secondChild向下传递时，一定为较大值</span></span><br><span class="line">    *(__first + __holeIndex) = *(__first + __secondChild);  <span class="comment">// while 里做 shift down 操作</span></span><br><span class="line">      <span class="comment">//二者本来是兄弟节点，较大值升为父节点。</span></span><br><span class="line">    __holeIndex = __secondChild;</span><br><span class="line">    __secondChild = <span class="number">2</span> * (__secondChild + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (__secondChild == __len) &#123;  <span class="comment">// 没有右子节点，只有左子节点</span></span><br><span class="line">    *(__first + __holeIndex) = *(__first + (__secondChild - <span class="number">1</span>));</span><br><span class="line">    __holeIndex = __secondChild - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="comment">//循环退出时，__holeIndex移动到最后一层。</span></span><br><span class="line">    <span class="comment">// 此时。__holeIndex标志着最小值__value的位置</span></span><br><span class="line">  __push_heap(__first, __holeIndex, __topIndex, __value);  <span class="comment">// 向上寻找 找到真正的位置，插入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抛开<mark>删除元素移动最小值</mark>而言，当我们所操作的是任意一个元素时，所进行的操作是先将其<mark>下降到最深深度</mark>，然后将其<mark>上升至适当位置</mark>，<strong>但是最终这个位置不能大于其原本的位置</strong>。</p><h4 id="make-heap"><a href="#make-heap" class="headerlink" title="make_heap"></a>make_heap</h4><p>递归调用<code>__adjust_heap()</code>进行调整 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [first, last) 调整为 heap</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">__make_heap(_RandomAccessIterator __first,</span><br><span class="line">            _RandomAccessIterator __last, _Tp*, _Distance*)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__last - __first &lt; <span class="number">2</span>) <span class="keyword">return</span>; <span class="comment">// 如果长度为 0 或 1，不排列</span></span><br><span class="line">  _Distance __len = __last - __first; <span class="comment">// 待排列的长度</span></span><br><span class="line">  _Distance __parent = (__len - <span class="number">2</span>)/<span class="number">2</span>; <span class="comment">// 父节点i和右子节点2i+2</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">// 这里 __parent 就是待插入节点索引</span></span><br><span class="line">    __adjust_heap(__first, __parent, __len, _Tp(*(__first + __parent)));</span><br><span class="line">    <span class="keyword">if</span> (__parent == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    __parent--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="sort-heap"><a href="#sort-heap" class="headerlink" title="sort_heap"></a>sort_heap</h4><p>重复调用<code>pop_heap</code>函数，将当前最大值丢到尾部。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> </span></span><br><span class="line"><span class="function"><span class="title">sort_heap</span><span class="params">(_RandomAccessIterator __first,</span></span></span><br><span class="line"><span class="params"><span class="function">          _RandomAccessIterator __last, _Compare __comp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __STL_REQUIRES(_RandomAccessIterator, _Mutable_RandomAccessIterator);</span><br><span class="line">  <span class="keyword">while</span> (__last - __first &gt; <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">pop_heap</span>(__first, __last--, __comp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>既然sort_heap已经可以实现排序，那make_heap作用？</p></blockquote><p>首先，我们在<code>priority_queue</code>底层了解到其存在如下构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">priority_queue</span>(<span class="keyword">const</span> value_type* __first, <span class="keyword">const</span> value_type* __last) </span><br><span class="line">    : <span class="built_in">c</span>(__first, __last) &#123; <span class="built_in">make_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp); &#125;</span><br></pre></td></tr></table></figure><p>当我们为其传入一个<code>vector</code>的首尾指针时（测试<code>list</code>亦可），会先把相应的值赋给底层容器里，然后调用<code>make_heap</code>函数，将拷贝到底层容器里的值进行排序。</p><blockquote><p>后话：暂时在该版本源码中并未发现sort_heap的调用</p></blockquote><h2 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h2><h3 id="RB-Tree"><a href="#RB-Tree" class="headerlink" title="RB-Tree"></a>RB-Tree</h3><p>红黑树，是一个自平衡的<mark>二叉搜索树</mark>。</p><p>首先用<code>bool</code>类型定义结点的红黑色。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">bool</span> _Rb_tree_Color_type;</span><br><span class="line"><span class="keyword">const</span> _Rb_tree_Color_type _S_rb_tree_red = <span class="literal">false</span>; <span class="comment">// 红色为 0</span></span><br><span class="line"><span class="keyword">const</span> _Rb_tree_Color_type _S_rb_tree_black = <span class="literal">true</span>; <span class="comment">// 黑色为 1</span></span><br></pre></td></tr></table></figure><h4 id="header"><a href="#header" class="headerlink" title="header"></a>header</h4><p>红黑树的虚拟头结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Rb_tree_base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    _Rb_tree_node&lt;_Tp&gt;* _M_header;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">Rb_tree</span> :</span> <span class="keyword">protected</span> _Rb_tree_base&lt;_Value, _Alloc&gt; &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    size_type _M_node_count; <span class="comment">// keeps track of size of tree 节点数量</span></span><br><span class="line">    _Compare _M_key_compare; <span class="comment">// 节点间的键值大小比较准则</span></span><br><span class="line">&#125;;</span><br><span class="line">_Link_type&amp; _M_root() <span class="keyword">const</span> </span><br><span class="line">&#123; <span class="keyword">return</span> (_Link_type&amp;) _M_header-&gt;_M_parent; &#125;</span><br><span class="line">_Link_type&amp; _M_leftmost() <span class="keyword">const</span> </span><br><span class="line">&#123; <span class="keyword">return</span> (_Link_type&amp;) _M_header-&gt;_M_left; &#125;</span><br><span class="line">_Link_type&amp; _M_rightmost() <span class="keyword">const</span> </span><br><span class="line">&#123; <span class="keyword">return</span> (_Link_type&amp;) _M_header-&gt;_M_right; &#125;</span><br></pre></td></tr></table></figure><ul><li>对于一个空树而言。<ul><li><code>header</code>的<code>left  right</code>指针指向自己</li><li><code>header-&gt;parent = nullptr</code></li></ul></li><li>红黑树非空<ul><li><code>root-&gt;parent = header</code> &amp;&amp; <code>header-&gt;parent = root</code></li><li><code>header-&gt;left = leftmost(最小值结点)</code> &amp;&amp; <code>header-&gt;right = rightmost(最大值结点)</code></li></ul></li></ul><h4 id="node"><a href="#node" class="headerlink" title="node"></a>node</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Rb_tree_node_base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> _Rb_tree_Color_type _Color_type;</span><br><span class="line">  <span class="keyword">typedef</span> _Rb_tree_node_base* _Base_ptr;</span><br><span class="line">  _Color_type _M_color;   <span class="comment">// 节点颜色，非红即黑</span></span><br><span class="line">  _Base_ptr _M_parent;    <span class="comment">// 父节点</span></span><br><span class="line">  _Base_ptr _M_left;      <span class="comment">// 左节点</span></span><br><span class="line">  _Base_ptr _M_right;     <span class="comment">// 右节点</span></span><br><span class="line">    <span class="comment">//此外，还有找最大值、最小值的函数，二叉搜索树最大值、最小值即为最右侧、最左侧结点。</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Value</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Rb_tree_node</span> :</span> <span class="keyword">public</span> _Rb_tree_node_base</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typedef</span> _Rb_tree_node&lt;_Value&gt;* _Link_type;</span><br><span class="line">  _Value _M_value_field;  <span class="comment">// 节点值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RB-tree 的迭代器-基类</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Rb_tree_base_iterator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> _Rb_tree_node_base::_Base_ptr _Base_ptr;</span><br><span class="line">  _Base_ptr _M_node; <span class="comment">// 它用来与容器之间产生一个连接关系</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="decrement-increment"><a href="#decrement-increment" class="headerlink" title="decrement/increment"></a>decrement/increment</h4><p>迭代器<code>++/--</code>的底层，用于寻找前驱、后继节点（按值的大小序），但其中对虚拟header结点有着特殊处理。最左值的前一个和最右值的后一个结点均为header</p><h4 id="end"><a href="#end" class="headerlink" title="end()"></a>end()</h4><p>返回最右值的后一个元素(header)</p><h4 id="equal-range"><a href="#equal-range" class="headerlink" title="equal_range"></a>equal_range</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Key</span>, <span class="keyword">class</span> _<span class="title">Value</span>, <span class="keyword">class</span> _<span class="title">KeyOfValue</span>,  <span class="keyword">class</span> _<span class="title">Compare</span>, <span class="keyword">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> pair&lt;<span class="keyword">typename</span> _Rb_tree&lt;_Key,_Value,_KeyOfValue,_Compare,_Alloc&gt;::iterator,</span><br><span class="line">     <span class="keyword">typename</span> _Rb_tree&lt;_Key,_Value,_KeyOfValue,_Compare,_Alloc&gt;::iterator&gt;</span><br><span class="line">_Rb_tree&lt;_Key,_Value,_KeyOfValue,_Compare,_Alloc&gt;::<span class="built_in">equal_range</span>(<span class="keyword">const</span> _Key&amp; __k)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> pair&lt;iterator, iterator&gt;(<span class="built_in">lower_bound</span>(__k), <span class="built_in">upper_bound</span>(__k));</span><br><span class="line">&#125;<span class="comment">// key == _k的结点迭代器所在的范围。</span></span><br></pre></td></tr></table></figure><ul><li><p>lower_bound(const _Key&amp; __k)  —  <strong>不小于k</strong>的第一个节点的迭代器</p></li><li><p>upper_bound(const _Key&amp; __k)  —  <strong>大于k</strong>的第一个节点的迭代器</p></li></ul><h4 id="rb-verify"><a href="#rb-verify" class="headerlink" title="__rb_verify()"></a>__rb_verify()</h4><p>判断红黑树<mark>是否合法</mark>。（满足红黑树的性质）</p><p>源码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Key</span>, <span class="keyword">class</span> _<span class="title">Value</span>, <span class="keyword">class</span> _<span class="title">KeyOfValue</span>,  <span class="keyword">class</span> _<span class="title">Compare</span>, <span class="keyword">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> _Rb_tree&lt;_Key,_Value,_KeyOfValue,_Compare,_Alloc&gt;::__rb_verify() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_M_node_count == <span class="number">0</span> || <span class="built_in">begin</span>() == <span class="built_in">end</span>())</span><br><span class="line">        <span class="keyword">return</span> _M_node_count == <span class="number">0</span> &amp;&amp; <span class="built_in">begin</span>() == <span class="built_in">end</span>() &amp;&amp;</span><br><span class="line">        _M_header-&gt;_M_left == _M_header &amp;&amp; _M_header-&gt;_M_right == _M_header;</span><br><span class="line">  <span class="comment">//true代表此空树符合红黑树的性质</span></span><br><span class="line">    <span class="keyword">int</span> __len = __black_count(_M_leftmost(), _M_root());<span class="comment">//每个分支上黑节点个数</span></span><br><span class="line">    <span class="keyword">for</span> (const_iterator __it = <span class="built_in">begin</span>(); __it != <span class="built_in">end</span>(); ++__it) &#123;</span><br><span class="line">        _Link_type __x = (_Link_type) __it._M_node;</span><br><span class="line">        _Link_type __L = _S_left(__x);</span><br><span class="line">        _Link_type __R = _S_right(__x);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//红黑树性质之 红节点的子节点均为黑</span></span><br><span class="line">        <span class="keyword">if</span> (__x-&gt;_M_color == _S_rb_tree_red)</span><br><span class="line">            <span class="keyword">if</span> ((__L &amp;&amp; __L-&gt;_M_color == _S_rb_tree_red) ||</span><br><span class="line">                (__R &amp;&amp; __R-&gt;_M_color == _S_rb_tree_red))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="comment">//二叉搜素树结点间大小关系</span></span><br><span class="line">        <span class="keyword">if</span> (__L &amp;&amp; _M_key_compare(_S_key(__x), _S_key(__L)))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (__R &amp;&amp; _M_key_compare(_S_key(__R), _S_key(__x)))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//统计一条分支上黑节点个数 与基准值不同  则不符合</span></span><br><span class="line">        <span class="keyword">if</span> (!__L &amp;&amp; !__R &amp;&amp; __black_count(__x, _M_root()) != __len)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//左节点不是最小值、右节点不是最大值</span></span><br><span class="line">    <span class="keyword">if</span> (_M_leftmost() != _Rb_tree_node_base::_S_minimum(_M_root()))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (_M_rightmost() != _Rb_tree_node_base::_S_maximum(_M_root()))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="set-multiset"><a href="#set-multiset" class="headerlink" title="set/multiset"></a>set/multiset</h3><p>底层容器为红黑树。函数实现为调用红黑树相应的函数。两个的区别在于<code>insert</code>函数</p><ul><li>set调用红黑树的<code>insert_unique</code>函数</li><li>multiset调用红黑树的<code>insert_equal</code>函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Key</span>, <span class="keyword">class</span> _<span class="title">Compare</span>, <span class="keyword">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">set</span>&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> _Key     key_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Key     value_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Compare key_compare;</span><br><span class="line">    <span class="keyword">typedef</span> _Compare value_compare;</span><br><span class="line">    <span class="keyword">typedef</span> _Rb_tree&lt;key_type, value_type, _Identity&lt;value_type&gt;, key_compare, _Alloc&gt; _Rep_type;</span><br><span class="line">    <span class="comment">// set 的底层实现为 RB-tree</span></span><br><span class="line">    _Rep_type _M_t;  <span class="comment">// red-black tree representing set</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="map-multimap"><a href="#map-multimap" class="headerlink" title="map/multimap"></a>map/multimap</h3><p>除了下述基础结构和<code>set/mutiset</code>有细微差距外，整体与<code>set/mutiset</code>类似、</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Key</span>, <span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Compare</span>, <span class="keyword">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">map</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> _Key                  key_type; <span class="comment">// 键值类型</span></span><br><span class="line">    <span class="keyword">typedef</span> _Tp                   data_type; <span class="comment">// 实值类型</span></span><br><span class="line">    <span class="keyword">typedef</span> _Tp                   mapped_type;</span><br><span class="line">    <span class="keyword">typedef</span> pair&lt;<span class="keyword">const</span> _Key, _Tp&gt; value_type;  <span class="comment">// 元素类型(键值/实值)</span></span><br><span class="line">    <span class="keyword">typedef</span> _Compare              key_compare; <span class="comment">// 键值比较函数</span></span><br><span class="line">    _Compare comp;</span><br><span class="line">    <span class="keyword">typedef</span> _Rb_tree&lt;key_type, value_type,  _Select1st&lt;value_type&gt;, key_compare, _Alloc&gt; _Rep_type; </span><br><span class="line">    <span class="comment">// map 的底层机制 RB-tree </span></span><br><span class="line">    _Rep_type _M_t;  <span class="comment">// red-black tree representing map 以红黑树(RB-tree) 表现 map</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h3><p> map 的结构是键值对 <code>&lt;Key, value&gt;</code>，这种结构在底层以<code>pair</code>形式存储。基本结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">T1</span>, <span class="keyword">class</span> _<span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pair</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> _T1 first_type;</span><br><span class="line">    <span class="keyword">typedef</span> _T2 second_type;</span><br><span class="line">    _T1 first;  <span class="comment">// 第一个参数</span></span><br><span class="line">    _T2 second; <span class="comment">// 第二个参数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="opertor-lt"><a href="#opertor-lt" class="headerlink" title="opertor&lt;"></a>opertor&lt;</h4><p>先比较第一参数大小关系，第一参数相等时，再比较第二参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">T1</span>, <span class="keyword">class</span> _<span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> pair&lt;_T1, _T2&gt;&amp; __x, <span class="keyword">const</span> pair&lt;_T1, _T2&gt;&amp; __y)</span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">return</span> __x.first &lt; __y.first || (!(__y.first &lt; __x.first) &amp;&amp; __x.second &lt; __y.second); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="make-pair"><a href="#make-pair" class="headerlink" title="make_pair"></a>make_pair</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">T1</span>, <span class="keyword">class</span> _<span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> pair&lt;_T1, _T2&gt; <span class="title">make_pair</span><span class="params">(<span class="keyword">const</span> _T1&amp; __x, <span class="keyword">const</span> _T2&amp; __y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pair&lt;_T1, _T2&gt;(__x, __y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h3><p>整体实现上与<code>bit_vector</code>有些类似。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> _Nw&gt;<span class="comment">//使用时传入的bitset中的位数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Base_bitset</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> _WordT;</span><br><span class="line"></span><br><span class="line">    _WordT _M_w[_Nw];</span><br><span class="line">&#125;:</span><br></pre></td></tr></table></figure><h4 id="BITSET-WORDS"><a href="#BITSET-WORDS" class="headerlink" title="__BITSET_WORDS"></a>__BITSET_WORDS</h4><p>当我们声明一个<code>bitset</code>时，该宏定义用于计算出需要多少个<code>unsigned int</code>才能存储这些<code>bit</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __BITSET_WORDS(__n) ((__n) &lt; 1 ? 1 : ((__n) + __BITS_PER_WORD - 1)/__BITS_PER_WORD)</span></span><br></pre></td></tr></table></figure><p>由于操作系统位数不同，可能会带来歧义。该模块用于自动推导出<code>unsigned int</code>所占空间大小。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __BITS_PER_WORD (CHAR_BIT*sizeof(unsigned long))</span></span><br></pre></td></tr></table></figure><h4 id="Bit-count"><a href="#Bit-count" class="headerlink" title="_Bit_count"></a>_Bit_count</h4><p>该数组提供一个对照表用于判断角标所代表元素的二进制标志中<code>1</code>的个数。</p><p>如 $7=111_{(2)}$,故<code>_Bit_count[7] = 3</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> __dummy&gt; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Bit_count</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> _S_bit_count[<span class="number">256</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="First-one"><a href="#First-one" class="headerlink" title="_First_one"></a>_First_one</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> __dummy&gt; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">First_one</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> _S_first_one[<span class="number">256</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同样的，该数组也起到对照作用。该数组表示首个<code>1</code>开始，后面二进制值为<code>0</code>的个数。</p><p>如 $7 = 111_{(2)}$,故<code>_First_one[7] = 0</code></p><h4 id="S-whichword"><a href="#S-whichword" class="headerlink" title="_S_whichword"></a>_S_whichword</h4><p>获取比特位<code>__pos</code>在数组中的下标。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> _S_whichword( <span class="keyword">size_t</span> __pos )</span><br><span class="line">&#123; <span class="keyword">return</span> __pos / __BITS_PER_WORD; &#125;</span><br></pre></td></tr></table></figure><h4 id="S-whichbyte"><a href="#S-whichbyte" class="headerlink" title="_S_whichbyte"></a>_S_whichbyte</h4><p>获取在<code>word</code>中第几个char</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> _S_whichbyte( <span class="keyword">size_t</span> __pos )</span><br><span class="line">&#123; <span class="keyword">return</span> (__pos % __BITS_PER_WORD) / CHAR_BIT; &#125;</span><br></pre></td></tr></table></figure><h4 id="S-whichbit"><a href="#S-whichbit" class="headerlink" title="_S_whichbit"></a>_S_whichbit</h4><p>获取在<code>word</code>中第几个<code>bit</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> _S_whichbit( <span class="keyword">size_t</span> __pos )</span><br><span class="line">        &#123; <span class="keyword">return</span> __pos % __BITS_PER_WORD; &#125;</span><br></pre></td></tr></table></figure><h4 id="S-maskbit"><a href="#S-maskbit" class="headerlink" title="_S_maskbit"></a>_S_maskbit</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> _WordT;</span><br><span class="line"><span class="keyword">static</span> _WordT _S_maskbit( <span class="keyword">size_t</span> __pos )</span><br><span class="line">    &#123; <span class="keyword">return</span> (<span class="keyword">static_cast</span>&lt;_WordT&gt;(<span class="number">1</span>)) &lt;&lt; _S_whichbit(__pos); &#125;</span><br></pre></td></tr></table></figure><p>移位，以供<code>set  reset  flip</code>等调用</p><p>为实现一些功能，封装了一些简单函数</p><table><thead><tr><th align="center">函数</th><th align="center">含义</th><th align="center">调用</th></tr></thead><tbody><tr><td align="center">_M_do_and()</td><td align="center">bitset之间逻辑<strong>与</strong></td><td align="center">&amp;  &amp;=</td></tr><tr><td align="center">_M_do_or()</td><td align="center">bitset之间逻辑<strong>或</strong></td><td align="center">|  |=</td></tr><tr><td align="center">_M_do_xor()</td><td align="center">bitset之间逻辑<strong>异或</strong></td><td align="center">^  ^=</td></tr><tr><td align="center">_M_do_flip()</td><td align="center">逐元素取反</td><td align="center">flip()  ~</td></tr><tr><td align="center">_M_do_left_shift()</td><td align="center">左移</td><td align="center">&lt;&lt;  &lt;&lt;=</td></tr><tr><td align="center">_M_do_right_shift()</td><td align="center">右移</td><td align="center">&gt;&gt;  &gt;&gt;=</td></tr><tr><td align="center">_M_do_set()</td><td align="center">置为1</td><td align="center">set()</td></tr><tr><td align="center">_M_do_reset()</td><td align="center">置为0</td><td align="center">reset()</td></tr><tr><td align="center">_M_is_equal()</td><td align="center">判断是否相等</td><td align="center">==  !=</td></tr><tr><td align="center">_M_is_any()</td><td align="center">是否有值为<code>1</code>的位</td><td align="center">any()  none()</td></tr><tr><td align="center">_M_do_count()</td><td align="center">值为<code>1</code>的位的个数</td><td align="center">count()</td></tr><tr><td align="center">_M_do_to_ulong()</td><td align="center">01串转换成整数</td><td align="center">to_ulong()</td></tr><tr><td align="center">_M_copy_to_string()</td><td align="center">赋值给string</td><td align="center">to_string()</td></tr></tbody></table><h4 id="重载cin-cout"><a href="#重载cin-cout" class="headerlink" title="重载cin/cout"></a>重载cin/cout</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> _Nb&gt;</span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; __is, bitset&lt;_Nb&gt;&amp; __x) &#123;</span><br><span class="line">    string __tmp;</span><br><span class="line">    __tmp.<span class="built_in">reserve</span>(_Nb);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__is.<span class="built_in">flags</span>() &amp; ios::skipws) &#123;</span><br><span class="line">        <span class="keyword">char</span> __c;</span><br><span class="line">        <span class="keyword">do</span> </span><br><span class="line">            __is.<span class="built_in">get</span>(__c);</span><br><span class="line">        <span class="keyword">while</span> (__is &amp;&amp; <span class="built_in">isspace</span>(__c));</span><br><span class="line">        <span class="keyword">if</span> (__is)</span><br><span class="line">            __is.<span class="built_in">putback</span>(__c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> __i = <span class="number">0</span>; __i &lt; _Nb; ++__i) &#123;</span><br><span class="line">        <span class="keyword">char</span> __c;</span><br><span class="line">        __is.<span class="built_in">get</span>(__c);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!__is)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (__c != <span class="string">&#x27;0&#x27;</span> &amp;&amp; __c != <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">            __is.<span class="built_in">putback</span>(__c);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            __tmp.<span class="built_in">push_back</span>(__c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__tmp.<span class="built_in">empty</span>()) </span><br><span class="line">        __is.<span class="built_in">clear</span>(__is.<span class="built_in">rdstate</span>() | ios::failbit);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        __x._M_copy_from_string(__tmp, <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(<span class="number">0</span>), _Nb);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> __is;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出 以字符串形式输出</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> _Nb&gt;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; __os, <span class="keyword">const</span> bitset&lt;_Nb&gt;&amp; __x) &#123;</span><br><span class="line">    string __tmp;</span><br><span class="line">    __x._M_copy_to_string(__tmp);</span><br><span class="line">    <span class="keyword">return</span> __os &lt;&lt; __tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="hashtable"><a href="#hashtable" class="headerlink" title="hashtable"></a>hashtable</h3><p>哈希表的链式避免冲突法在成链时，新插入的元素在头部。（头插）</p><h4 id="结点"><a href="#结点" class="headerlink" title="结点"></a>结点</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Val</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Hashtable_node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _Hashtable_node* _M_next;<span class="comment">//用于链式连接</span></span><br><span class="line">  _Val _M_val;</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Val</span>, <span class="keyword">class</span> _<span class="title">Key</span>, <span class="keyword">class</span> _<span class="title">HashFcn</span>,</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> _<span class="title">ExtractKey</span>, <span class="keyword">class</span> _<span class="title">EqualKey</span>, <span class="keyword">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Hashtable_iterator</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> hashtable&lt;_Val,_Key,_HashFcn,_ExtractKey,_EqualKey,_Alloc&gt; _Hashtable;</span><br><span class="line">    <span class="keyword">typedef</span> _Hashtable_node&lt;_Val&gt; _Node; <span class="comment">// hash table 节点</span></span><br><span class="line">    <span class="keyword">typedef</span> forward_iterator_tag iterator_category; <span class="comment">// 迭代器类型：前向迭代器</span></span><br><span class="line"></span><br><span class="line">    _Node* _M_cur; <span class="comment">// 迭代器目前所指的节点</span></span><br><span class="line">    _Hashtable* _M_ht; <span class="comment">// 保持对容器的连接关系，bucket</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="bucket"><a href="#bucket" class="headerlink" title="bucket"></a>bucket</h4><p>一共提供28个bucket大小。设置的原则为，2倍扩充附近的质数。分别如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> __stl_num_primes = <span class="number">28</span> &#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> __stl_prime_list[__stl_num_primes] =</span><br><span class="line">&#123;</span><br><span class="line">  <span class="number">53ul</span>,         <span class="number">97ul</span>,         <span class="number">193ul</span>,       <span class="number">389ul</span>,       <span class="number">769ul</span>,</span><br><span class="line">  <span class="number">1543ul</span>,       <span class="number">3079ul</span>,       <span class="number">6151ul</span>,      <span class="number">12289ul</span>,     <span class="number">24593ul</span>,</span><br><span class="line">  <span class="number">49157ul</span>,      <span class="number">98317ul</span>,      <span class="number">196613ul</span>,    <span class="number">393241ul</span>,    <span class="number">786433ul</span>,</span><br><span class="line">  <span class="number">1572869ul</span>,    <span class="number">3145739ul</span>,    <span class="number">6291469ul</span>,   <span class="number">12582917ul</span>,  <span class="number">25165843ul</span>,</span><br><span class="line">  <span class="number">50331653ul</span>,   <span class="number">100663319ul</span>,  <span class="number">201326611ul</span>, <span class="number">402653189ul</span>, <span class="number">805306457ul</span>, </span><br><span class="line">  <span class="number">1610612741ul</span>, <span class="number">3221225473ul</span>, <span class="number">4294967291ul</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="hashtable-1"><a href="#hashtable-1" class="headerlink" title="hashtable"></a>hashtable</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Val</span>, <span class="keyword">class</span> _<span class="title">Key</span>, <span class="keyword">class</span> _<span class="title">HashFcn</span>,</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> _<span class="title">ExtractKey</span>, <span class="keyword">class</span> _<span class="title">EqualKey</span>, <span class="keyword">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hashtable</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _Key key_type; <span class="comment">// 节点的键值</span></span><br><span class="line">    <span class="keyword">typedef</span> _Val value_type; <span class="comment">// 节点的实值</span></span><br><span class="line">    <span class="keyword">typedef</span> _HashFcn hasher; <span class="comment">// 哈希函数</span></span><br><span class="line">    <span class="keyword">typedef</span> _EqualKey key_equal; <span class="comment">// 判断键值是否相同</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _Hashtable_node&lt;_Val&gt; _Node; <span class="comment">// 节点</span></span><br><span class="line">    hasher                _M_hash;</span><br><span class="line">    key_equal             _M_equals;</span><br><span class="line">    _ExtractKey           _M_get_key;</span><br><span class="line">    vector&lt;_Node*,_Alloc&gt; _M_buckets; <span class="comment">// vector 容器</span></span><br><span class="line">    size_type             _M_num_elements;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>_Val  —  节点的实值类型</p></li><li><p>_Key  —  节点的键值类型</p></li><li><p>_HashFcn  —  哈希函数的类型</p></li><li><p>_ExtractKey  —  从节点中取出键值的方法</p></li><li><p>_EqualKey  —  判断键值是否相同的方法</p></li><li><p>_Alloc  —  空间配置器</p></li></ul><h4 id="bkt-num"><a href="#bkt-num" class="headerlink" title="bkt_num"></a>bkt_num</h4><p>我们知道可以通过<code>Key</code>来获取到元素相应的<code>bucket</code>、重复的个数等信息。利用该函数，可以通过<code>Value</code>获取到相应信息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">size_type _M_bkt_num(<span class="keyword">const</span> value_type&amp; __obj) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _M_bkt_num_key(_M_get_key(__obj));</span><br><span class="line">&#125;</span><br><span class="line">size_type _M_bkt_num(<span class="keyword">const</span> value_type&amp; __obj, <span class="keyword">size_t</span> __n) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _M_bkt_num_key(_M_get_key(__obj), __n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//向上寻定义_ExtractKey           _M_get_key;</span></span><br></pre></td></tr></table></figure><h4 id="stl-hash-string"><a href="#stl-hash-string" class="headerlink" title="__stl_hash_string"></a>__stl_hash_string</h4><p>各种数字(<code>int</code>、<code>unsigned int</code>、<code>long</code>、<code>unsigned long</code>、<code>short</code>)以及字符<code>char</code>进行传入的是原值、除此之外字符串类型(<code>char*</code>)会进行转换:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">size_t</span> __stl_hash_string(<span class="keyword">const</span> <span class="keyword">char</span>* __s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> __h = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> ( ; *__s; ++__s)</span><br><span class="line">        __h = <span class="number">5</span>*__h + *__s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">size_t</span>(__h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="hashmap-hashset"><a href="#hashmap-hashset" class="headerlink" title="hashmap/hashset"></a>hashmap/hashset</h3><p><code>hash_set/hash_map</code> 底层实现机制是<code> hash table</code>，所以 <code>hash_set/hash_map</code> 内部实现就是封装<code>hashtable</code>类。与map/set和<code>multimap/multiset</code>基于红黑树改装类似，再次不过多赘述。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> SGI_STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL源码剖析</title>
      <link href="/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
      <url>/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>本文是我在学习候捷《STL标准库和泛型编程》课程时所做的笔记，在此分享给大家。</p><span id="more"></span><h2 id="STL源码剖析"><a href="#STL源码剖析" class="headerlink" title="STL源码剖析"></a>STL源码剖析</h2><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>所有新式header的组件，都封装于“std”命名空间下。</p><h3 id="STL六大件"><a href="#STL六大件" class="headerlink" title="STL六大件"></a>STL六大件</h3><p>容器(Container)、算法(Algorithm)、分配器(Allocator)、迭代器(Iterator)、适配器(Adapter)、仿函数(Functor)</p><h4 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h4><p><img src="/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/image-20220611144209099.png" alt="image-20220611144209099"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">6</span>] = &#123;<span class="number">2</span>, <span class="number">52</span>, <span class="number">365</span>, <span class="number">37</span>, <span class="number">587</span>, <span class="number">23</span>&#125;;</span><br><span class="line">vector&lt;<span class="keyword">int</span>, allocator&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">vi</span>(ia, ia + <span class="number">6</span>);</span><br><span class="line">cout &lt;&lt; <span class="built_in">count_if</span>(vi.<span class="built_in">begin</span>(), vi.<span class="built_in">end</span>(), <span class="built_in">not1</span>(<span class="built_in">bind2nd</span>(less&lt;<span class="keyword">int</span>&gt;(), <span class="number">40</span>)));</span><br><span class="line"><span class="comment">//寻找范围内所有大于等于40的元素</span></span><br></pre></td></tr></table></figure><p><code>vector</code>容器。<code>allocator&lt;int&gt;</code>分配器。<code>vi.begin()</code>迭代器。<code>count_if()</code>算法。<code>not1</code>仿函数适配器。<code>less&lt;int&gt;()</code>仿函数。<code>bind2nd(a,b)</code>适配器，绑定第二参数。<code>not1()</code>适配器，否定相应内容。<br><code>not1(bind2nd(less&lt;int&gt;(), 40))</code>predicate，判断条件。<br><code>x.begin(),x.end()</code>维持的是左闭右开区间，<code>x.end()</code>指向最后一个元素的<mark>下一位置</mark>。</p><h4 id="迭代器遍历"><a href="#迭代器遍历" class="headerlink" title="迭代器遍历"></a>迭代器遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Container&lt;T&gt; c;</span><br><span class="line"><span class="keyword">for</span>(Container&lt;T&gt;::iterator iter = c.<span class="built_in">begin</span>(); iter!=c.<span class="built_in">end</span>(); ++iter)</span><br></pre></td></tr></table></figure><h3 id="容器分类"><a href="#容器分类" class="headerlink" title="容器分类"></a>容器分类</h3><p>红色部分为C++11新特性。<br><img src="/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/image-20220611144350303.png" alt="image-20220611144350303"></p><h4 id="顺序型容器"><a href="#顺序型容器" class="headerlink" title="顺序型容器"></a>顺序型容器</h4><h5 id="array"><a href="#array" class="headerlink" title="array"></a>array</h5><p>只是将数组封装成class。<br><code>size()、front()、back()</code>可用<br>声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array&lt;type,SIZE&gt; arr;</span><br><span class="line"><span class="comment">//必须声明类型及大小</span></span><br><span class="line">arr.<span class="built_in">data</span>()    <span class="comment">//起始地址</span></span><br></pre></td></tr></table></figure><h5 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h5><p>变长数组（尾部可变）</p><h5 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h5><p>两端可扩。是分段连续的。<br>每段一个buffer，每个buffer可以存储一定的元素（满，进入下一个buffer），buffer两端可扩展。</p><h5 id="list"><a href="#list" class="headerlink" title="list"></a>list</h5><p>双向链表。</p><h5 id="forward-list"><a href="#forward-list" class="headerlink" title="forward-list"></a>forward-list</h5><p>单链表。单链表没有<code>push_back()</code>,而是<code>push_front()</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">forward_list&lt;<span class="keyword">int</span>&gt; fl;</span><br><span class="line">    fl.<span class="built_in">push_front</span>(<span class="number">1</span>);</span><br><span class="line">    fl.<span class="built_in">pop_front</span>();</span><br></pre></td></tr></table></figure><h4 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h4><p>由deque封装而来。</p><h5 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h5><h5 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h5><h4 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h4><p>key-value。通过key找value。查找更方便。<br><code>multi</code>key可重复。<code>unordered</code>迭代器易失效。</p><h5 id="set-multiset"><a href="#set-multiset" class="headerlink" title="set/multiset"></a>set/multiset</h5><p>底层红黑树。每个节点key即为value。</p><h5 id="map-multimap"><a href="#map-multimap" class="headerlink" title="map/multimap"></a>map/multimap</h5><p>底层红黑树。除key之外有value。</p><h5 id="unordered-set-multiset"><a href="#unordered-set-multiset" class="headerlink" title="unordered set/multiset"></a>unordered set/multiset</h5><p>底层链式防冲突哈希表。每个节点key即为value。</p><h5 id="unordered-map-multimap"><a href="#unordered-map-multimap" class="headerlink" title="unordered map/multimap"></a>unordered map/multimap</h5><p>底层链式防冲突哈希表。除key之外有value。</p><h3 id="分配器"><a href="#分配器" class="headerlink" title="分配器"></a>分配器</h3><p>在定义时候，带有默认值。可以不声明。以vector为例。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc = std::allocator&lt;_Tp&gt;&gt;</span><br><span class="line">class vector : protected_Vector_base&lt;_Tp, _Alloc&gt;&#123;</span><br><span class="line">    ...............</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="OOP-vs-GP"><a href="#OOP-vs-GP" class="headerlink" title="OOP vs GP"></a>OOP vs GP</h3><p>面向对象编程(<code>OOP</code>)企图将数据(data)和方法(method)关联一起。<br>泛型编程(<code>GP</code>)企图将数据(data)和方法(method)分开。<br>GP可以将容器和算法各自分开开发，通过iterator连接即可。（操作符重载显得很重要）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Compare&gt;</span></span><br><span class="line"><span class="function">   <span class="keyword">inline</span> <span class="keyword">const</span> _Tp&amp;</span></span><br><span class="line"><span class="function">   <span class="title">max</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __a, <span class="keyword">const</span> _Tp&amp; __b, _Compare __comp)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">     <span class="comment">//return __comp(__a, __b) ? __b : __a;</span></span><br><span class="line">     <span class="keyword">if</span> (__comp(__a, __b))</span><br><span class="line"><span class="keyword">return</span> __b;</span><br><span class="line">     <span class="keyword">return</span> __a;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="STL源码基础"><a href="#STL源码基础" class="headerlink" title="STL源码基础"></a>STL源码基础</h3><h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h4><p><code>:: . .* ?:</code>这四个运算符不能够重载</p><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><p>主要用到的是类模板、函数模板。除此之外，还用到了特化。<br>特化之前要有<code>template&lt;&gt;</code></p><h3 id="分配器-1"><a href="#分配器-1" class="headerlink" title="分配器"></a>分配器</h3><h4 id="operator-new-amp-malloc"><a href="#operator-new-amp-malloc" class="headerlink" title="operator new &amp; malloc"></a>operator new &amp; malloc</h4><p>内存分配的底层都是调用<code>operator new</code> 然后调用<code>malloc</code>。通过<code>malloc</code>，调用操作系统的api。<br>malloc所申请的内存，除所申请的内存外还有一些附加的额外开销。(因为释放时只传入指针，通过这些附加属性可以找到需要释放的地址。)</p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>set里面复合红黑树，<mark>非继承</mark>。两侧表示相应的<code>sizeof</code>大小，至于容器中存的元素多少，与容器大小无关。<br>下图中缩进表示复合关系。<br><img src="/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/image-20220611144437337.png" alt="image-20220611144437337"></p><h4 id="list-1"><a href="#list-1" class="headerlink" title="list"></a>list</h4><p>为了使迭代器更好的自增自减，一般均设计为类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_node</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">void</span> *void_pointer;</span><br><span class="line">    void_pointer prev;</span><br><span class="line">    void_pointer next;</span><br><span class="line">    T data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">list</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> list_node&lt;T&gt; list_node;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> list_node *link_type;</span><br><span class="line">    <span class="keyword">typedef</span> list_iterator&lt;T, T &amp;, T *&gt; iterator;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    link_type node;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="keyword">class</span> <span class="title">Ref</span>,<span class="keyword">class</span> <span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_iterator</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> list_iterator&lt;T,Ref,Ptr&gt; self;</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">    <span class="keyword">typedef</span> Ref reference;</span><br><span class="line">    <span class="keyword">typedef</span> list_node&lt;T&gt; *link_type;</span><br><span class="line">    <span class="comment">//difference_type 和 iterator_category省略。</span></span><br><span class="line">    link_type node;</span><br><span class="line">    reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (*node).data;</span><br><span class="line">    &#125;</span><br><span class="line">    pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中需要特别注意的是，很多运算符已经重载，在阅读过程中要注意其功能及调用次序。<br>根据运算符的性质，考虑其返回值类型。（前置++传回引用，后置++传值)。</p><h5 id="list底层"><a href="#list底层" class="headerlink" title="list底层"></a>list底层</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">List_node_base</span> &#123;</span></span><br><span class="line">  _List_node_base* _M_next;</span><br><span class="line">  _List_node_base* _M_prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">List_node</span> :</span> <span class="keyword">public</span> _List_node_base &#123;</span><br><span class="line">  _Tp _M_data; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">List_iterator_base</span> &#123;</span></span><br><span class="line">  _List_node_base* _M_node;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">List_base</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  _List_node&lt;_Tp&gt;* _M_node;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">list</span> :</span> <span class="keyword">protected</span> _List_base&lt;_Tp, _Alloc&gt; &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="iterator遵循的原则"><a href="#iterator遵循的原则" class="headerlink" title="iterator遵循的原则"></a>iterator遵循的原则</h4><p>trait,萃取。<br>algorithm要知道iterator的一些属性。 iterator共五种<code>associated type</code>。分别为(后面两种没有被使用过)</p><ul><li>iterator_category</li><li>difference_type</li><li>value_type</li><li>reference</li><li>pointer<br>以链表为例</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">List_iterator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> _List_iterator&lt;_Tp&gt;                _Self;</span><br><span class="line">    <span class="keyword">typedef</span> _List_node&lt;_Tp&gt;                    _Node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>                          difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> std::bidirectional_iterator_tag    iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp                                value_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp*                               pointer;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp&amp;                               reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>算法调用时，根据访问相应的类别，获取到相应的类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> I&gt;</span><br><span class="line"><span class="built_in">algorithm</span>(I first,I last) &#123;</span><br><span class="line">    I::iterator_category</span><br><span class="line">    I::difference_type</span><br><span class="line">    I::value_type</span><br><span class="line">    I::pointer</span><br><span class="line">    I::reference</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果传入的iterator不是class（比如指针），通过萃取机（中间件）获得相应的类型。</p><ul><li>间接询问</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Iterator&gt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::iterator_category iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::value_type        value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::difference_type   difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::pointer           pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::reference         reference;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><ul><li>偏特化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>&lt;</span>_Tp*&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp                         value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>                   difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp*                        pointer;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp&amp;                        reference;</span><br><span class="line">  &#125;;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>&lt;</span><span class="keyword">const</span> _Tp*&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp                         value_type; </span><br><span class="line">    <span class="comment">//value_type主要用来声明变量</span></span><br><span class="line">    <span class="comment">//如果是const，声明一个无法被赋值的变量，没有用。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>                   difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> _Tp*                  pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> _Tp&amp;                  reference;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><h4 id="vector-1"><a href="#vector-1" class="headerlink" title="vector"></a>vector</h4><p>vector 内部封装了三个迭代器<code>start</code>,<code>finish</code>,<code>end_of_storage</code>。<br>当容器填满时，在内存中分配另外一块两倍大小的空间。（造成迭代器失效）</p><h4 id="deque-1"><a href="#deque-1" class="headerlink" title="deque"></a>deque</h4><p>分段连续。内部有<code>start</code>、<code>finish</code>迭代器用来控制<code>map</code>（控制中心）首尾，<code>map</code>中的元素指向相应的<code>buffer</code>。<code>buffer</code>里存放具体的数据。为了维持<strong>连续</strong>这一假象，当触及到<code>buffer</code>边界时，会扩充。除此之外，内部还有<code>map_size</code>来判断大小。</p><p><code>__deque_buf_size</code>存在默认值，每个缓冲区大小为512字节，然后根据参数类型改变缓冲区可以存储的元素个数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">size_t</span> __deque_buf_size(<span class="keyword">size_t</span> __size) &#123;</span><br><span class="line">  <span class="keyword">return</span> __size &lt; <span class="number">512</span> ? <span class="built_in">size_t</span>(<span class="number">512</span> / __size) : <span class="built_in">size_t</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>deque</code>的构成:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">deque</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    iterator start;</span><br><span class="line">    iterator finish;</span><br><span class="line">    map_pointer map;</span><br><span class="line">    size_type map_size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">reference <span class="title">front</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> *start;&#125;</span><br><span class="line"><span class="function">reference <span class="title">back</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    iterator tmp = finish;</span><br><span class="line">    --tmp;</span><br><span class="line">    <span class="keyword">return</span> *tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> finish - start;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> finish == start;&#125;</span><br></pre></td></tr></table></figure><h5 id="deque迭代器"><a href="#deque迭代器" class="headerlink" title="deque迭代器"></a>deque迭代器</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">deque_iterator</span>&#123;</span></span><br><span class="line">    Elt_pointer cur;</span><br><span class="line">    Elt_pointer first;</span><br><span class="line">    Elt_pointer last;</span><br><span class="line">    Map_pointer node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="模拟连续空间"><a href="#模拟连续空间" class="headerlink" title="模拟连续空间"></a>模拟连续空间</h5><p>模拟连续空间主要是由<code>deque_iterator</code>实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *cur;</span><br><span class="line">&#125;</span><br><span class="line">pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个iterator之间距离:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">difference_type <span class="keyword">operator</span>-(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()) *(node - x.node - <span class="number">1</span>) + (cur - first) + (x.last - x.cur);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    node - x.node - 1     map中的完整缓冲区个数</span></span><br><span class="line"><span class="comment">    cur - first 尾迭代器buffer元素个数</span></span><br><span class="line"><span class="comment">    x.last - x.cur 头迭代器buffer元素个数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>++/–</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_node</span><span class="params">(map_pointer new_node)</span> </span>&#123;</span><br><span class="line">    node = new_node;</span><br><span class="line">    first = *new_node;</span><br><span class="line">    last = first +<span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self &amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">    ++cur;</span><br><span class="line">    <span class="comment">// 边界控制。跳下一个缓冲区</span></span><br><span class="line">    <span class="keyword">if</span>(cur == last) &#123;</span><br><span class="line">        <span class="built_in">set_node</span>(node + <span class="number">1</span>);</span><br><span class="line">        cur = first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    ++*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line">self &amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">    <span class="comment">// 边界控制 跳前一个缓冲区</span></span><br><span class="line">    <span class="keyword">if</span>(cur == first) &#123;</span><br><span class="line">        <span class="built_in">set_node</span>(node - <span class="number">1</span>);</span><br><span class="line">        cur = last;</span><br><span class="line">    &#125;</span><br><span class="line">    --cur;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">self <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123;</span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    --*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>+=/-=</p></blockquote><p>首先判断移动后的位置会不会跨越缓冲区边界。跨越则寻找合适位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">self&amp; <span class="keyword">operator</span>+=(difference_type n) &#123;</span><br><span class="line">    difference_type offset = n + (cur - first);</span><br><span class="line">    <span class="comment">// 不跨越缓冲区</span></span><br><span class="line">    <span class="keyword">if</span> (offset &gt;= <span class="number">0</span> &amp;&amp; offset &lt; <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>())) &#123;</span><br><span class="line">        cur += n;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//跨区</span></span><br><span class="line">        difference_type node_offset = offset &gt; <span class="number">0</span> ? offset / <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()) : -<span class="built_in">difference_type</span>((-offset - <span class="number">1</span>) / <span class="built_in">buffer_size</span>()) - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">set_node</span>(node + node_offset);</span><br><span class="line">        cur = first + (offset - node_offset * <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()));</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        三目运算符 </span></span><br><span class="line"><span class="comment">        true选项 offset / difference_type(buffer_size()) 正向 延伸 （+=）</span></span><br><span class="line"><span class="comment">        false选项 -difference_type((-offset - 1) / buffer_size()) - 1 反向延伸 (-=)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">self <span class="keyword">operator</span>+(difference_type n) <span class="keyword">const</span> &#123;</span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp += n;</span><br><span class="line">&#125;</span><br><span class="line">self &amp;<span class="keyword">operator</span>-=(different_type n) &#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span> += -n;</span><br><span class="line">&#125;</span><br><span class="line">self <span class="keyword">operator</span>-(different_type n) <span class="keyword">const</span> &#123;</span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp -= n;</span><br><span class="line">&#125;</span><br><span class="line">reference <span class="keyword">operator</span>[] (different_type n) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *(*<span class="keyword">this</span> + n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="stack-queue"><a href="#stack-queue" class="headerlink" title="stack/queue"></a>stack/queue</h5><p>底层容器可以是deque/list。此外，stack还可以选择vector作底层容器。<strong>默认</strong>是<code>deque</code>，在此基础上封装，调用<code>deque</code>去实现。</p><p>stack/queue不提供iterator，<mark>不允许遍历</mark>。</p><h4 id="RB-tree"><a href="#RB-tree" class="headerlink" title="RB_tree"></a>RB_tree</h4><ul><li><p>自平衡二叉搜索树。数据排列规则有利于<strong>插入</strong>和<strong>查找</strong>；</p></li><li><p><code>rb_tree</code>提供遍历功能。使用++遍历得到的结果是有序的(<code>sorted</code>)</p></li><li><p>不推荐<code>rb_tree</code>的<code>iterator</code>改值。（破坏排序规则）</p><ul><li>但并非编程层面禁止。<code>rb_tree</code>服务于<code>map</code>/<code>set</code>，而<code>map</code>允许改<code>value</code>值。</li></ul></li><li><p><code>rb_tree</code>提供两种插入<code>insert_unique()</code>和<code>insert_equal()</code>。表示是否允许key值重复。(multi)</p></li></ul><p>以下 $value = key + data$</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>,</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> <span class="title">Value</span>,  //<span class="title">value</span> =</span> key + data</span><br><span class="line">          <span class="class"><span class="keyword">class</span> <span class="title">KeyOfValue</span>, //在<span class="title">value</span>中捕获<span class="title">key</span>的方式</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> <span class="title">Compare</span>,    //<span class="title">key</span>比较方式</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;  <span class="comment">//底层分配器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">rb_tree</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> rb_tree_node&lt;Value&gt; rb_tree_node;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> rb_tree_node *link_type;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    size_type node_count;   <span class="comment">//rb_tree节点数量</span></span><br><span class="line">    link_type header;       <span class="comment">//不放值，指向根节点</span></span><br><span class="line">    Compare key_compare;    <span class="comment">//大小比较规则。是函数对象。</span></span><br><span class="line">&#125;;</span><br><span class="line">rb_tree&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, identity&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt;, alloc&gt; TreeNode;</span><br><span class="line"><span class="comment">// 仿函数.将传入的东西返回.</span></span><br><span class="line"><span class="comment">// unary_function参数：元素类型、返回值类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">identity</span> :</span> <span class="keyword">public</span> unary_function&lt;T,T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> T &amp;<span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T &amp;x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 比较方式</span></span><br><span class="line"><span class="comment">// unary_function参数：元素类型、元素类型、返回值类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">less</span> :</span><span class="keyword">public</span> binary_function&lt;T,T,<span class="keyword">bool</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T &amp;x, <span class="keyword">const</span> T &amp;y)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一个红黑树节点包括<code>3ptr+1 enum =24 Bytes</code></p><p>3ptr:<code>parent</code>、<code>right</code>、<code>left</code></p><h5 id="set-multiset-1"><a href="#set-multiset-1" class="headerlink" title="set/multiset"></a>set/multiset</h5><ul><li><code>set/multiset</code>以<code>rb_tree</code>为底层，元素会自动排序(依据<code>key</code>)。</li><li><strong>禁止</strong>通过iterator改值。</li><li>set所有操作都对底层红黑树进行操作。可以理解为<strong>容器适配器</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>,</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> <span class="title">Compare</span> =</span> less&lt;Key&gt;,</span><br><span class="line">          <span class="class"><span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">set</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// typedefs</span></span><br><span class="line">    <span class="keyword">typedef</span> Key key_type;</span><br><span class="line">    <span class="keyword">typedef</span> Key value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Compare key_compare;</span><br><span class="line">    <span class="keyword">typedef</span> Compare value_compare;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> rb_tree&lt;key_type, value_type, identity&lt;value_type&gt;, key_compare, Alloc&gt; rep_type;</span><br><span class="line">    rep_type t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_iterator iterator;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="map-multimap-1"><a href="#map-multimap-1" class="headerlink" title="map/multimap"></a>map/multimap</h5><ul><li>以<code>rb_tree</code>为底层，元素会自动排序(依据<code>key</code>)。</li><li><strong>禁止</strong>通过iterator改<code>key</code>值，但可以改<code>data</code>($data = value - key$)通过将<code>key_type</code>指定为<code>const</code>实现。</li><li>map中可以用operator[]访问。存在，则修改<code>data</code>或访问。否则，创建节点。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>,</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> <span class="title">T</span>,</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> <span class="title">Compare</span> =</span> less&lt;Key&gt;,</span><br><span class="line">          <span class="class"><span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">map</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// typedefs</span></span><br><span class="line">    <span class="keyword">typedef</span> Key key_type;</span><br><span class="line">    <span class="keyword">typedef</span> T data_type;</span><br><span class="line">    <span class="keyword">typedef</span> T mapped_type;</span><br><span class="line">    <span class="keyword">typedef</span> pair&lt;<span class="keyword">const</span> Key, T&gt; value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Compare key_compare;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> rb_tree&lt;key_type, value_type, select1st&lt;value_type&gt;, key_compare, Alloc&gt; rep_type;</span><br><span class="line">    rep_type t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator iterator;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="hashtable"><a href="#hashtable" class="headerlink" title="hashtable"></a>hashtable</h4><ul><li><p>哈希冲突时再哈希时间复杂度过高，采用<mark>链式</mark>存储解决此问题。</p></li><li><p>每个<code>Hash(x)</code>值为一个<code>bucket</code>。</p></li><li><p>当元素个数超过bucket个数时，<code>rehash</code>。<code>bucket</code>个数通常为<strong>质数</strong>，每次<strong>扩充</strong>约为<strong>2倍</strong>。</p></li><li><p>可以通过<code>iterator</code>改data，但<strong>不能</strong>改<code>key</code>。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">hashtable_node</span> &#123;</span></span><br><span class="line">    __hashtable_node *next;</span><br><span class="line">    Value val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>,</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> <span class="title">Key</span>,</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> <span class="title">HashFcn</span>,</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> <span class="title">EXtractKey</span>,</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> <span class="title">EqualKey</span>,</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">hashtable_iterator</span> &#123;</span></span><br><span class="line">    node *cur;</span><br><span class="line">    hashtable *ht;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>,</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> <span class="title">Key</span>,</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> <span class="title">HashFcn</span>,    //哈希映射</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> <span class="title">EXtractKey</span>, //在所存取的数据中取<span class="title">key</span></span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> <span class="title">EqualKey</span>,   //给定元素比对的原则</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hashtable</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> HashFcn hasher;</span><br><span class="line">    <span class="keyword">typedef</span> EqualKey key_equal;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    hasher hash;</span><br><span class="line">    key_equal equals;</span><br><span class="line">    EXtractKey get_key;</span><br><span class="line">    <span class="keyword">typedef</span> __hashtable_node&lt;Value&gt; node;</span><br><span class="line">    vector&lt;node *, Alloc&gt; buckets;</span><br><span class="line">    size_type num_elements;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">size_type <span class="title">bucket_count</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buckets.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="modulus运算"><a href="#modulus运算" class="headerlink" title="modulus运算"></a>modulus运算</h5><p>通过计算得出元素该存放在哪个<code>bucket</code>。</p><p>$hash(key) \mod(n)$</p><p>c++11开始，<code>hashtable_xxx</code>更名为<code>unordered_xxx</code>。</p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器共五种</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_iterator_tag</span> &#123;</span>&#125;;<span class="comment">//</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">output_iterator_tag</span> &#123;</span>&#125;;<span class="comment">//</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">forward_iterator_tag</span>:</span> <span class="keyword">public</span> input_iterator_tag&#123;&#125;;<span class="comment">//单向</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bidirectional_iterator_tag</span>:</span> <span class="keyword">public</span> forward_iterator_tag&#123;&#125;;<span class="comment">//双向</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">random_access_iterator_tag</span>:</span> <span class="keyword">public</span> bidirectional_iterator_tag&#123;&#125;;<span class="comment">//随机访问</span></span><br></pre></td></tr></table></figure><p>调用时根据萃取机获取迭代器的类型(<code>iterator_category</code>)然后进行相应的调用。<br>不同类型的迭代器对元素访问的方式也不同，因此迭代器类型不同，可能会对算法有影响</p><p>样例如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> iterator_traits&lt;InputIterator&gt;::<span class="function">difference_type <span class="title">distance</span><span class="params">(InputIterator first,InputIterator last,input_iterator_tag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::iterator_category category n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">        ++first;</span><br><span class="line">        ++n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> iterator_traits&lt;RandomAccessIterator&gt;::difference_type _distance(RandomAccessIterator first,RandomAccessIterator last, random_access_iterator_tag) &#123;</span><br><span class="line">    <span class="keyword">return</span> last - first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> iterator_traits&lt;InputIterator&gt;::<span class="function">difference_type <span class="title">distance</span><span class="params">(InputIterator first,InputIterator last)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::iterator_category category;</span><br><span class="line">    <span class="keyword">return</span> _distance(first, last, <span class="built_in">category</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于上述算法只对<code>input_iterator</code> 和<code>random_access_iterator</code>进行了实现，当使用其他类型的迭代器(如<code>forward_iterator</code>)进行调用时，由于<code>forward_iterator</code><strong>继承</strong>自<code>input_iterator</code>，故调用对<code>input_iterator</code>实现的函数。</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>标准库中所有的<code>Algorithm</code>都看不见<code>Container</code>，而是通过<code>iterator</code>进行操作。</p><p><code>Algorithm</code>一定需要传入首尾<strong>两个迭代器</strong>。</p><p><code>xxx</code>,<code>xxx_if</code>,<code>xxx_copy</code>（如replace，replace_if）前一个是一个默认条件，<code>xxx_if</code>支持自己给出一个条件，<code>xxx_copy</code>不会改原值，而是返回一个新创建的序列。</p><h3 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h3><p>又叫函数对象，服务于算法。仿函数分类：</p><ul><li>算术类：plus(+)、minus(-)</li><li>逻辑运算类：logical_and</li><li>相对关系类：equal_to、less</li></ul><p><code>GNU C++</code>（GCC）有一些独有的仿函数：identity、select1st、select2nd。（<mark>非标准库</mark>）</p><h3 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h3><p>适配器、改造器。可分为容器适配器、迭代器适配器、仿函数适配器。修改一些对外的接口，使得相应的组件能够适配。</p><blockquote><p>仿函数适配器</p></blockquote><h4 id="binder2nd"><a href="#binder2nd" class="headerlink" title="binder2nd"></a>binder2nd</h4><p><code>bind2nd</code>为辅助函数，其底层仍为<code>binder2nd</code>。绑定第二实参。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Operation&gt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">binder2nd</span></span></span><br><span class="line"><span class="class">    :</span> <span class="keyword">public</span> unary_function&lt;<span class="keyword">typename</span> _Operation::first_argument_type,</span><br><span class="line">    <span class="keyword">typename</span> _Operation::result_type&gt;</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">      _Operation op;</span><br><span class="line">      <span class="keyword">typename</span> _Operation::second_argument_type value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">binder2nd</span>(<span class="keyword">const</span> _Operation&amp; __x,</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">typename</span> _Operation::second_argument_type&amp; __y)</span><br><span class="line">      : <span class="built_in">op</span>(__x), <span class="built_in">value</span>(__y) &#123; &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">typename</span> _Operation::result_type</span></span><br><span class="line"><span class="function">      <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">typename</span> _Operation::first_argument_type&amp; __x)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">      </span>&#123; <span class="keyword">return</span> <span class="built_in">op</span>(__x, value); &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// _GLIBCXX_RESOLVE_LIB_DEFECTS</span></span><br><span class="line">      <span class="comment">// 109.  Missing binders for non-const sequence elements</span></span><br><span class="line">      <span class="function"><span class="keyword">typename</span> _Operation::result_type</span></span><br><span class="line"><span class="function">      <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">typename</span> _Operation::first_argument_type&amp; __x)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">      </span>&#123; <span class="keyword">return</span> <span class="built_in">op</span>(__x, value); &#125;</span><br><span class="line">    &#125; _GLIBCXX_DEPRECATED;</span><br></pre></td></tr></table></figure><p><code>typedef typename xxx xx</code>中的<code>typename</code>主要用于告诉编译器<code>xxx</code>的类型，以方便编译器能够更好的识别。</p><p>现版本的<code>binder2nd、binder1st</code>被<code>bind</code>替代。</p><h4 id="not1"><a href="#not1" class="headerlink" title="not1"></a>not1</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; class Predicate &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> std::unary_negate&lt;Predicate&gt; <span class="title">not1</span><span class="params">(<span class="keyword">const</span> Predicate&amp; pred)</span></span>;</span><br></pre></td></tr></table></figure><p>用于创建函数对象的辅助函数，该函数对象返回所传递的<strong>一元</strong>(同理，not2创建的是二元)谓词函数的补码。</p><h5 id="一元、二元"><a href="#一元、二元" class="headerlink" title="一元、二元"></a>一元、二元</h5><p>元表示的是操作数的个数。一元(<code>unary</code>)如less（＜<code>xxx</code>）。二元(<code>binary</code>)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Arg</span>,<span class="keyword">class</span> _<span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">unary_function</span></span></span><br><span class="line"><span class="class">&#123;</span><span class="comment">// base class for unary functions</span></span><br><span class="line"><span class="keyword">typedef</span> _Arg argument_type;</span><br><span class="line"><span class="keyword">typedef</span> _Result result_type;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// TEMPLATE STRUCT binary_function</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Arg1</span>,<span class="keyword">class</span> _<span class="title">Arg2</span>,<span class="keyword">class</span> _<span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binary_function</span></span></span><br><span class="line"><span class="class">&#123;</span><span class="comment">// base class for binary functions</span></span><br><span class="line"><span class="keyword">typedef</span> _Arg1 first_argument_type;</span><br><span class="line"><span class="keyword">typedef</span> _Arg2 second_argument_type;</span><br><span class="line"><span class="keyword">typedef</span> _Result result_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><p>取代了<code>bind1st,bind2nd</code>。可以绑定函数、仿函数、成员函数、成员变量。 返回值是仿函数。</p><p>以除法为例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">divide</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x/y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> x1 = <span class="built_in">bind</span>(divide,a,b);</span><br><span class="line">cout &lt;&lt; <span class="built_in">x1</span>(); <span class="comment">//a/b</span></span><br><span class="line"><span class="keyword">auto</span> x2 = <span class="built_in">bind</span>(divide,_1,b);</span><br><span class="line">cout &lt;&lt; <span class="built_in">x2</span>(x); <span class="comment">//x/b</span></span><br><span class="line"><span class="keyword">auto</span> x3 = <span class="built_in">bind</span>(divide,_2,_1);</span><br><span class="line">cout &lt;&lt; <span class="built_in">x3</span>(x,y); <span class="comment">//y/x</span></span><br><span class="line"><span class="keyword">auto</span> x4 = bind&lt;<span class="keyword">int</span>&gt;(···)<span class="comment">//指定返回值类型</span></span><br></pre></td></tr></table></figure><p>bind()绑定成员变量时，有一个隐藏的参数<code>this指针</code></p><blockquote><p>迭代器适配器</p></blockquote><h4 id="reverse-iterator"><a href="#reverse-iterator" class="headerlink" title="reverse_iterator"></a>reverse_iterator</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="built_in">reverse_iterator</span>(<span class="built_in">end</span>());&#125;</span><br><span class="line"><span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="built_in">reverse_iterator</span>(<span class="built_in">begin</span>());&#125;</span><br></pre></td></tr></table></figure><p>在实现具体使用时，对<strong>逆向后的迭代器</strong>取值相当于把<strong>正向迭代器退一格</strong>取值。<code>reverse_iterator</code>的<code>++、--、+n、-n</code>也要逆序</p><h4 id="inserter"><a href="#inserter" class="headerlink" title="inserter"></a>inserter</h4><p>以第三参数传入，调用相应的运算符重载，在数组中指定位置插入相应的新数据（后面的数据会后移）</p><h4 id="ostream-iterator"><a href="#ostream-iterator" class="headerlink" title="ostream_iterator"></a>ostream_iterator</h4><p>可以简化输出过程。利用ostream_iterator。现有一个数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt;arr&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="function">ostream_iterator&lt;<span class="keyword">int</span>&gt; <span class="title">temp</span><span class="params">(cout,<span class="string">&quot;,&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">copy</span>(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>(),temp);</span><br><span class="line"><span class="comment">//输出1,2,3,4,5,6,7,</span></span><br></pre></td></tr></table></figure><p><code>cout</code>是输出流，<code>ostream_iterator</code>将指定内容写入流中。</p><h4 id="istream-iterator"><a href="#istream-iterator" class="headerlink" title="istream_iterator"></a>istream_iterator</h4><p>输入流。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">istream_iterator&lt;<span class="keyword">double</span>&gt;eos;<span class="comment">//end-of-stream</span></span><br><span class="line">istream_iterator&lt;<span class="keyword">double</span>&gt;<span class="built_in">iit</span>(cin);</span><br><span class="line"><span class="keyword">if</span>(iit!=eos)</span><br><span class="line">    value1=*iit; <span class="comment">//取第一个值</span></span><br><span class="line">++iit;</span><br><span class="line"><span class="keyword">if</span>(iit!=eos)</span><br><span class="line">    value2=*iit;<span class="comment">//取第二个值</span></span><br><span class="line">cout&lt;&lt;value1 &lt;&lt;<span class="string">&quot;*&quot;</span>&lt;&lt;value2&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;value1*value2;</span><br></pre></td></tr></table></figure><h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><p>指定任意类型的任意元素。类似于一个临时创建的结构体。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tuple&lt;<span class="keyword">int</span>,<span class="keyword">double</span>,string&gt;<span class="built_in">t1</span>(<span class="number">41</span>,<span class="number">6.3</span>,<span class="string">&quot;niko&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> t2 = <span class="built_in">make_tuple</span>(<span class="number">41</span>,<span class="number">25</span>,<span class="string">&quot;zzz&quot;</span>);</span><br><span class="line">get&lt;<span class="number">0</span>&gt;(t1);<span class="comment">//取41</span></span><br></pre></td></tr></table></figure><p>tuple可以赋值、比较(相同类型依次比较元素)、直接cout输出。</p><p><code>tuple_size</code>可以知道元素的个数</p><p><code>tuple_element</code>可以知道元素的类型</p><p>利用可变模板元来实现的tuple。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Values&gt;<span class="class"><span class="keyword">class</span> <span class="title">tuple</span>;</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="class"><span class="keyword">class</span> <span class="title">tuple</span>&lt;</span>&gt;&#123;&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head,<span class="keyword">typename</span>... Tail&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">typle</span>&lt;</span>Head,Tail...&gt;:<span class="keyword">private</span> tuple&lt;Tail...&gt;&#123;</span><br><span class="line">    <span class="keyword">typedef</span> tuple&lt;Tail...&gt;inherited;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">tuple</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">tuple</span>(Head v, Tail... vtail):<span class="built_in">m_head</span>(v),<span class="built_in">inherited</span>(vtail...)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">typename</span> Head::type <span class="title">head</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> m_head;&#125;</span><br><span class="line">    inherited&amp; tail &#123;<span class="keyword">return</span> &amp;<span class="keyword">this</span>;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Head m_head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每次分为$1+x$.当最终没有参数时，执行<code>tuple&lt;&gt;</code>结束.</p><h3 id="type-traits"><a href="#type-traits" class="headerlink" title="type traits"></a>type traits</h3><p>将功能相同而参数不同的函数进行抽象</p><p>通过traits将不同的参数的相同属性提取出来，在函数中利用这些用traits提取的属性，使得函数对不同的参数表现一致。故，可实现在编译期计算、判断、转换、查询等等功能。</p><p><code>c++</code>为默认数据类型都提供了相应的类型萃取机制，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span>&lt;</span><span class="keyword">int</span>&gt;&#123;</span><br><span class="line">    <span class="keyword">typedef</span> __true_type has_trivial_default_constructor;</span><br><span class="line">    <span class="keyword">typedef</span> __true_type has_trivial_copy_constructor;</span><br><span class="line">    <span class="keyword">typedef</span> __true_type has_trivial_assignment_operator;</span><br><span class="line">    <span class="keyword">typedef</span> __true_type has_trivial_destructor;</span><br><span class="line">    <span class="keyword">typedef</span> __true_type is_POD_type; <span class="comment">// Plain Old Data</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="is-void"><a href="#is-void" class="headerlink" title="is_void"></a>is_void</h4><p>去除掉<code>const</code>和<code>volatile</code>之后返回类型。然后调用相应的辅助函数，如果有相应的参数（偏特化），则返回<code>true</code>，否则返回<code>false</code>。</p><p>进而扩展<code>is_class、is_union、is_enum、is_pod</code>，但并没有找到。</p><h3 id="cout"><a href="#cout" class="headerlink" title="cout"></a>cout</h3><p>cout对<code>&lt;&lt;</code>运算符的<strong>各种输入</strong>进行重载，以实现可以随意输出。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> 候捷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复数类</title>
      <link href="/%E5%A4%8D%E6%95%B0%E7%B1%BB/"/>
      <url>/%E5%A4%8D%E6%95%B0%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>本文主要根据候捷《面向对象高级开发》课程实现的一个复数类。所涉及的功能有 加减乘（除法我高中没学过）、以及对应的+=、-=、*=。还有取模、取反、求共轭复数、判断是否相同、输出等。代码将分模块的进行讲述，不想看可以直接滑到文末。文末会给出完整代码。</p><span id="more"></span><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>首先，实现的是类的初始化及对其数据成员的访问。<br>由于访问数据成员并不会修改其相应的值，可以设置为常函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="keyword">double</span> x, <span class="keyword">double</span> y) : <span class="built_in">re</span>(x), <span class="built_in">im</span>(y)&#123;&#125;</span><br><span class="line">    <span class="built_in">Complex</span>() : <span class="built_in">re</span>(<span class="number">0</span>), <span class="built_in">im</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">real</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> re; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">imag</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> im; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> re, im;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="取模"><a href="#取模" class="headerlink" title="取模"></a>取模</h2><p>取模，即输出 $\sqrt {re^2 +im^2}$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="keyword">this</span>-&gt;re * <span class="keyword">this</span>-&gt;re + <span class="keyword">this</span>-&gt;im * <span class="keyword">this</span>-&gt;im, <span class="number">0.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> re, im;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="共轭复数"><a href="#共轭复数" class="headerlink" title="共轭复数"></a>共轭复数</h2><p>共轭复数，即实部相同，虚部互为相反数。<br>求共轭复数，并不会改变原复数。故不返回引用类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Complex <span class="title">conj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(<span class="keyword">this</span>-&gt;re, -<span class="keyword">this</span>-&gt;im);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> re, im;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><h3 id="X"><a href="#X" class="headerlink" title="X="></a>X=</h3><p>先实现的是在原对象基础上修改的操作，+=，-=，*=。在原对象的基础上与另一个对象进行运算。<br>根据相关的运算性质，有着如下的代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Complex &amp;<span class="keyword">operator</span>+=(<span class="keyword">const</span> Complex &amp;c);</span><br><span class="line">    Complex &amp;<span class="keyword">operator</span>-=(<span class="keyword">const</span> Complex &amp;c);</span><br><span class="line">    Complex &amp;<span class="keyword">operator</span>*=(<span class="keyword">const</span> Complex &amp;c);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> re, im;</span><br><span class="line">    <span class="keyword">friend</span> Complex &amp;_plus(Complex *, <span class="keyword">const</span> Complex &amp;);</span><br><span class="line">    <span class="keyword">friend</span> Complex &amp;_minus(Complex *, <span class="keyword">const</span> Complex &amp;);</span><br><span class="line">    <span class="keyword">friend</span> Complex &amp;_times(Complex *, <span class="keyword">const</span> Complex &amp;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//  + </span></span><br><span class="line"><span class="keyword">inline</span> Complex &amp;_plus(Complex *ths, <span class="keyword">const</span> Complex &amp;c) &#123;</span><br><span class="line">    ths-&gt;re += c.re;</span><br><span class="line">    ths-&gt;im += c.im;</span><br><span class="line">    <span class="keyword">return</span> *ths;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// += Complex</span></span><br><span class="line"><span class="keyword">inline</span> Complex &amp; Complex::<span class="keyword">operator</span> += (<span class="keyword">const</span> Complex &amp; c) &#123;</span><br><span class="line">    <span class="keyword">return</span> _plus(<span class="keyword">this</span>, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  - </span></span><br><span class="line"><span class="keyword">inline</span> Complex &amp;_minus (Complex *ths, <span class="keyword">const</span> Complex &amp;c) &#123;</span><br><span class="line">    ths-&gt;re -= c.re;</span><br><span class="line">    ths-&gt;im -= c.im;</span><br><span class="line">    <span class="keyword">return</span> *ths;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -= Complex</span></span><br><span class="line"><span class="keyword">inline</span> Complex &amp; Complex::<span class="keyword">operator</span> -= (<span class="keyword">const</span> Complex &amp; c) &#123;</span><br><span class="line">    <span class="keyword">return</span> _minus(<span class="keyword">this</span>, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  * </span></span><br><span class="line"><span class="keyword">inline</span> Complex &amp;_times(Complex *ths, <span class="keyword">const</span> Complex &amp;c) &#123;</span><br><span class="line">    ths-&gt;re = ths-&gt;re * c.re - ths-&gt;im * c.im;</span><br><span class="line">    ths-&gt;im = ths-&gt;re * c.im + ths-&gt;im * c.re;</span><br><span class="line">    <span class="keyword">return</span> *ths;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// *= Complex</span></span><br><span class="line"><span class="keyword">inline</span> Complex &amp; Complex::<span class="keyword">operator</span>*=(<span class="keyword">const</span> Complex &amp; c) &#123;</span><br><span class="line">    <span class="keyword">return</span> _times(<span class="keyword">this</span>, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此外，还写出了相应的与纯实数进行运算。（纯实数可以是一个<code>int、double</code>等基本数据类型，而纯虚数是实部为0的对象，故不重复实现）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    Complex &amp;<span class="keyword">operator</span>+=(<span class="keyword">const</span> T num);</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    Complex &amp;<span class="keyword">operator</span>-=(<span class="keyword">const</span> T num);</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    Complex &amp;<span class="keyword">operator</span>*=(<span class="keyword">const</span> T num);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> re, im;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// += number</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> Complex &amp; Complex::<span class="keyword">operator</span> += (<span class="keyword">const</span> T num) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;re += num;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -= number</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> Complex &amp; Complex::<span class="keyword">operator</span> -= (<span class="keyword">const</span> T num) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;re -= num;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// *=number</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> Complex &amp; Complex::<span class="keyword">operator</span> *= (<span class="keyword">const</span> T num) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;re *= num;</span><br><span class="line">    <span class="keyword">this</span>-&gt;im *= num;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title="+-*"></a>+-*</h3><p>重载完带<code>=</code>的运算符后，开始重载基本的运算符，定义了三个基本操作 <code>+-*</code>分别实现两个复数间的<code>+-*</code><br>由于在类内部尝试重载时，发生相应的错误（参数个数过多），于是在类的外部定义了相应的功能函数。<br>在该部分，考虑到运算符左右的参数类型的问题，同样进行了重载。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Complex + Complex</span></span><br><span class="line"><span class="keyword">inline</span> Complex  <span class="keyword">operator</span>+ (<span class="keyword">const</span> Complex &amp; x,<span class="keyword">const</span> Complex &amp; y) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(x.<span class="built_in">real</span>() + y.<span class="built_in">real</span>(), x.<span class="built_in">imag</span>() + y.<span class="built_in">imag</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Complex + number</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;c, T num) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(c.<span class="built_in">real</span>() + num, c.<span class="built_in">imag</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// number + Complex</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>+(T num, <span class="keyword">const</span> Complex &amp;c) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(c.<span class="built_in">real</span>() + num, c.<span class="built_in">imag</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Complex - Complex</span></span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>-(<span class="keyword">const</span> Complex &amp;x, <span class="keyword">const</span> Complex &amp;y) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(x.<span class="built_in">real</span>() - y.<span class="built_in">real</span>(), x.<span class="built_in">imag</span>() - y.<span class="built_in">imag</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Complex - number</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>-(<span class="keyword">const</span> Complex &amp;c, T num) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(c.<span class="built_in">real</span>() - num, c.<span class="built_in">imag</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// number - Complex</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>-(T num, <span class="keyword">const</span> Complex &amp;c) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(num - c.<span class="built_in">real</span>(), -c.<span class="built_in">imag</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Complex * Complex</span></span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>*(<span class="keyword">const</span> Complex &amp;x, <span class="keyword">const</span> Complex &amp;y) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(x.<span class="built_in">real</span>() * y.<span class="built_in">real</span>() - x.<span class="built_in">imag</span>() * y.<span class="built_in">imag</span>(), x.<span class="built_in">real</span>() * y.<span class="built_in">imag</span>() + x.<span class="built_in">imag</span>() * y.<span class="built_in">real</span>());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Complex * number</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>*(<span class="keyword">const</span> Complex &amp;c, T num) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(c.<span class="built_in">real</span>() * num, c.<span class="built_in">imag</span>() * num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// number * Complex</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>*(T num, <span class="keyword">const</span> Complex &amp;c) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(c.<span class="built_in">real</span>() * num, c.<span class="built_in">imag</span>() * num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="取反（-X）"><a href="#取反（-X）" class="headerlink" title="取反（-X）"></a>取反（-X）</h3><p>私以为取反是用来赋值，故并未修改原对象的成员变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -Complex</span></span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>-(<span class="keyword">const</span> Complex &amp;c) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(-c.<span class="built_in">real</span>(), -c.<span class="built_in">imag</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（！-）"><a href="#（！-）" class="headerlink" title="==（！=）"></a>==（！=）</h3><p>实部虚部完全相同为相等，任一个不同则为不同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ==</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Complex &amp;x, <span class="keyword">const</span> Complex &amp;y) &#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">return</span></span> (x.<span class="built_in">real</span>() == y.<span class="built_in">real</span>()) &amp;&amp; (x.<span class="built_in">imag</span>() == y.<span class="built_in">imag</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// !=</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Complex &amp;x, <span class="keyword">const</span> Complex &amp;y) &#123;</span><br><span class="line">    <span class="comment">// return !(x == y);   //不是相同则为不同</span></span><br><span class="line">    <span class="built_in"><span class="keyword">return</span></span> (x.<span class="built_in">real</span>() != y.<span class="built_in">real</span>()) || (x.<span class="built_in">imag</span>() != y.<span class="built_in">imag</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>输出的格式为<code>a+b i</code>，考虑到美观性，额外的判断了下<code>a==0 b==0 b &lt; 0</code>的情况。即，<code>0+3i、1+0i、1+（-3）i</code>类型特殊化处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt;(ostream&amp; os,<span class="keyword">const</span> Complex &amp; c) &#123;</span><br><span class="line">    <span class="keyword">if</span> (c.<span class="built_in">real</span>() &amp;&amp; c.<span class="built_in">imag</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c.<span class="built_in">imag</span>() &gt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> os &lt;&lt; c.<span class="built_in">real</span>() &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; c.<span class="built_in">imag</span>() &lt;&lt; <span class="string">&quot;i&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> os &lt;&lt; c.<span class="built_in">real</span>() &lt;&lt; c.<span class="built_in">imag</span>() &lt;&lt; <span class="string">&quot;i&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c.<span class="built_in">real</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> os &lt;&lt; c.<span class="built_in">real</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> os &lt;&lt; c.<span class="built_in">imag</span>() &lt;&lt; <span class="string">&quot;i&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完整代码及部分测试"><a href="#完整代码及部分测试" class="headerlink" title="完整代码及部分测试"></a>完整代码及部分测试</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="keyword">double</span> x, <span class="keyword">double</span> y) : <span class="built_in">re</span>(x), <span class="built_in">im</span>(y)&#123;&#125;</span><br><span class="line">    <span class="built_in">Complex</span>() : <span class="built_in">re</span>(<span class="number">0</span>), <span class="built_in">im</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">real</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> re; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">imag</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> im; &#125;</span><br><span class="line">    Complex &amp;<span class="keyword">operator</span>+=(<span class="keyword">const</span> Complex &amp;c);</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    Complex &amp;<span class="keyword">operator</span>+=(<span class="keyword">const</span> T num);</span><br><span class="line"></span><br><span class="line">    Complex &amp;<span class="keyword">operator</span>-=(<span class="keyword">const</span> Complex &amp;c);</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    Complex &amp;<span class="keyword">operator</span>-=(<span class="keyword">const</span> T num);</span><br><span class="line"></span><br><span class="line">    Complex &amp;<span class="keyword">operator</span>*=(<span class="keyword">const</span> Complex &amp;c);</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    Complex &amp;<span class="keyword">operator</span>*=(<span class="keyword">const</span> T num);</span><br><span class="line"></span><br><span class="line">    <span class="function">Complex <span class="title">conj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(<span class="keyword">this</span>-&gt;re, -<span class="keyword">this</span>-&gt;im);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="keyword">this</span>-&gt;re * <span class="keyword">this</span>-&gt;re + <span class="keyword">this</span>-&gt;im * <span class="keyword">this</span>-&gt;im, <span class="number">0.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> re, im;</span><br><span class="line">    <span class="keyword">friend</span> Complex &amp;_plus(Complex *, <span class="keyword">const</span> Complex &amp;);</span><br><span class="line">    <span class="keyword">friend</span> Complex &amp;_minus(Complex *, <span class="keyword">const</span> Complex &amp;);</span><br><span class="line">    <span class="keyword">friend</span> Complex &amp;_times(Complex *, <span class="keyword">const</span> Complex &amp;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//  + </span></span><br><span class="line"><span class="keyword">inline</span> Complex &amp;_plus(Complex *ths, <span class="keyword">const</span> Complex &amp;c) &#123;</span><br><span class="line">    ths-&gt;re += c.re;</span><br><span class="line">    ths-&gt;im += c.im;</span><br><span class="line">    <span class="keyword">return</span> *ths;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  - </span></span><br><span class="line"><span class="keyword">inline</span> Complex &amp;_minus (Complex *ths, <span class="keyword">const</span> Complex &amp;c) &#123;</span><br><span class="line">    ths-&gt;re -= c.re;</span><br><span class="line">    ths-&gt;im -= c.im;</span><br><span class="line">    <span class="keyword">return</span> *ths;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  * </span></span><br><span class="line"><span class="keyword">inline</span> Complex &amp;_times(Complex *ths, <span class="keyword">const</span> Complex &amp;c) &#123;</span><br><span class="line">    ths-&gt;re = ths-&gt;re * c.re - ths-&gt;im * c.im;</span><br><span class="line">    ths-&gt;im = ths-&gt;re * c.im + ths-&gt;im * c.re;</span><br><span class="line">    <span class="keyword">return</span> *ths;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// += Complex</span></span><br><span class="line"><span class="keyword">inline</span> Complex &amp; Complex::<span class="keyword">operator</span> += (<span class="keyword">const</span> Complex &amp; c) &#123;</span><br><span class="line">    <span class="keyword">return</span> _plus(<span class="keyword">this</span>, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// += number</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> Complex &amp; Complex::<span class="keyword">operator</span> += (<span class="keyword">const</span> T num) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;re += num;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -= Complex</span></span><br><span class="line"><span class="keyword">inline</span> Complex &amp; Complex::<span class="keyword">operator</span> -= (<span class="keyword">const</span> Complex &amp; c) &#123;</span><br><span class="line">    <span class="keyword">return</span> _minus(<span class="keyword">this</span>, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -= number</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> Complex &amp; Complex::<span class="keyword">operator</span> -= (<span class="keyword">const</span> T num) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;re -= num;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// *= Complex</span></span><br><span class="line"><span class="keyword">inline</span> Complex &amp; Complex::<span class="keyword">operator</span>*=(<span class="keyword">const</span> Complex &amp; c) &#123;</span><br><span class="line">    <span class="keyword">return</span> _times(<span class="keyword">this</span>, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// *=number</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> Complex &amp; Complex::<span class="keyword">operator</span> *= (<span class="keyword">const</span> T num) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;re *= num;</span><br><span class="line">    <span class="keyword">this</span>-&gt;im *= num;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Complex + Complex</span></span><br><span class="line"><span class="keyword">inline</span> Complex  <span class="keyword">operator</span>+ (<span class="keyword">const</span> Complex &amp; x,<span class="keyword">const</span> Complex &amp; y) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(x.<span class="built_in">real</span>() + y.<span class="built_in">real</span>(), x.<span class="built_in">imag</span>() + y.<span class="built_in">imag</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Complex + number</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;c, T num) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(c.<span class="built_in">real</span>() + num, c.<span class="built_in">imag</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// number + Complex</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>+(T num, <span class="keyword">const</span> Complex &amp;c) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(c.<span class="built_in">real</span>() + num, c.<span class="built_in">imag</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Complex - Complex</span></span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>-(<span class="keyword">const</span> Complex &amp;x, <span class="keyword">const</span> Complex &amp;y) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(x.<span class="built_in">real</span>() - y.<span class="built_in">real</span>(), x.<span class="built_in">imag</span>() - y.<span class="built_in">imag</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Complex - number</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>-(<span class="keyword">const</span> Complex &amp;c, T num) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(c.<span class="built_in">real</span>() - num, c.<span class="built_in">imag</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// number - Complex</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>-(T num, <span class="keyword">const</span> Complex &amp;c) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(num - c.<span class="built_in">real</span>(), -c.<span class="built_in">imag</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -Complex</span></span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>-(<span class="keyword">const</span> Complex &amp;c) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(-c.<span class="built_in">real</span>(), -c.<span class="built_in">imag</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Complex * Complex</span></span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>*(<span class="keyword">const</span> Complex &amp;x, <span class="keyword">const</span> Complex &amp;y) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(x.<span class="built_in">real</span>() * y.<span class="built_in">real</span>() - x.<span class="built_in">imag</span>() * y.<span class="built_in">imag</span>(), x.<span class="built_in">real</span>() * y.<span class="built_in">imag</span>() + x.<span class="built_in">imag</span>() * y.<span class="built_in">real</span>());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Complex * number</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>*(<span class="keyword">const</span> Complex &amp;c, T num) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(c.<span class="built_in">real</span>() * num, c.<span class="built_in">imag</span>() * num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// number * Complex</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>*(T num, <span class="keyword">const</span> Complex &amp;c) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(c.<span class="built_in">real</span>() * num, c.<span class="built_in">imag</span>() * num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt;(ostream&amp; os,<span class="keyword">const</span> Complex &amp; c) &#123;</span><br><span class="line">    <span class="keyword">if</span> (c.<span class="built_in">real</span>() &amp;&amp; c.<span class="built_in">imag</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c.<span class="built_in">imag</span>() &gt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> os &lt;&lt; c.<span class="built_in">real</span>() &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; c.<span class="built_in">imag</span>() &lt;&lt; <span class="string">&quot;i&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> os &lt;&lt; c.<span class="built_in">real</span>() &lt;&lt; c.<span class="built_in">imag</span>() &lt;&lt; <span class="string">&quot;i&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c.<span class="built_in">real</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> os &lt;&lt; c.<span class="built_in">real</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> os &lt;&lt; c.<span class="built_in">imag</span>() &lt;&lt; <span class="string">&quot;i&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ==</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Complex &amp;x, <span class="keyword">const</span> Complex &amp;y) &#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">return</span></span> (x.<span class="built_in">real</span>() == y.<span class="built_in">real</span>()) &amp;&amp; (x.<span class="built_in">imag</span>() == y.<span class="built_in">imag</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// !=</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Complex &amp;x, <span class="keyword">const</span> Complex &amp;y) &#123;</span><br><span class="line">    <span class="comment">// return !(x == y);   //不是相同则为不同</span></span><br><span class="line">    <span class="built_in"><span class="keyword">return</span></span> (x.<span class="built_in">real</span>() != y.<span class="built_in">real</span>()) || (x.<span class="built_in">imag</span>() != y.<span class="built_in">imag</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">x</span><span class="params">(<span class="number">3</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">y</span><span class="params">(<span class="number">3</span>, <span class="number">-4</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; x.<span class="built_in">length</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; x * y &lt;&lt; endl;</span><br><span class="line">    x += <span class="number">2</span>;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; -x &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; (x == y.<span class="built_in">conj</span>())&lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; (x.<span class="built_in">conj</span>() != y) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; x + y &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="number">1</span> + x &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; y + <span class="number">3</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="number">2</span> * x &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 候捷 </tag>
            
            <tag> 代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/hello-world/"/>
      <url>/hello-world/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>正如学编程语言时首个程序是<code>Hello World!</code>一样，本blog亦是如此。</p><p>该网站旨在分享一些生活的点滴及秋招的经历。最初是在微信公众号分享，奈何修改、发表过于繁琐。后来尝试过csdn，但一些不可描述的原因又将我劝退，最终决定自己搭建网站。</p><p>当然了，建站还有一个很重要的原因是  —  装逼。</p><span id="more"></span><h2 id="残局"><a href="#残局" class="headerlink" title="残局"></a>残局</h2><p>endgame,残局。</p><p>csgo可谓是电子竞技中最精彩的赛事之一，他的精彩就表现在残局众多。残局，是一场比赛中最精彩、最充满期待同时也是有着最多遗憾的时刻。精彩在会有一个力挽狂澜、扭转乾坤的人出现；遗憾在纵使他的某次发挥再流传千古，可终究改变不了逆局。而此时此刻，恰如彼时彼刻。</p><h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>钱都花了，也该有点相应的规划。预想着在本网站发布一些算法刷题的经历、八股、面经以及将来实习、工作的经历，还有一些日常生活中的点滴（许久没学习的时候，水个内容）。当然了，还有另外一种可能——几天之后，<strong style="color:#e67c86;">删库跑路</strong>。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>奈何，本人才疏学浅，能力有限再加上语言表达能力不是很好，文章中难免会有些地方表达欠缺难以理解，甚至与事实相悖。遇到这种情况时，还望您能轻点骂，骂完能帮忙指出错误，避免我这一己之见误导了他人。网站里，留下了我的<a href="mailto:goudan.wang@outlook.com">邮箱</a>和微信号(<code>endgame_joker</code>)，如果您在阅读时有疑问、发现了错误又或者觉得这个人写的还可以，想交个朋友，欢迎联系我。</p><p>最后，为给您带来的不良阅读体验致歉。(本人亲测在<code>DARK REDAER</code>插件下图片阅读感极差，代码块的兼容性也较差)</p><hr><h2 id="2022-04-19更新"><a href="#2022-04-19更新" class="headerlink" title="2022/04/19更新"></a>2022/04/19更新</h2><p>关于技术性的文章，我觉得已有心无力。因为网上有着太多太多的资源，有着太多太多的博主们他们理解的比我深、讲的也比我更通透。以后，本blog更偏向于分享一些照片、读书笔记、沙雕日常亦或是吐槽。当然了，如果有我学的比较透彻的知识点（大概率是没有了），也会分享给大家。</p><hr><h2 id="2022-08-01更新"><a href="#2022-08-01更新" class="headerlink" title="2022/08/01更新"></a>2022/08/01更新</h2><p>说来惭愧，上面的flag鸽好久了。</p><ul><li>月报，就写了一次，感觉大多索然无味，没什么有意思的。</li><li>拍照，除了日常、沙雕瞬间也没怎么拍出有意境的照片</li><li>读书笔记，忙着实习、找工作也没有大把的时间让我坐下来好好看一本书（也好久没有看电影了）</li><li>沙雕日常，屁大点事没什么好写的</li><li><strong>再加上我就是个大懒蛋</strong></li></ul><p>种种原因吧，也没更新过。关于本站日后的走向可能更偏向于分享一下走过的路、踩过的坑、流过的血<del>、吹过的牛、爱过的人</del>以及一些学的比较通透的知识点。（也可以理解为记录我的成长）</p><p>然后，想分享一个<a href="https://www.bilibili.com/video/BV15a411T7RS">采访杜琪峰的视频</a>中的一段话。</p><blockquote><p>我不看以前，我反而觉得现在应该做点什么，因为过去我无法改变。<br>当时我的决定，是基于很多原因，形成了这个结果，这个结果改变不了，就像佛教里讲得</p><blockquote><p>我们不能改变那个“果”<br>因为那个“因”改变不了<br></p><p>怎么去改“果”呢</p></blockquote><p>反而今天要做好我现在看到的事，才能改变以后的事情，之前发生的结果是改不了的。</p></blockquote><p>我是个烂人，各种事都一团糟。祝愿看到这些文字的你，能被生活善待。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 关于我 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象</title>
      <link href="/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p>本文是我在学习候捷《面向对象高级开发》课程时所做的笔记，在此分享给大家。</p><span id="more"></span><h2 id="基于对象"><a href="#基于对象" class="headerlink" title="基于对象"></a>基于对象</h2><p>类从思考方式上大致分为两类</p><ul><li>不带指针。（complex）复数。内容在创建的时候已经是确定的（实部、虚部及相关的函数）</li><li>带指针。（string）字符串。只存了指针，当需要添加内容时，需要额外的创建空间。</li></ul><h3 id="设计重点"><a href="#设计重点" class="headerlink" title="设计重点"></a>设计重点</h3><ol><li>成员变量必须为private</li><li>参数尽可能的使用<mark>引用传递</mark>（const与否看情况）</li><li>尽可能的将<mark>返回值以引用形式</mark>传递</li><li>类本体里面注意应该加const的地方</li><li>尽量使用构造函数的初始化形式。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> _a,<span class="keyword">int</span> _b) : <span class="built_in">a</span>(_a),<span class="built_in">b</span>(_b) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基于对象-amp-amp-面向对象"><a href="#基于对象-amp-amp-面向对象" class="headerlink" title="基于对象 &amp;&amp; 面向对象"></a>基于对象 &amp;&amp; 面向对象</h3><p>Object-Based。设计<mark>单一</mark>的class。<br>Object-Oriented。面对多个class，涉及class与class的关系。</p><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p>防卫式声明（guard）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __xxxx__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __xxxx__</span></span><br><span class="line">.......</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>只有再第一次包含头文件时，才会导入库。</p><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p>在头文件里，大致分为三个部分。</p><ol><li>前置声明</li><li>类-声明</li><li>类-定义</li></ol><h3 id="私有构造函数"><a href="#私有构造函数" class="headerlink" title="私有构造函数"></a>私有构造函数</h3><p>当把构造函数设置在private区域时，表示该类不允许被创建对象。（设计模式-Singleton）</p><h3 id="function-const"><a href="#function-const" class="headerlink" title="function() const {}"></a>function() const {}</h3><p>设计不会改变数据内容的成员函数时（如：打印private成员变量），声明为const</p><h3 id="同一class的各个object互为friend"><a href="#同一class的各个object互为friend" class="headerlink" title="同一class的各个object互为friend"></a>同一class的各个object互为friend</h3><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>在实现运算符重载时，可以按照<code>(int)(30+10.5)</code>的形式，来强制转成类的临时对象。（该行运行结束即销毁）<code>Complex(5,4)</code></p><h3 id="拷贝构造"><a href="#拷贝构造" class="headerlink" title="拷贝构造"></a>拷贝构造</h3><p>类不写拷贝构造函数及拷贝赋值的话，会默认按bit进行拷贝。（带指针的类，需要自己去写）<br>如果没有写，只是复制了个指针（指针才是类内部的东西，字符数组是动态分配的）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用默认拷贝</span></span><br><span class="line">    <span class="function">String <span class="title">a</span><span class="params">(<span class="string">&quot;HELLO&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">b</span><span class="params">(<span class="string">&quot;WORLD&quot;</span>)</span></span>;</span><br><span class="line">    b = a;</span><br></pre></td></tr></table></figure><p>上述代码中，对象a的指针指向<code>HELLO</code>，对象b的指针指向<code>WORLD</code>，当执行b=a时，对象b拷贝对象a，两个对象的指针都指向原来对象a所指向的<code>HELLO</code>地址（浅拷贝），而<code>WORLD</code>所在地址已经造成内存泄漏。</p><h3 id="拷贝赋值"><a href="#拷贝赋值" class="headerlink" title="拷贝赋值"></a>拷贝赋值</h3><p>拷贝赋值时，要加上自我赋值检测（自我赋值delete-&gt;new时，delete删掉了相应的数据，无法new相同空间及拷贝内容）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span> == &amp;str)</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br></pre></td></tr></table></figure><h3 id="new-delete"><a href="#new-delete" class="headerlink" title="new/delete"></a>new/delete</h3><p>有<code>[]</code>的new要搭配有<code>[]</code>的delete使用。中括号表示的是数组(array)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * ptr = <span class="keyword">new</span> <span class="keyword">int</span>[];</span><br><span class="line"><span class="keyword">delete</span>[] ptr;</span><br></pre></td></tr></table></figure><p>有没有[]不影响这一个对象数组在内存中的删除，而是 有[]是表示删除整个数组，根据元素个数，调用多次分别释放各自动态分配的内存。而是数组中后面的指针所分配的内存没有被释放。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String* p = <span class="keyword">new</span> String[<span class="number">3</span>];</span><br><span class="line">......</span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure><p>上述代码中，有无[].3个String所占的内存都会被释放，而有[]会调用3次析构函数，即3个String对象中指针所指向的内存都会被释放，而delete只会调用一次析构函数，String[1],String[2]这两个对象中的指针所指向的内存并没有被释放。</p><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>静态变量要在类外进行定义（类内的static进行声明，不属于对象）。<br>多个对象的成员函数<mark>只有一份</mark><br>加在数据成员、成员函数前，表示为静态。所有对象<mark>共用</mark>一个<strong>静态</strong>成员。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt;c1.<span class="built_in">real</span>();</span><br><span class="line">cout &lt;&lt;c2.<span class="built_in">real</span>();</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">cout &lt;&lt;Complex::<span class="built_in">real</span>(&amp;c1);</span><br><span class="line">cout &lt;&lt;Complex::<span class="built_in">real</span>(&amp;c2);</span><br></pre></td></tr></table></figure><p>非静态的成员，以<code>this pointer</code>的形式去传，指针地址不同，调用不同的对象。<br>而静态的成员，属于类，是类负责存储。<mark>没有</mark><code>this pointer</code><br>e.g:银行系统，利率设置为静态。利息结算函数去处理静态的变量（利率）。<br>可以通过对象去调用静态变量，也可以通过类名直接调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> m_rate;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set_rate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; x)</span> </span>&#123;m_rate = x;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> Account::m_rate = <span class="number">5</span>; <span class="comment">//类外进行初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Account::<span class="built_in">set_rate</span>(<span class="number">3</span>); <span class="comment">//通过类名调用</span></span><br><span class="line">    Account a; a.<span class="built_in">set_rate</span>(<span class="number">6</span>); <span class="comment">//通过对象调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复合（Composition）"><a href="#复合（Composition）" class="headerlink" title="复合（Composition）"></a>复合（Composition）</h3><p>比如 队列、栈是基于双端队列来设计的。故队列、栈内部会包含双端队列这个类（内部存有其他数据结构）这个概念叫做复合。一些共用的功能，可以直接返回其底层容器的东西（empty()、size()函数），不需要的功能可以不开放，不引入进来（设计模式–Adapter）<br> Adapter是改装后的，不是被改装者。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">queue</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    deque&lt;T&gt; deq;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        deq.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="container-amp-component"><a href="#container-amp-component" class="headerlink" title="container &amp;component"></a>container &amp;component</h4><p>在上述过程中，container为队列（继承者），component为双端队列（被继承者）<br>Container构造时，先构造Component的构造函数，再构造自己的。析构时则相反。先调用自己的析构函数，再调用Component的析构函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Container::<span class="built_in">Container</span>(...):<span class="built_in">Component</span>()(......)</span><br><span class="line">Container::~<span class="built_in">Container</span>(...)&#123;......~<span class="built_in">Component</span>()&#125;</span><br><span class="line"><span class="comment">//上述代码中 六个点表示Container相应函数的实现</span></span><br></pre></td></tr></table></figure><h3 id="委托（Delegation）"><a href="#委托（Delegation）" class="headerlink" title="委托（Delegation）"></a>委托（Delegation）</h3><p>又叫 Composition by reference。<br>某个类的内部，成员变量中含有另一个类的对象的指针。（想用那个类的函数时，可以直接通过指针调用另一个类的函数，即将该功能委托给另一个类）。</p><p>Handle/Body<br>衍生设计模式：<br>    * 类的对外接口在该类内部实现，类的底层在被委托者里具体实现。</p><p>好处：对外接口不变，内部通过指针指向不同的实现类，从而改变底层。（底层变动不影响接口，从而不影响客户端。）即，底层改变时，编译时候只需要编译底层，不需要编译对外接口等。（节省时间）<br>而且可以多个不同的对外接口文件共用同一份底层代码。</p><h3 id="Composition-amp-Delegation"><a href="#Composition-amp-Delegation" class="headerlink" title="Composition &amp; Delegation"></a>Composition &amp; Delegation</h3><ul><li>生命周期不同<ul><li>Composition直接涵盖另一个类的源码，二者同生共死。</li><li>Delegation中另一个类对象的指针，只有调用时才创建。</li></ul></li></ul><h3 id="继承-amp-amp-虚函数"><a href="#继承-amp-amp-虚函数" class="headerlink" title="继承&amp;&amp;虚函数"></a>继承&amp;&amp;虚函数</h3><p>成员函数+virtual关键字。继承函数是继承的<mark>调用权</mark><br>设计模式（Template Method)。比如 各种软件打开文件功能，其打开步骤都是相似的（打开对话框、选择文件、检查文件是否存在、在磁盘里读取）这些基础动作基本相同，不同的是以什么形式读取。可以直接封装一个类实现这些基础功能，读取的具体实现，取决于软件继承这个类后去重写。这个东西也叫作Application framework。（应用框架），微软MFC是一个典型例子。</p><h3 id="继承-复合构造析构的顺序"><a href="#继承-复合构造析构的顺序" class="headerlink" title="继承+复合构造析构的顺序"></a>继承+复合构造析构的顺序</h3><p>派生类Component其余类对象时，派生类的构造/析构次序：<code>基类构造-&gt;复合类构造-&gt;自身构造</code>， <code>自身析构-&gt;复合类析构-&gt;基类析构。</code></p><h3 id="继承-委托"><a href="#继承-委托" class="headerlink" title="继承+委托"></a>继承+委托</h3><p>设计模式（Observer)某个文件内部包括多个查看操作的委托，该文件支持多个人同时查看。（内部可以增加注册、注销等功能以便于管理。）</p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="实现对象和非对象的运算"><a href="#实现对象和非对象的运算" class="headerlink" title="实现对象和非对象的运算"></a>实现对象和非对象的运算</h3><h4 id="conversion-function"><a href="#conversion-function" class="headerlink" title="conversion function"></a>conversion function</h4><p>类对象—&gt;非类的对象<br>转换函数conversion function。（比如分数类，实现分数和小数的转换）<br>以<code>operator</code>开头，函数名为返回值类型。不需要写返回值类型。也不需要参数。通常加上<code>const</code>(因为不需要改变内容)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Frac</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Frac</span>(<span class="keyword">double</span> _y, <span class="keyword">double</span> _x) : <span class="built_in">x</span>(_x), <span class="built_in">y</span>(_y)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>)y / x;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>至此，可以用一个数字去这个分数类进行运算。（无需重载运算符）</p><h4 id="non-explicit-one-argument-ctor"><a href="#non-explicit-one-argument-ctor" class="headerlink" title="non-explicit-one-argument ctor"></a>non-explicit-one-argument ctor</h4><p>非类的对象—&gt;类对象<br>non-explicit-one-argument ctor。要重载运算符。（整数默认分母是1，可以使得分母默认为1，只输入一个实参便可以）如果只写了分数间加法时，当调用分数+小数（整数）时，会调用相应的构造函数转换成分数再加。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Frac</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Frac</span>(<span class="keyword">double</span> _y, <span class="keyword">double</span> _x = <span class="number">1</span>) : <span class="built_in">x</span>(_x), <span class="built_in">y</span>(_y) &#123;&#125;</span><br><span class="line">    Frac <span class="keyword">operator</span>+(<span class="keyword">const</span> Frac &amp;f) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Frac</span>(...);</span><br><span class="line">        <span class="comment">//...为具体实现的方式</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>non-explicit-one-argument ctor与转换函数并存会产生二义性，报错。</li></ul><h4 id="explicit-one-argument-ctor"><a href="#explicit-one-argument-ctor" class="headerlink" title="explicit-one-argument ctor"></a>explicit-one-argument ctor</h4><p>explicit关键字放在<mark>构造函数前</mark>，告诉编译器，不会将非对象的参数转换为对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Frac</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Frac</span><span class="params">(<span class="keyword">double</span> _y, <span class="keyword">double</span> _x = <span class="number">1</span>)</span> : x(_x), y(_y) &#123;</span>&#125;</span><br><span class="line">    Frac <span class="keyword">operator</span>+(<span class="keyword">const</span> Frac &amp;f) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Frac</span>(...);</span><br><span class="line">        <span class="comment">//...为具体实现的方式</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//运行会报错。</span></span><br></pre></td></tr></table></figure><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>cpp的类大致分为两类，类的对象长得像指针的，长得像函数的。</p><h4 id="pointer-like-class"><a href="#pointer-like-class" class="headerlink" title="pointer-like class"></a>pointer-like class</h4><p>像指针的类。内部一定含有指针，实现一些比指针更高级的功能(智能指针)。作用在指针上的运算符(<code>*</code> 、 <code>-&gt;</code>等)要进行重载。<br>shared_ptr(智能指针)、 iterator(迭代器)</p><ul><li>shared_ptr。在不同类中，实现基本一致。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shared_ptr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T &amp;<span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> *px;</span><br><span class="line">    &#125;</span><br><span class="line">    T &amp;<span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> px;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">shared_ptr</span>(T *ptr) : <span class="built_in">px</span>(ptr)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *px;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">shared_ptr&lt;Foo&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> Foo)</span></span>;</span><br><span class="line"><span class="function">Foo <span class="title">f</span><span class="params">(*sp)</span></span>;</span><br><span class="line">sp-&gt;<span class="built_in">function</span>(); <span class="comment">// &lt;==&gt;  px-&gt;function();</span></span><br></pre></td></tr></table></figure><ul><li>iterator。根据功能不同会改动，且会重载其他运算符（如 自增、自减）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Ref</span>, <span class="keyword">class</span> <span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">list_iterator</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> __list_iterator&lt;T, Ref, Ptr&gt; self;</span><br><span class="line">    <span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">    <span class="keyword">typedef</span> Ref reference;</span><br><span class="line">    <span class="keyword">typedef</span> __list_node&lt;T&gt; *link_type;</span><br><span class="line">    link_type node;</span><br><span class="line">    ... </span><br><span class="line">    reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> (*node).data; &#125;</span><br><span class="line">    pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">list&lt;Foo&gt;::iterator iter;</span><br><span class="line">*iter; <span class="comment">//获取Foo对象</span></span><br><span class="line">iter-&gt;<span class="built_in">function</span>();    <span class="comment">//调用Foo::function();</span></span><br><span class="line"><span class="comment">// iter-&gt;function() &lt;==&gt; *(iter).function() &lt;==&gt; (&amp;(*iter))-&gt;function()</span></span><br></pre></td></tr></table></figure><h4 id="function-like-class"><a href="#function-like-class" class="headerlink" title="function-like class"></a>function-like class</h4><p>像函数的类。仿函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">identity</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> T &amp;<span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T &amp;x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">select1st</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">typename</span> Pair::first_type &amp;<span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Pair &amp;x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x.first; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">select2nd</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">typename</span> Pair::second_type &amp;<span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Pair &amp;x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x.second; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h3><p>命名空间。用于分隔开不同开发团队的成果（防止名字冲突，具有二义性）</p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><h4 id="class-template"><a href="#class-template" class="headerlink" title="class template"></a>class template</h4><p>类模板。参考复数类。成员变量类型、成员函数的返回值类型可以用模板替换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="keyword">double</span> x, <span class="keyword">double</span> y) : <span class="built_in">re</span>(x), <span class="built_in">im</span>(y)&#123;&#125;</span><br><span class="line">    <span class="built_in">Complex</span>() : <span class="built_in">re</span>(<span class="number">0</span>), <span class="built_in">im</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="function">T <span class="title">real</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> re; &#125;</span><br><span class="line">    <span class="function">T <span class="title">imag</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> im; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T re, im;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Complex&lt;<span class="keyword">int</span>&gt; <span class="title">c</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="function-template"><a href="#function-template" class="headerlink" title="function template"></a>function template</h4><p>函数模板。有一些函数，所实现的功能很通用。可以直接封装成函数模板。（一些其他类重载运算符）编译器会根据传入值自动推导相应的类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">const</span> T&amp; <span class="title">min</span> <span class="params">(cosntT&amp; a,constT&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? b : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="member-function"><a href="#member-function" class="headerlink" title="member function"></a>member function</h4><p>成员模板。模板里面嵌套模板。常用于标准库中，用某一个数据类型的变量来初始化另一个数据类型的变量。<br>比如，现在封装了一个鱼类，以及一个鲫鱼类。<br>我们声明了一个鲫鱼对象，用他去初始化一个鱼类对象。（构造函数更有弹性）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pair</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T1 first_type;</span><br><span class="line">    <span class="keyword">typedef</span> T2 second_type;</span><br><span class="line">    T1 first;</span><br><span class="line">    T2 second;</span><br><span class="line">    <span class="built_in">pair</span>() : <span class="built_in">first</span>(<span class="built_in">T1</span>()), <span class="built_in">second</span>(<span class="built_in">T2</span>())&#123;&#125;</span><br><span class="line">    <span class="built_in">pair</span>(<span class="keyword">const</span> T1 &amp;a, <span class="keyword">const</span> T2 &amp;b) : <span class="built_in">first</span>(a), <span class="built_in">second</span>(b)&#123;&#125;</span><br><span class="line">    <span class="function">temppalte&lt;class U1, classU2&gt;</span></span><br><span class="line"><span class="function">    <span class="title">pair</span><span class="params">(<span class="keyword">const</span> pair&lt;U1, U2&gt; &amp;p)</span> : first(p.first), second(p.second)&#123;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="模板特化"><a href="#模板特化" class="headerlink" title="模板特化"></a>模板特化</h3><p>specialization。通过模板实现了泛化，而其中一些东西可能并不太适用，会有些不同，需要特殊处理（特化）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过模板泛化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&#123;</span>&#125;;</span><br><span class="line"><span class="comment">//当输入类型为指定类型时，进行特化处理</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;</span><span class="keyword">char</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">char</span> x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;</span><span class="keyword">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span> * x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="偏特化"><a href="#偏特化" class="headerlink" title="偏特化"></a>偏特化</h3><p>局部特化，可以从个数、范围上产生差异。</p><ul><li>个数。比如模板的参数有2个，可以绑定部分参数。（bool类型用特定的底层做容器容易浪费，偏特化处理）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> Alloc=...&gt;</span><br><span class="line">class vector</span><br><span class="line">&#123;</span><br><span class="line">    ...<span class="comment">//具体实现略</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Alloc=...&gt;</span><br><span class="line">class vector&lt;<span class="keyword">bool</span>,Alloc&gt;</span><br><span class="line">&#123;</span><br><span class="line">    ...<span class="comment">//具体实现略</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>范围。模板支持任意类型，偏特化为 任意指针类型。（其余类型使用泛化模板，指针使用偏特化）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...<span class="comment">//具体实现略</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>&lt;</span>T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">    ...<span class="comment">//具体实现略</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="模板模板参数"><a href="#模板模板参数" class="headerlink" title="模板模板参数"></a>模板模板参数</h3><p>模板的一个参数也为模板。用来初始化时，容器实现底层所采用的数据类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Container</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="variadic-templates"><a href="#variadic-templates" class="headerlink" title="variadic templates"></a>variadic templates</h3><p>模板参数可变化。允许写任意个数的模板参数(用<code>...</code>来省略)(每次都分为<code>1 + n</code>进行运行)通过<code>sizeof...()</code>函数获取<code>n</code>值。</p><p>以下代码调用时，可以一直递归为<code>1 + n</code>直至运行<code>1 + 0</code>全部运行完，程序结束。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//最后的0个参数时调用的函数，用来退出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Types&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> T&amp; firstArg,<span class="keyword">const</span> Types&amp;...args)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; firstArg &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">print</span>(args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><p>自动推导相应的数据类型。比如容器的迭代器，写起来过长可以直接<code>auto</code>让编译器<mark>根据返回值类型</mark>自动推导相应的类型。再比如lambda表达式返回值比较复杂，可以auto推导。</p><h3 id="for-decl-coll"><a href="#for-decl-coll" class="headerlink" title="for(decl:coll)"></a>for(decl:coll)</h3><p>另一种遍历的形式。每次从右边的容器中取出值赋给左边的变量。默认为值传递，不会改变原来值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;::iterator iter = vec.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">auto</span> iter = vec.<span class="built_in">begin</span>();</span><br></pre></td></tr></table></figure><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用，给变量取一个别名，取出后可以去修改。<br>变量和其引用大小相同，地址相同。<br>指针可以重新指向其他元素，而引用一旦确定不能变。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;x;</span><br><span class="line"><span class="keyword">int</span> &amp;r = x;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">5</span>;</span><br><span class="line">p = y;    <span class="comment">//指针p指向了y 再赋值改变的是y值，不会影响x。</span></span><br><span class="line">r = y;    <span class="comment">//用y的值给r赋值 r = 5 x  = 5;</span></span><br></pre></td></tr></table></figure><p>指针传递、值传递、引用传递中，指针和引用可以改原始值，三者调用对象的方式有些差异。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(Cls *pobj)</span> </span>&#123; pobj-&gt;<span class="built_in">function</span>(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(Cls obj)</span> </span>&#123; obj.<span class="built_in">function</span>(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">(Cls &amp;obj)</span> </span>&#123; obj.<span class="built_in">function</span>(); &#125;</span><br></pre></td></tr></table></figure><p>同名同类型一个值传递、一个引用传递的函数不能重载。（二义性）但一个<code>const</code>一个非const可以并存。</p><h3 id="虚指针-amp-虚表"><a href="#虚指针-amp-虚表" class="headerlink" title="虚指针&amp;虚表"></a>虚指针&amp;虚表</h3><p>vptr &amp; vtbl。只要有虚函数，类内部就会有出现<mark>一个</mark>指针。虚指针用来指向虚表中的<mark>函数指针</mark>指向虚函数的地址。未重写的虚函数，基类和派生类共用。重写了的，各自虚表中指向重写后的地址。<br>下列代码中存在一些问题，可以不必纠结。（为了方便理解）。<br>通过指针，向上转型，指向虚函数。<code>(*p-&gt;vptr[n])(p)</code><br><img src="/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20220611144047216.png" alt="vptr+vtbl"></p><h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p>通过对象调用函数时，对象的地址传<code>this</code>指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">&#125;;</span><br><span class="line">B b;</span><br><span class="line">A::<span class="built_in">func</span>(&amp;b); </span><br><span class="line">b.<span class="built_in">func</span>(); <span class="comment">//等价 </span></span><br><span class="line"><span class="comment">//this指针为&amp;b</span></span><br></pre></td></tr></table></figure><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>非const对象可以调用所有的成员函数，const对象只能调用const成员函数。当成语函数const和非cosnt同时存在时，const对象只能调用const函数，非const对象只能调用非const函数。</p><h3 id="operator-new-delete"><a href="#operator-new-delete" class="headerlink" title="operator new/delete"></a>operator new/delete</h3><p>是运算符，可以重载。（全局，类内部 都可以）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span> size);</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* ptr)</span></span>;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> *<span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span>* ptr);</span><br></pre></td></tr></table></figure><h3 id="重载new-delete"><a href="#重载new-delete" class="headerlink" title="重载new/delete"></a>重载new/delete</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> _id;</span><br><span class="line">    <span class="keyword">long</span> _data;</span><br><span class="line">    string _str;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>() : _id(<span class="number">0</span>) &#123; cout &lt;&lt; <span class="string">&quot;default ctor.this&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;id=&quot;</span> &lt;&lt; _id &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="keyword">int</span> i):_id(i) &#123; cout &lt;&lt; <span class="string">&quot;ctor.this&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;id=&quot;</span> &lt;&lt; _id &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">Foo</span>() &#123; cout &lt;&lt; <span class="string">&quot;dtor.this&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;id=&quot;</span> &lt;&lt; _id &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span> size);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* Foo::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    Foo *p = (Foo *)<span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> Foo::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span>* Foo::<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span> size) &#123;</span><br><span class="line">    Foo *p = (Foo *)<span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Foo::<span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size) &#123;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 优先从类成员函数调用，如果没有就用全局。</span></span><br><span class="line">Foo *pf = <span class="keyword">new</span> Foo;</span><br><span class="line"><span class="keyword">delete</span> pf;</span><br><span class="line"><span class="comment">//默认使用全局函数</span></span><br><span class="line">Foo *pf = ::<span class="keyword">new</span> Foo;</span><br><span class="line">::<span class="keyword">delete</span> pf;</span><br></pre></td></tr></table></figure><h3 id="重载new-delete-1"><a href="#重载new-delete-1" class="headerlink" title="重载new(),delete()"></a>重载new(),delete()</h3><p>new()可以重载出多个版本，但第一参数必须为<code>size_t</code>。同时也可以重载对应的delete()，但其不会被调用。只有在new()抛出异常才会调用delete()</p><h3 id="new-amp-amp-delete"><a href="#new-amp-amp-delete" class="headerlink" title="new &amp;&amp; delete"></a>new &amp;&amp; delete</h3><p>二者对于基本数据类型的操作基本没有差异，而当为类的对象分配空间时，会有一些区别。<br>以下是候捷老师课程中关于malloc/new区别的代码以更好的区分二者。<br><img src="/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/malloc+new.png" alt="malloc+new"><br>假设我们现在已经有一个复数类，当我们用new进行分配时，首先自动获取对象所占空间，执行<code>operator new</code>，在其内部调用malloc分配相应的大小。然后调用<code>static_cast</code>显式的进行强制类型转换。最终再执行类的构造函数。<br>从图中，我们可以看出二者的一些区别：</p><ol><li>new无需强制类型转换和指定分配的大小，而malloc需要。</li><li>new为一个对象开辟空间时，会调用构造函数，而malloc不会。(故，malloc为对象申请空间时，一些在构造函数里的初始化操作无法执行。)</li></ol><h3 id="free-amp-amp-delete"><a href="#free-amp-amp-delete" class="headerlink" title="free &amp;&amp; delete"></a>free &amp;&amp; delete</h3><p>下面是关于free/delete的区别<br><img src="/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/free+delete.png" alt="free+delete"><br>可以看出，当我们对一个对象执行<code>delete</code>操作时，首先要调用析构函数再通过<code>operator delete</code>执行<code>free</code>操作。<br>由此，我们可以知道</p><ul><li>free使用不当会造成内存泄漏。</li></ul><p>如果该类是不带指针的类（比如复数类，成员变量只有实部和虚部），不调用类的析构函数也没有任何问题，也会正常的释放掉为对象所分配的内存空间。而如果这个类<mark>带有指针</mark>（比如 string），free时虽然会释放掉对象所占的空间，但由于<code>string</code>存储的只是个指针，我们对字符串进行修改时，对象内部会为指针分配相应的空间来存储内容。我们执行free时，内存中为其具体内容分配的空间没有得到释放。（指针消亡，但指向的内存空间并没有被释放）。</p><h3 id="delete-amp-amp-delete"><a href="#delete-amp-amp-delete" class="headerlink" title="delete &amp;&amp; delete[]"></a>delete &amp;&amp; delete[]</h3><p>当我们为一个数组new相应的空间时，使用<code>delete</code>释放也会造成内存泄漏。<br><img src="/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/delete.png" alt="delete"><br>从图中可以看出，使用delete释放为数组开辟的空间时，我们会释放掉所分配的空间，同样的也会调用析构函数。这对于不带指针的类来说可能没有太大的区别，当我们的类带指针时，由于只能够调用一次析构函数。数组<code>array</code>中，只有<code>array[0]</code>所指向的内存空间被释放掉了，其余的几个指针指向的空间并没有被释放。<br>由此可以知道，当我们为数组new一片内存时（<code>new xxx[]</code>)，也要使用相应的<code>delete[] xxx</code>。</p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h3><p>通过<strong>复合</strong>。某个类内部含有另一个类的对象，一些可复用的功能直接通过对象去调用。<br>实例：栈、队列从双端队列改写代码。已实现的功能直接调用，其余自己再写。</p><h3 id="Handle-Body"><a href="#Handle-Body" class="headerlink" title="Handle/Body"></a>Handle/Body</h3><p>通过<strong>委托</strong>。某个类内部含有另一个类 对象的指针。这个类可以用来提供对外借口，而底层具体实现在指针指向的对象内实现。（接口改变、底层改变可以只编译一部分）</p><h3 id="Template-Method"><a href="#Template-Method" class="headerlink" title="Template Method"></a>Template Method</h3><p>通过<strong>继承</strong>。有些东西在每个软件中所展示出的操作没有太大区别，我们可以将其相似的功能进行编写，细微差异部分以虚函数的形式留给所继承到具体的类中去实现。<br>实例：打开文件操作。各个软件打开文件的次序基本一致：选择文件，检查文件是否存在，在磁盘中进行读取，xxx，关闭文件。我们可以将其余功能都封装好，对外提供一个具体读取方式的接口。</p><h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><p>通过<strong>继承+委托</strong>。文件类内部包括多个查看操作的委托，具体到某个文件时，支持多个人同时查看。（文件内部可以增加注册、注销等功能以便于管理。）</p><h3 id="Composite"><a href="#Composite" class="headerlink" title="Composite"></a>Composite</h3><p>通过<strong>继承+委托</strong>。当某个类内部可以包含多种不同内容时（自身+其余的类），我们可以将自身及 要包含的类继承自同一个父类。然后该类的内部包含基类的委托。<br>e.g. 类A内部要可以包含A的指针也可以包含B的指针。我们可以将A B都继承自父类C（功能多少不重要，重要的是A中可以包含B的委托），A中包含父类的委托。</p><h3 id="Prototype"><a href="#Prototype" class="headerlink" title="Prototype"></a>Prototype</h3><p>通过<strong>继承+委托</strong>。父类可以创建未来将要出现的子类。（父类是发行商自己写的，子类是客户买回去自己写的相应的类）。<br>派生类构造函数设置为私有，构造函数内部实现将自身的指针返回给基类，保存在基类的容器中。派生类中含有一个clone()函数，以让基类调用，生成一个副本提供给父类。还需要另外一个的构造函数（以便clone函数构造自己时调用，防止再次调用上次的私有构造 陷入死循环）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 候捷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022/04月度总结</title>
      <link href="/2022-04%E6%9C%88%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
      <url>/2022-04%E6%9C%88%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>不知不觉，马上就来到了五月。大学的课程也只剩下一两门。在大学时光结束之前，记录一下生活。可以将这东西理解为日记(流水账)，但俺懒到一个月才写一次。</p><span id="more"></span><p>这一个月是疯狂投简历的一个月。一共投了将近20份简历吧，只面试了一次。本来觉得我算法还可以，背了几天面经。然后笔试了几次发现，算法垃圾的一批，又再天天刷题。再加上这学期很多门课都是有实验的，有些实验异常浪费时间，实际的学习的时间很少、效率很低。而且还少交了一些作业，直接摆烂了一些作业（指，写一半不想写了直接交）<br><img src="/2022-04%E6%9C%88%E5%BA%A6%E6%80%BB%E7%BB%93/leetcode.png" alt="力扣刷题"><br>最大的感受是，很多题基本上在看到题的一瞬间就注定结果了。会就是会，不会憋半天也没任何想法（卡样例的想法除外）。<br>一个月来相关的笔试如下（感谢华为的面试让我觉得自己又行了）：<br><img src="/2022-04%E6%9C%88%E5%BA%A6%E6%80%BB%E7%BB%93/%E6%97%A5%E5%8E%86.jpg" alt="笔试安排"><br>实在学不下去了的时候，看了几本书:《动物凶猛》、《过把瘾就死》、《限时医院》、《潮骚》。影视剧已经被搁置了一段时间。（太令我沉迷）。</p><p>这个月，最<mark>烦心</mark>的是阿里的笔试。周五晚上的笔试，三个编程题，后两个只有一个样例没过，可以说是我发挥最好的一场笔试，结果周一上午直接给我挂了。当然了，最<mark>意外的收获</mark>也就是华为的面试。虽然笔试600分我只有90,但还是给了我面试资格。面试体验感也极好。<br>送给大家最近听到的比较喜欢的一句话（华为面试时，反问面试官职业规划的建议时他说的）</p><blockquote><p>人生中存在着很多的变数。怎么说呢，把握机遇吧。</p></blockquote><p>虽然这句话听起来很俗。但在听完他的故事以及看到他沧桑的面孔后，能说出这句话，又透露着多少的遗憾。<br><del>最后分享一组最近拍摄的照片的原图。</del><strong>删了，没有了。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 关于我 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B树</title>
      <link href="/B%E6%A0%91/"/>
      <url>/B%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>AVL 树和红黑树都假设所有的数据放在主存当中。而当数据量达到亿级，主存中根本存储不下，我们只能以块的形式从磁盘读取数据，与主存的访问时间相比，磁盘的 I/O 操作相当耗时，而提出 B-树的主要目的就是减少磁盘的 I/O 操作。</p><span id="more"></span><p> B树的一个节点$x$如果包含$n$个$key$，则其有$n+1$个孩子。（$n$个key将其余数据划分为$n+1$个区间，每个孩子介于相应的区间中）</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>B树所具有的的性质人如下:</p><ol><li>每个节点$x$应具有如下属性：<ol><li>$x.n$即，存储在$x$节点的$key$个数</li><li>节点$x$的n个key以<strong style="color:red;">非降序</strong>排列。$x.key_1 \le x.key_2 \le \cdots \le x.key_{x.n}$</li><li>$ x.leaf$，布尔值。用来表示x是(true)否(false)为叶子节点</li></ol></li><li>每个<strong style="color:red;">非叶子节点</strong>还包括$x.n + 1$个指向其孩子的指针:$x.c_1,x.c_2,x.c_3\cdots,x.c_{x.n +1}$。<mark>叶子节点没有该定义</mark>。</li><li>$x.key_i$对其子节点进行分割。假设$k_i$为其子节点的$key$值。则有 </li></ol><p>$$<br>k_1 \le x.key_1 \le k_2 \le x.key_2 \le \cdots \le x.key_{x.n} \le k_{x.n +1}<br>$$<br>4. 所有的<strong style="color:red;">叶子节点深度相同</strong><br>5. B树的<strong>最小度数</strong>$t \ge 2$以限制每个节点所包含$key$值的个数(上下限)。<br>    1. 除根节点外，每个节点必须<strong>至少</strong>有$t-1$个$key$。（除叶子节点外，每个节点至少有$t$个孩子）<br>    2. 每个节点至多有$2t-1$个key。（除叶子节点外，每个节点至多有$2t$个孩子）当B树恰好拥有$2t-1$个$key$时，称该节点为满的。（结合性质5.1即B树要求半满）</p><p>一个B树的样例如下：<br><img src="/B%E6%A0%91/BTreeExp.png" alt="B树样例"><br>一个较为简单的B树定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BTreeNode</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">int</span> *keys; <span class="comment">// 存储key值</span></span><br><span class="line">    <span class="keyword">int</span> t;  <span class="comment">// 最小度 </span></span><br><span class="line">    BTreeNode **C; <span class="comment">// 子节点</span></span><br><span class="line">    <span class="keyword">int</span> n;  <span class="comment">// key的个数</span></span><br><span class="line">    <span class="keyword">bool</span> leaf; <span class="comment">// 是否为叶子节点</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p><strong>B树的高度</strong><br>B树大部分操作的磁盘存取次数与B树的高度成正比。对于任意一个包含$n$个$key$,高度为$h$,最小度为$t$的B树，有</p><p>$$<br>    h \le \log_{t}{\frac{n+1}{2} }<br>$$</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>在此假定：B树始终在主存中，无需读取磁盘。</p><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>B树的搜索，不过是在二叉搜索树的基础上，每个节点有多个$key$值。<br>以上述的样例图中查找33为例。</p><ol><li>首先，访问根节点。先和第一个$key$值20比较，发现 $37&gt;20$。然后与第二个$key$值40比较，此时$37&lt;40$。于是递归到20与40之间的子节点去查找。<br><img src="/B%E6%A0%91/BTreeSearch1.png" alt="B树搜索样例1_1"></li><li>接着，访问$\left[24,35\right]$节点。先和第一个$key$ 24比较，发现$37&gt;24$。然后与第二个$key$ 35比较,发现$37 &gt; 35$。访问该节点的最后一个子节点。<br><img src="/B%E6%A0%91/BTreeSearch2.png" alt="B树搜索样例1_2"></li><li>最后在叶子节点$\left[ 37,39\right]$中，查找到37,结束。<br><img src="/B%E6%A0%91/BTreeSearch3.png" alt="B树查找样例1_3"><br>相关过程代码如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BTreeNode *<span class="title">BTreeNode::search</span><span class="params">(<span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> <span class="comment">// 找到第一个大于待查找k 的key值</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span> (i &lt; n &amp;&amp; k &gt; keys[i]) &#123;</span><br><span class="line">    i++; </span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">// 相等即找到 </span></span><br><span class="line"> <span class="keyword">if</span> (keys[i] == k) </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>; </span><br><span class="line"></span><br><span class="line"> <span class="comment">// 如果没有找到，且当前结点为叶子结点则无解</span></span><br><span class="line"> <span class="keyword">if</span> (leaf == <span class="literal">true</span>) </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>; </span><br><span class="line"></span><br><span class="line"> <span class="comment">// 递归访问恰当的子代</span></span><br><span class="line"> <span class="keyword">return</span> C[i]-&gt;<span class="built_in">search</span>(k); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>插入、删除。过于复杂，先略了，有空再写。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构&amp;算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<p>虽然，Carl的<a href="https://programmercarl.com/">《代码随想录》</a>和labuladong的<a href="https://labuladong.gitee.io/algo/">《算法小抄》</a>对“动态规划”类问题有着详尽且优质的解答，但仍然想在这里简单啰嗦一下<strong>动态规划</strong>。在这里，并不想以《算法导论》中较为晦涩且难懂的<code>「矩阵连乘」</code>、<code>「最优二叉搜索树」</code>等为样例进行讲解。</p><span id="more"></span><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>动态规划，英文名：Dynamic Programming，简称DP。其算法的基本思想是：将待求解的问题<strong>分解成若干个子问题</strong>，先求解子问题，再<strong>由子问题的解得到原问题的解</strong>。换句话说，将一个复杂的问题，分解为多个相互联系的较为简单的子问题，对每个子问题进行求解，复杂问题的答案蕴含在子问题中（<strong>具备「最优子结构」</strong>）。</p><p>通常，可以用动态规划求解的问题也可以用<strong style="color:red;">穷举</strong>来解决问题。但在穷举的过程中会<strong>存在「重叠子问题」</strong>。即，在暴力穷举求解时，一些中间值会进行多次的重复计算，严重影响效率。以斐波那契数列为例:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fib</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">2</span>) ? n: <span class="built_in">Fib</span>(n - <span class="number">1</span>) + <span class="built_in">Fib</span>(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归树如下:</p><p><img src="/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/DPFib.png" alt="斐波那契数列"></p><center>随着递归的进行，$Fib(n)\quad n \in \left[ 2,18\right]$均计算了多次</center><p>我们知道，这些进行<strong style="color:red;">重复计算的值</strong>如果<strong style="color:red;">只计算一次</strong>的话，求解问题的<strong style="color:red;">效率</strong>会有一定的<strong style="color:red;">提高</strong>。</p><p>为解决该问题，引入了「备忘录方法」。即，其在<strong style="color:red;">自顶向下</strong>递归过程中<strong style="color:#e67c86;">用一个表来保存已解决问题的答案</strong>，在求解时先查表，表中有的直接用，没有的再递归。上述斐波那契数列在每次递归求解$Fib(n-1)+Fib(n-2)$时，$Fib(n-2)$的值在求解$Fib(n-1)$时已经求过，直接从表中引用。</p><p>我们发现，在利用「备忘录方法」进行求解时，我们是每求解一个问题记录一次，当<strong>并非所有子问题都需要求解时</strong>，「备忘录方法」可以严格的只求解需要的问题，而当所有子问题都需要求解一次或多次时，考虑使用动态规划。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N &lt;= <span class="number">1</span>) <span class="keyword">return</span> N;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(N + <span class="number">1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基本要素"><a href="#基本要素" class="headerlink" title="基本要素"></a>基本要素</h1><p>动态规划三个基本要素分别为：最优子结构、重叠子问题、状态转移方程。</p><ol><li>最优子结构：当<strong>问题的最优解包含了其子问题的最优解</strong>时，称该问题具有最优子结构性质。分析最优子结构性质时，一般假设由问题的最优解导出的子问题不是最优的，然后再设法说明在这个假设下可以构造出一个比原问题更优解更好的解，从而导出矛盾。</li><li>重叠子问题：在用递归算法自顶向下解此问题时，每次产生的子问题并不总是新问题，<strong>有些子问题被反复计算多次</strong>。动态规划算法对每个问题只解一次，而后将其解保存在一个表格中，当再次需要解此问题时，用常数时间查看一下结果。因此，用动态规划算法通常只需要多项式时间。</li><li>状态转移方程：动态规划中，一个状态向另一个状态转变时的规则。实际的算法问题中，列出状态转移方程往往较为困难。在列相应的状态转移方程时，我们需要注意：确定状态数组<code>dp</code>中角标的含义、初始化时已确定的状态及递归公式。</li></ol><h1 id="求解步骤"><a href="#求解步骤" class="headerlink" title="求解步骤"></a>求解步骤</h1><ol><li>找出最优解的性质，并刻划最优解的结构特征。</li><li> 递归地定义最优值。</li><li> 以自底向上的方式计算出最优值。</li><li> 根据计算最优值时得到的信息，构造最优解。</li></ol><h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><p>首先，<strong style="color:red;">动态规划和分治法</strong>都是分解成子问题，由子问题的解得到原问题的解。但需要将二者进行区分：动态规划中除了有诸多的重叠子问题外，各子问题之间还存在着一定的关联(通过状态转移方程递推其他状态)。而分治法中，各子问题相对独立。</p><p>再者，<strong style="color:red;">贪心算法和动态规划</strong>也同样的都需要分解子问题来求解。二者所不同的是：<strong style="color:#9b2ebd;">动态规划</strong>在求解问题时需要<strong style="color:#9b2ebd;">遍历所有的可能</strong>情况。而<strong style="color:rgb(0, 191, 166);">贪心算法</strong>在每个子问题求解时<strong style="color:rgb(0, 191, 166);">只考虑局部最优解</strong>的情况。语言介绍较为苍白无力，接下来用<strong style="color:#e67c86;">「拼凑面额问题」</strong>来对比二者的区别。在此，我们将会引入一些面额的纸币以方便举例。</p><h2 id="能否凑出面额"><a href="#能否凑出面额" class="headerlink" title="能否凑出面额"></a>能否凑出面额</h2><p>假设，我们去商店买东西。已知，口袋里有如下几种面额的纸币各<strong>一张</strong>：<code>1</code>,<code>2</code>,<code>5</code>,<code>10</code>,<code>13</code>，我们需要支付的金额为<code>17</code>。而由于种种原因，商店并没有零钱。即，我们需要用上述五个数字中的部分进行加和，让值恰好为17。</p><ul><li><strong style="color:#c04851;">贪心算法</strong><ol><li>首先拿出面值为<code>13</code>的纸币。由于<code>13&lt;17</code>，面值<code>13</code>的纸币<strong>一定要使用</strong>。接下来，我们需要用<code>1</code>,<code>2</code>,<code>5</code>,<code>10</code>四张纸币支付<code>4</code>。</li><li>面值为<code>10</code>的纸币超过了要支付的金额，不予使用。</li><li>面值为<code>5</code>的纸币超过了要支付的金额，不予使用。</li><li>由于<code>2 &lt; 4</code>，面值为<code>2</code>的纸币也一定使用。</li><li>最后，剩下一张面值为<code>1</code>的纸币，不足以支付剩余的金额<code>2</code>。则贪心算法的结果是不能支付。</li></ol></li><li><strong>动态规划</strong><ol><li>我们假设在此按照自顶向下(最大面值开始)求解该问题时，同样的也会经历上述步骤。但，上述步骤执行完时并不直接返回<code>false</code>，而是继续考虑。</li><li>这一次，我们将考虑不需要面值为<code>13</code>的纸币。而是使用面值为<code>10</code>的纸币。这一次，我们需要利用剩下的面值为<code>1</code>,<code>2</code>,<code>5</code>面值的纸币凑出<code>7</code>。</li><li>由于<code>5 &lt; 7</code>，使用面值为<code>5</code>的纸币，我们需要利用剩下的面值为<code>1</code>和<code>2</code>的纸币凑够金额2。显然这是可以的。因此利用动态规划得到的结果是可以支付。</li></ol></li></ul><h2 id="最少纸币数量"><a href="#最少纸币数量" class="headerlink" title="最少纸币数量"></a>最少纸币数量</h2><p>这一次，我们有面值为<code>2</code>,<code>8</code>,<code>10</code>的纸币，假设每种纸币的数量<strong>足够多</strong>。我们需要做的是拼凑出金额<code>16</code>。我们所做的是怎么用较少的纸币数量拼凑出相应的金额。</p><ul><li><strong>贪心算法</strong><ol><li>首先，我们拿出面值为<code>10</code>的纸币，一张即可（<code>10 &lt; 16 &lt; 2 * 10</code>）。接下来，需要利用面值为<code>2</code>和<code>8</code>的纸币凑够金额<code>6</code></li><li>面值为<code>8</code>的纸币超过了要支付的金额，不予使用。</li><li><code>3 * 2 = 6</code>。故需要4张纸币。</li></ol></li><li><strong>动态规划</strong><ul><li>在上述基础上，动态规划还会去考虑不使用面值为<code>10</code>时候的其他情况，分别<code>2 * 8</code>，<code>8 + 4 * 2</code>，<code>8 * 2</code>三种方案，最终确定为使用2张面值<code>8</code>的纸币所用纸币数量最少。</li></ul></li></ul><p>最后，需要声明的是，以上样例中动态规划的解法是为方便理解，效率上有着改进的空间。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构&amp;算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红黑树</title>
      <link href="/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
      <url>/%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>由于二叉搜索树很不平衡，很容易退化为一条类似链表的结构，从而造成时间复杂度从$O(lgN)$降低为$O(N)$。</p><p>为解决这一问题，引入了<strong>“平衡”二叉搜索树</strong>，红黑树就是其中的一种。红黑树在树的基础上，为每个节点增加了一个<strong>颜色位</strong>，可以是<code>RED</code>，也可以是<code>BLACK</code>。通过对每条路径的颜色进行约束，保证红黑树处于<strong style="color:#e67c86;">近似平衡</strong>的状态，从而保证了查找最坏情况为$O(lgN)$。</p><span id="more"></span><h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p>红黑树除了本身是<strong style="color:rgb(0, 191, 166);">二叉搜索树</strong>外，还满足以下条件：</p><ol><li>每个节点<strong style="color:red;">要么是红色</strong>的，<strong style="color:red;">要么是黑色</strong>的。</li><li><strong style="color:red;">根节点</strong>是<strong style="color:red;">黑色</strong>的。</li><li>每个空节点(<strong style="color:red;">NIL</strong>)都是<strong style="color:red;">黑色</strong>的。</li><li><strong style="color:red;">红色节点</strong>的两个<strong style="color:red;">子节点</strong>都是<strong style="color:red;">黑色</strong>的。</li><li><strong style="color:red;">每个节点</strong><strong>到</strong>其后代<strong style="color:red;">叶子节点</strong>的路径上包含的<strong style="color:red;">黑色节点数目相同</strong>。</li></ol><p>红黑树的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">RBTColor</span>&#123;</span>RED, BLACK&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RBTNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    T key;</span><br><span class="line">        RBTColor color;</span><br><span class="line">        RBTNode *left;</span><br><span class="line">        RBTNode *right;</span><br><span class="line">        RBTNode *parent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>样例如图：</p><p><img src="/%E7%BA%A2%E9%BB%91%E6%A0%91/RedBlackTree.png" alt="红黑树样例"></p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>由于结点的插入、删除操作对树进行了修改。修改后的红黑树可能<strong style="color:red;">不再满足</strong>上面所列出的<strong style="color:red;">红黑性质</strong>，故需要对树的某些结点进行<strong style="color:pink;">旋转</strong>或<strong style="color:pink;">变色</strong>使其自平衡。</p><p>忽略红黑特性，以一个二叉搜索树为例进行演示旋转。样例如下：</p><p><img src="/%E7%BA%A2%E9%BB%91%E6%A0%91/RBTreeRotate.png" alt="红黑树旋转"></p><p>图中<code>x y</code>是两个节点，<code>a b c</code>表示任意子树。</p><p>不难看出，图中的旋转仍然保持了二叉搜索树的性质：a子树所有节点的key值小于<code>x.key</code>;c子树所有节点的key值大于<code>y.key</code>;b子树key值介于<code>x.key</code>与<code>y.key</code>之间。伪代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左旋</span></span><br><span class="line">LEFT-<span class="built_in">ROTATE</span>(T, x)</span><br><span class="line">y = x.right</span><br><span class="line">x.right = y.left<span class="comment">//上图中，b子树的移动</span></span><br><span class="line"><span class="keyword">if</span> y.left != <span class="literal">nullptr</span></span><br><span class="line">    y.left.parent = x<span class="comment">//过继过去的b子树父节点改变</span></span><br><span class="line">y.parent = x.parent</span><br><span class="line">    <span class="comment">//改变x的父节点的指向</span></span><br><span class="line"><span class="keyword">if</span> x.parent == <span class="literal">nullptr</span></span><br><span class="line">    T.root = y<span class="comment">//x父节点为空，证明x为根节点 即左旋后的y节点变为根节点</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> x == x.parent.left</span><br><span class="line">    x.parent.left = x</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    x.parent.right = y</span><br><span class="line">y.left = x<span class="comment">//将x链接在y的左侧</span></span><br><span class="line">x.parent = y</span><br><span class="line"></span><br><span class="line"><span class="comment">//右旋</span></span><br><span class="line">RIGHT-<span class="built_in">ROTATE</span>(T, y)</span><br><span class="line">x = y.left</span><br><span class="line">y.left = x.right</span><br><span class="line"><span class="keyword">if</span> x.right != <span class="literal">nullptr</span></span><br><span class="line">    x.right.parent = y</span><br><span class="line">x.parent = y.parent</span><br><span class="line"><span class="keyword">if</span> y.parent == <span class="literal">nullptr</span></span><br><span class="line">    T.root = x</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> y == y.parent.left</span><br><span class="line">    y.parent.left = x</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    y.parent.right = x</span><br><span class="line">x.right = y</span><br><span class="line">y.parent = x</span><br></pre></td></tr></table></figure><p>旋转操作只改变所旋转元素附近的指针，其他属性均未改变。可以在常数时间$O(1)$内完成。</p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>由于红黑树对黑色节点的要求较为苛刻，新插入的节点<strong>默认为红色</strong>。</p><p>将某个节点插入到红黑树，详细过程如下：</p><ol><li>首先，红黑树本身是一个<strong>二叉搜索树</strong>，依据其性质可以找到相应的插入位置，保证节点<strong>插入后</strong>key仍<strong>有序</strong>。</li><li>插入后，进行一系列的<strong style="color:red;">旋转</strong>、<strong style="color:red;">着色</strong>使其继续<strong style="color:red;">保持红黑特性</strong>。</li></ol><p>正常情况下(排除红黑树从0开始构建的情况)，当我们插入一个节点后如果违反了红黑树的红黑特性，那么所违反的应该为特性4(红节点的两个子节点均为黑色)。我们需要<strong>从当前节点向根节点</strong>逐层向上判断是否调整并作出相应的<strong>调整</strong>。相关调整方案如下：</p><p><img src="/%E7%BA%A2%E9%BB%91%E6%A0%91/RBTreeInsert.png" alt="RBTreeInsert"></p><p>最后，<strong style="color:red;">根节点</strong>恒<strong style="color:red;">染为黑色</strong>。</p><p>下面给出一个范例，显示一个红黑树上的调整操作。</p><p><img src="/%E7%BA%A2%E9%BB%91%E6%A0%91/RBTreeInsertExp.png" alt="RBTreeInsertExp"></p><p>在上图中，初始状态<code>x</code>为插入的节点，其父节点(<code>key = 5</code>)违背红黑规则4，需要进行调整：</p><ol><li>由于<code>x</code>的父节点和叔节点都是红色（调整方案1.2），调整时需要将其父节点(<code>key = 5</code>)和叔节点(<code>key = 8</code>)染成黑色，将其祖父节点(<code>key = 7</code>)染成红色，然后考虑其祖父节点。<code>x节点</code>上移为其祖父节点(<code>key = 7</code>)，此时<code>x节点</code>的父节点(<code>key = 2</code>)违背红黑规则4</li><li>叔节点不为红色，调整策略对应为1.1。观察到<strong style="color:pink;">父节点是祖父节点的左子树，自己是父节点的右节点</strong>(1.1.1.1)。当前节点上移为其父节点(<code>key = 2</code>)然后左旋。左旋后的<code>x节点</code>执行调整方案1.1.1.2</li><li>父节点(<code>key = 7</code>)染成黑色，祖父节点(<code>key = 11</code>)染成红色，将祖父节点右旋。<code>x节点</code>的父节点(<code>key = 11</code>)不再是红色，退出循环。此时当前红黑树不再违背红黑规则。</li><li>循环退出后，将其<strong style="color:red;">根节点染成黑色</strong>。</li></ol><p>调整方案对应的伪代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> x.parent.color == RED<span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> x.parent == x.parent.parent.left</span><br><span class="line">        y = x.parent.parent.right<span class="comment">//叔节点</span></span><br><span class="line">        <span class="keyword">if</span> y.color == RED<span class="comment">//1.2</span></span><br><span class="line">            x.parent.color = BLACK</span><br><span class="line">            y.color = BLACK</span><br><span class="line">            x.parent.parent.color = RED</span><br><span class="line">            x = x.parent.parent</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span> x == x.parent.right<span class="comment">//1.1.1.1</span></span><br><span class="line">                <span class="comment">//父节点左旋并置为当前</span></span><br><span class="line">                x = x.parent</span><br><span class="line">                LEFT-<span class="built_in">ROTATE</span>(T, x)</span><br><span class="line">            <span class="comment">//1.1.1.2</span></span><br><span class="line">            x.parent.color = BLACK</span><br><span class="line">            x.parent.parent.color = RED</span><br><span class="line">            RIGHT-<span class="built_in">ROTATE</span>(T, x.parent.parent)</span><br><span class="line">    <span class="comment">//父节点为右</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        y = x.parent.parent.left</span><br><span class="line">        <span class="keyword">if</span> y.color == RED</span><br><span class="line">            x.parent.color = BLACK</span><br><span class="line">            y.color = BLACK</span><br><span class="line">            x.parent.parent.color = RED</span><br><span class="line">            x = x.parent.parent</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span> x == x.parent.left <span class="comment">//1.1.2.2</span></span><br><span class="line">                x = x.parent</span><br><span class="line">                RIGHT-<span class="built_in">ROTATE</span>(T, x)</span><br><span class="line">            <span class="comment">//1.1.2.1</span></span><br><span class="line">            x.parent.color = BLACK</span><br><span class="line">            x.parent.parent.color = RED</span><br><span class="line">            LEFT-<span class="built_in">ROTATE</span>(T, x.parent.parent)</span><br><span class="line">T.root.color = BLACK</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除和插入操作类似，也分为两个步骤：</p><ol><li>红黑树本身是一个<strong>二叉搜索树</strong>，根据其性质<strong style="color:red;">寻找到对应节点并删除</strong>掉。删除的情况如下<ul><li>若该节点是<strong style="color:red;">叶子节点</strong>，则<strong>直接删除</strong>。</li><li>若<strong style="color:red;">只有一个子树</strong>，则用子树<strong>替代当前节点</strong>。</li><li>若<strong style="color:red;">有两个子树</strong>，则用<strong>右子树的最小值</strong>(大于被删除元素的最小值)替代当前节点。</li></ul></li><li>通过旋转、着色等操作将红黑树修正，使之成为新的红黑树。</li></ol><p>根据所替代节点的相关信息来进行调整：</p><p><img src="/%E7%BA%A2%E9%BB%91%E6%A0%91/RBTreeDelete.png" alt="RBTreeDelete"></p><p>同样的，在循环结束之后，将<strong style="color:red;">当前节点染成黑色</strong>。</p><p>下面给出几个具体样例进行分析：</p><ul><li><p>例一</p><p><img src="/%E7%BA%A2%E9%BB%91%E6%A0%91/RBTreeDeleteExp1.png" alt="RBTreeDeleteExp1"></p><p>在该样例中，A<strong>节点为黑色</strong>，且是其<strong>父节点的左节点</strong>，<strong>兄弟节点D为红色</strong>，满足调整方案1.1.1。所做出的调整为将其父节点<code>B</code>染成红色，兄弟节点<code>D</code>染成黑色。然后将其父节点<code>B</code>进行左旋。此后均满足条件。</p></li><li><p>例二</p><p><img src="/%E7%BA%A2%E9%BB%91%E6%A0%91/RBTreeDeleteExp2.png" alt="RBTreeDeleteExp2"></p><p>在该样例中，A<strong>节点为黑色</strong>，且是其<strong>父节点的左节点</strong>，<strong>兄弟节点D为黑色</strong>，两个<strong>侄子节点</strong><code>C</code>和<code>E</code><strong>均为黑色</strong>，满足调整方案1.1.2.1。调整时，将其兄弟结点<code>D</code>染成红色，<code>x</code>已上移为根节点<code>B</code>，循环结束。需要特别注意的是，此刻应再将节点<code>B</code>染成黑色。</p></li><li><p>例三</p><p><img src="/%E7%BA%A2%E9%BB%91%E6%A0%91/RBTreeDeleteExp3.png" alt="RBTreeDeleteExp3"></p><p>在该样例中，A<strong>节点为黑色</strong>，且是其<strong>父节点的左节点</strong>，<strong>兄弟节点D为黑色</strong>，左侄子<code>C</code>为红色,右侄子<code>E</code>为黑色，满足调整方案1.1.2.2。调整时，将其左侄子<code>C</code>染成黑色，兄弟节点<code>D</code>染成红色，并将兄弟节点D右旋，然后再按照调整方案1.1.2.3进行调整，在此略过。</p></li><li><p>例四</p><p><img src="/%E7%BA%A2%E9%BB%91%E6%A0%91/RBTreeDeleteExp4.png" alt="RBTreeDeleteExp4"></p><p>在该样例中，A<strong>节点为黑色</strong>，且是其<strong>父节点的左节点</strong>，<strong>兄弟节点D为黑色</strong>，右侄子<code>E</code>为红色，满足调整方案1.1.2.3。调整时，兄弟节点<code>D</code>颜色随父节点<code>B</code>，右侄子<code>E</code>和父节点<code>B</code>染成黑色，将父节点<code>B</code>左旋。</p></li></ul><p>调整方案对应伪代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> x != T.root <span class="keyword">and</span> x.color == BLACK</span><br><span class="line">    <span class="keyword">if</span> x == x.parent.left</span><br><span class="line">w = x.parent.right<span class="comment">//兄弟节点</span></span><br><span class="line">        <span class="keyword">if</span> w.color == RED<span class="comment">// 1.1.1</span></span><br><span class="line">            w.color = BLACK</span><br><span class="line">            x.parent.color = RED</span><br><span class="line">            LEFT-<span class="built_in">ROTATE</span>(T, x.parent)</span><br><span class="line">            w = x.parent.right</span><br><span class="line">        <span class="keyword">if</span> w.left.color == BLACK <span class="keyword">and</span> w.right.color == BLACK<span class="comment">//1.1.2.1</span></span><br><span class="line">            w.color = RED</span><br><span class="line">            x = x.parent</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span> w.right.color == BLACK<span class="comment">//1.1.2.2</span></span><br><span class="line">            w.left.color = BLACK</span><br><span class="line">                w.color = RED</span><br><span class="line">                RIGHT-<span class="built_in">ROTATE</span>(T, w)</span><br><span class="line">               w = x.parent.right</span><br><span class="line">            w.color = x.parent.color<span class="comment">//1.1.2.3</span></span><br><span class="line">            x.parent.color = BLACK</span><br><span class="line">            w.right.color = BLACK</span><br><span class="line">            LEFT-<span class="built_in">ROTATE</span>(T, x.parent)</span><br><span class="line">            x = T.root</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        w = x.parent.left</span><br><span class="line">        <span class="keyword">if</span> w.color == RED<span class="comment">//1.2.2</span></span><br><span class="line">            w.color = BLACK</span><br><span class="line">            x.parent.color = RED</span><br><span class="line">            RIGHT-<span class="built_in">ROTATE</span>(T, x.parent)</span><br><span class="line">            w = x.parent.left</span><br><span class="line">        <span class="keyword">if</span> w.right.color == BLACK <span class="keyword">and</span> w.left.color == BLACK<span class="comment">//1.2.1.1</span></span><br><span class="line">            w.color =RED</span><br><span class="line">            x = x.parent</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span> w.left.color == BLACK<span class="comment">//1.2.1.2</span></span><br><span class="line">                w.right.color = BLACK</span><br><span class="line">                w.color = RED</span><br><span class="line">                LEFT-<span class="built_in">ROTATE</span>(T, w)</span><br><span class="line">            w.color = x.parent.color<span class="comment">//1.2.1.3</span></span><br><span class="line">            x.parent.color = BLACK</span><br><span class="line">            w.left.color = BLACK</span><br><span class="line">   RIGHT-<span class="built_in">ROTATE</span>(T, x.parent)</span><br><span class="line">            x = T.root</span><br><span class="line">x.color = BLACK</span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>红黑树插入、删除节点的情况虽然复杂，但基本处于<strong>对称</strong>情况，且有一个模型通过拼凑其他模型来实现。本文中的伪代码、样例均选自《算法导论》，红黑树的图采用<a href="https://draw.io/">drawio</a>绘制。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构&amp;算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>左孩子右兄弟树</title>
      <link href="/%E5%B7%A6%E5%AD%A9%E5%AD%90%E5%8F%B3%E5%85%84%E5%BC%9F%E6%A0%91/"/>
      <url>/%E5%B7%A6%E5%AD%A9%E5%AD%90%E5%8F%B3%E5%85%84%E5%BC%9F%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>在二叉树的基础上，我们可以扩展出任意多个叉的树。即，多叉树。然而，此时又面临着另外一个问题：</p><ul><li>当孩子结点无限制时，我们并不知道<strong>预先要分配多少个属性</strong>，且当<strong>仅有少数元素拥有多个子节点</strong>时，将会造成大量的空间浪费。</li></ul><p>此时，提出了一种新的表示形式:</p><p>$left-child \quad right-sibling \quad representation$。</p><span id="more"></span><h1 id="左孩子右兄弟表示法"><a href="#左孩子右兄弟表示法" class="headerlink" title="左孩子右兄弟表示法"></a>左孩子右兄弟表示法</h1><p>对于任意一个结点T，其仅包含两个指针：</p><ol><li><code>T.left-child</code>，指向T结点的最左侧子节点。</li><li><code>T.right-sibling</code>，指向T右侧最邻近的兄弟结点。</li></ol><p>特别的，当二者不存在时，相应的指针皆为空，即<code>NIL</code>。该方法只需要$O(n)$空间来存储含$n$个结点的树。</p><p>由于其与二叉树的相似性，故又叫<code>树的二叉树表示法</code>。</p><p>在此，给出一个样例：</p><p><img src="/%E5%B7%A6%E5%AD%A9%E5%AD%90%E5%8F%B3%E5%85%84%E5%BC%9F%E6%A0%91/LchildRsiblingTree.png" alt="LchildRsiblingTree"></p><p>该样例旨在为下述算法提供一个参考。</p><h1 id="相关算法"><a href="#相关算法" class="headerlink" title="相关算法"></a>相关算法</h1><h2 id="深度"><a href="#深度" class="headerlink" title="深度"></a>深度</h2><p>对于该种树而言，任意一个节点和其右节点的深度相同。也就意味着对于一个节点T，其高度为要么<strong>和右子树高度相同</strong>，要么<strong>比左子树低一层</strong>。从叶子节点向上递归，即可得出最大深度。即：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Height</span><span class="params">(Tree&amp; t)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(t == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Height</span>(t-&gt;left) + <span class="number">1</span> &gt; <span class="built_in">Height</span>(t-&gt;right) ? <span class="built_in">Height</span>(t-&gt;left) + <span class="number">1</span> : <span class="built_in">Height</span>(t-&gt;right);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="叶子节点数"><a href="#叶子节点数" class="headerlink" title="叶子节点数"></a>叶子节点数</h2><p>基于二叉树中的定义，<strong>叶子节点</strong>是没有子节点的节点。在该种表示方法中，即<strong>左指针为空</strong>的节点（某一层的最后一个叶子节点右子树也为空，故只看左指针就行）。对于一个节点的叶子节点数，即：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Count</span><span class="params">(Tree&amp; t)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(t == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(t-&gt;left == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Count</span>(t-&gt;left) + <span class="built_in">Count</span>(t-&gt;right); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><p>先序遍历，对于某个节点而言，其<strong>左指针</strong>为<strong>第一个子节点</strong>。向左指针递归即寻找孩子，回溯时输出右指针的兄弟。与二叉树的先序遍历完全一致。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Tree&amp; t)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(t == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">cout&lt;&lt;t-&gt;val&lt;&lt;<span class="string">&quot; &quot;</span>;<span class="comment">//输出值</span></span><br><span class="line">TreeNode* p = t-&gt;left;</span><br><span class="line"><span class="keyword">while</span>(p != <span class="literal">nullptr</span>)&#123;</span><br><span class="line"><span class="built_in">preOrder</span>(p);</span><br><span class="line">p = p-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>后序遍历过程中，对于一个节点，应该打印其左指针和全部右侧的节点后才打印该节点，即回溯时才打印当前节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(Tree&amp; t)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(t == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">TreeNode* p = t-&gt;left;</span><br><span class="line"><span class="keyword">while</span>(p != <span class="literal">nullptr</span>)&#123;</span><br><span class="line"><span class="built_in">PostOrder</span>(p); <span class="comment">//递归找“根”</span></span><br><span class="line">p = p-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;t-&gt;val&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>层序遍历，即类似于广度优先算法。对于一个节点，当打印左节点时，应将其右侧所有兄弟节点都打印再去下一层。打印其兄弟节点时，保留其左节点，即其子节点的兄弟。基于此，也可统计出每层的<strong>宽度</strong>。有注释的几行即为相应的宽度统计。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(Tree&amp; t)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(t == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">queue&lt;TreeNode*&gt; q;</span><br><span class="line">TreeNode* p;</span><br><span class="line">    <span class="keyword">int</span> max = INT_MIN; <span class="comment">//宽度</span></span><br><span class="line">q.<span class="built_in">push</span>(t);</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line"><span class="keyword">int</span> width = q.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; width;i ++)&#123;</span><br><span class="line">p = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">cout&lt;&lt;p-&gt;val&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">p = p-&gt;left;</span><br><span class="line"><span class="keyword">while</span>(p != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">q.<span class="built_in">push</span>(p);</span><br><span class="line">p = p-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        max = max &gt; width ? max: width;        <span class="comment">//一层遍历结束 统计宽度</span></span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> max;<span class="comment">//返回宽度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构&amp;算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
