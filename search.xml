<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>STL源码剖析</title>
      <link href="/2022/06/23/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
      <url>/2022/06/23/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>本文是我在学习候捷《STL标准库和泛型编程》课程时所做的笔记，在此分享给大家。</p><span id="more"></span><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>所有新式header的组件，都封装于“std”命名空间下。</p><h3 id="STL六大件"><a href="#STL六大件" class="headerlink" title="STL六大件"></a>STL六大件</h3><p>容器(Container)、算法(Algorithm)、分配器(Allocator)、迭代器(Iterator)、适配器(Adapter)、仿函数(Functor)</p><h4 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h4><p><img src="/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/image-20220611144209099.png" alt="image-20220611144209099"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">6</span>] = &#123;<span class="number">2</span>, <span class="number">52</span>, <span class="number">365</span>, <span class="number">37</span>, <span class="number">587</span>, <span class="number">23</span>&#125;;</span><br><span class="line">vector&lt;<span class="keyword">int</span>, allocator&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">vi</span>(ia, ia + <span class="number">6</span>);</span><br><span class="line">cout &lt;&lt; <span class="built_in">count_if</span>(vi.<span class="built_in">begin</span>(), vi.<span class="built_in">end</span>(), <span class="built_in">not1</span>(<span class="built_in">bind2nd</span>(less&lt;<span class="keyword">int</span>&gt;(), <span class="number">40</span>)));</span><br><span class="line"><span class="comment">//寻找范围内所有大于等于40的元素</span></span><br></pre></td></tr></table></figure><p><code>vector</code>容器。<code>allocator&lt;int&gt;</code>分配器。<code>vi.begin()</code>迭代器。<code>count_if()</code>算法。<code>not1</code>仿函数适配器。<code>less&lt;int&gt;()</code>仿函数。<code>bind2nd(a,b)</code>适配器，绑定第二参数。<code>not1()</code>适配器，否定相应内容。<br><code>not1(bind2nd(less&lt;int&gt;(), 40))</code>predicate，判断条件。<br><code>x.begin(),x.end()</code>维持的是左闭右开区间，<code>x.end()</code>指向最后一个元素的<mark>下一位置</mark>。</p><h4 id="迭代器遍历"><a href="#迭代器遍历" class="headerlink" title="迭代器遍历"></a>迭代器遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Container&lt;T&gt; c;</span><br><span class="line"><span class="keyword">for</span>(Container&lt;T&gt;::iterator iter = c.<span class="built_in">begin</span>(); iter!=c.<span class="built_in">end</span>(); ++iter)</span><br></pre></td></tr></table></figure><h3 id="容器分类"><a href="#容器分类" class="headerlink" title="容器分类"></a>容器分类</h3><p>红色部分为C++11新特性。<br><img src="/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/image-20220611144350303.png" alt="image-20220611144350303"></p><h4 id="顺序型容器"><a href="#顺序型容器" class="headerlink" title="顺序型容器"></a>顺序型容器</h4><h5 id="array"><a href="#array" class="headerlink" title="array"></a>array</h5><p>只是将数组封装成class。<br><code>size()、front()、back()</code>可用<br>声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array&lt;type,SIZE&gt; arr;</span><br><span class="line"><span class="comment">//必须声明类型及大小</span></span><br><span class="line">arr.<span class="built_in">data</span>()    <span class="comment">//起始地址</span></span><br></pre></td></tr></table></figure><h5 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h5><p>变长数组（尾部可变）</p><h5 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h5><p>两端可扩。是分段连续的。<br>每段一个buffer，每个buffer可以存储一定的元素（满，进入下一个buffer），buffer两端可扩展。</p><h5 id="list"><a href="#list" class="headerlink" title="list"></a>list</h5><p>双向链表。</p><h5 id="forward-list"><a href="#forward-list" class="headerlink" title="forward-list"></a>forward-list</h5><p>单链表。单链表没有<code>push_back()</code>,而是<code>push_front()</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">forward_list&lt;<span class="keyword">int</span>&gt; fl;</span><br><span class="line">    fl.<span class="built_in">push_front</span>(<span class="number">1</span>);</span><br><span class="line">    fl.<span class="built_in">pop_front</span>();</span><br></pre></td></tr></table></figure><h4 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h4><p>由deque封装而来。</p><h5 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h5><h5 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h5><h4 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h4><p>key-value。通过key找value。查找更方便。<br><code>multi</code>key可重复。<code>unordered</code>迭代器易失效。</p><h5 id="set-multiset"><a href="#set-multiset" class="headerlink" title="set/multiset"></a>set/multiset</h5><p>底层红黑树。每个节点key即为value。</p><h5 id="map-multimap"><a href="#map-multimap" class="headerlink" title="map/multimap"></a>map/multimap</h5><p>底层红黑树。除key之外有value。</p><h5 id="unordered-set-multiset"><a href="#unordered-set-multiset" class="headerlink" title="unordered set/multiset"></a>unordered set/multiset</h5><p>底层链式防冲突哈希表。每个节点key即为value。</p><h5 id="unordered-map-multimap"><a href="#unordered-map-multimap" class="headerlink" title="unordered map/multimap"></a>unordered map/multimap</h5><p>底层链式防冲突哈希表。除key之外有value。</p><h3 id="分配器"><a href="#分配器" class="headerlink" title="分配器"></a>分配器</h3><p>在定义时候，带有默认值。可以不声明。以vector为例。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc = std::allocator&lt;_Tp&gt;&gt;</span><br><span class="line">class vector : protected_Vector_base&lt;_Tp, _Alloc&gt;&#123;</span><br><span class="line">    ...............</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="OOP-vs-GP"><a href="#OOP-vs-GP" class="headerlink" title="OOP vs GP"></a>OOP vs GP</h3><p>面向对象编程(<code>OOP</code>)企图将数据(data)和方法(method)关联一起。<br>泛型编程(<code>GP</code>)企图将数据(data)和方法(method)分开。<br>GP可以将容器和算法各自分开开发，通过iterator连接即可。（操作符重载显得很重要）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Compare&gt;</span></span><br><span class="line"><span class="function">   <span class="keyword">inline</span> <span class="keyword">const</span> _Tp&amp;</span></span><br><span class="line"><span class="function">   <span class="title">max</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __a, <span class="keyword">const</span> _Tp&amp; __b, _Compare __comp)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">     <span class="comment">//return __comp(__a, __b) ? __b : __a;</span></span><br><span class="line">     <span class="keyword">if</span> (__comp(__a, __b))</span><br><span class="line"><span class="keyword">return</span> __b;</span><br><span class="line">     <span class="keyword">return</span> __a;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="STL源码基础"><a href="#STL源码基础" class="headerlink" title="STL源码基础"></a>STL源码基础</h3><h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h4><p><code>:: . .* ?:</code>这四个运算符不能够重载</p><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><p>主要用到的是类模板、函数模板。除此之外，还用到了特化。<br>特化之前要有<code>template&lt;&gt;</code></p><h3 id="分配器-1"><a href="#分配器-1" class="headerlink" title="分配器"></a>分配器</h3><h4 id="operator-new-amp-malloc"><a href="#operator-new-amp-malloc" class="headerlink" title="operator new &amp; malloc"></a>operator new &amp; malloc</h4><p>内存分配的底层都是调用<code>operator new</code> 然后调用<code>malloc</code>。通过<code>malloc</code>，调用操作系统的api。<br>malloc所申请的内存，除所申请的内存外还有一些附加的额外开销。(因为释放时只传入指针，通过这些附加属性可以找到需要释放的地址。)</p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>set里面复合红黑树，<mark>非继承</mark>。两侧表示相应的<code>sizeof</code>大小，至于容器中存的元素多少，与容器大小无关。<br>下图中缩进表示复合关系。<br><img src="/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/image-20220611144437337.png" alt="image-20220611144437337"></p><h4 id="list-1"><a href="#list-1" class="headerlink" title="list"></a>list</h4><p>为了使迭代器更好的自增自减，一般均设计为类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_node</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">void</span> *void_pointer;</span><br><span class="line">    void_pointer prev;</span><br><span class="line">    void_pointer next;</span><br><span class="line">    T data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">list</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> list_node&lt;T&gt; list_node;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> list_node *link_type;</span><br><span class="line">    <span class="keyword">typedef</span> list_iterator&lt;T, T &amp;, T *&gt; iterator;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    link_type node;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="keyword">class</span> <span class="title">Ref</span>,<span class="keyword">class</span> <span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_iterator</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> list_iterator&lt;T,Ref,Ptr&gt; self;</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">    <span class="keyword">typedef</span> Ref reference;</span><br><span class="line">    <span class="keyword">typedef</span> list_node&lt;T&gt; *link_type;</span><br><span class="line">    <span class="comment">//difference_type 和 iterator_category省略。</span></span><br><span class="line">    link_type node;</span><br><span class="line">    reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (*node).data;</span><br><span class="line">    &#125;</span><br><span class="line">    pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中需要特别注意的是，很多运算符已经重载，在阅读过程中要注意其功能及调用次序。<br>根据运算符的性质，考虑其返回值类型。（前置++传回引用，后置++传值)。</p><h4 id="iterator遵循的原则"><a href="#iterator遵循的原则" class="headerlink" title="iterator遵循的原则"></a>iterator遵循的原则</h4><p>trait,萃取。<br>algorithm要知道iterator的一些属性。 iterator共五种<code>associated type</code>。分别为(后面两种没有被使用过)</p><ul><li>iterator_category</li><li>difference_type</li><li>value_type</li><li>reference</li><li>pointer<br>以链表为例</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">List_iterator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> _List_iterator&lt;_Tp&gt;                _Self;</span><br><span class="line">    <span class="keyword">typedef</span> _List_node&lt;_Tp&gt;                    _Node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>                          difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> std::bidirectional_iterator_tag    iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp                                value_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp*                               pointer;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp&amp;                               reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>算法调用时，根据访问相应的类别，获取到相应的类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> I&gt;</span><br><span class="line"><span class="built_in">algorithm</span>(I first,I last) &#123;</span><br><span class="line">    I::iterator_category</span><br><span class="line">    I::difference_type</span><br><span class="line">    I::value_type</span><br><span class="line">    I::pointer</span><br><span class="line">    I::reference</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果传入的iterator不是class（比如指针），通过萃取机（中间件）获得相应的类型。</p><ul><li>间接询问</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Iterator&gt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::iterator_category iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::value_type        value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::difference_type   difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::pointer           pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::reference         reference;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><ul><li>偏特化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>&lt;</span>_Tp*&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp                         value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>                   difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp*                        pointer;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp&amp;                        reference;</span><br><span class="line">  &#125;;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>&lt;</span><span class="keyword">const</span> _Tp*&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp                         value_type; </span><br><span class="line">    <span class="comment">//value_type主要用来声明变量</span></span><br><span class="line">    <span class="comment">//如果是const，声明一个无法被赋值的变量，没有用。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>                   difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> _Tp*                  pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> _Tp&amp;                  reference;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><h4 id="vector-1"><a href="#vector-1" class="headerlink" title="vector"></a>vector</h4><p>vector 内部封装了三个迭代器<code>start</code>,<code>finish</code>,<code>end_of_storage</code>。<br>当容器填满时，在内存中分配另外一块两倍大小的空间。（造成迭代器失效）</p><h4 id="deque-1"><a href="#deque-1" class="headerlink" title="deque"></a>deque</h4><p>分段连续。内部有<code>start</code>、<code>finish</code>迭代器用来控制<code>map</code>（控制中心）首位，<code>map</code>中的元素指向相应的<code>buffer</code>。<code>buffer</code>里存放具体的数据。为了维持<strong>连续</strong>这一假象，当触及到<code>buffer</code>边界时，会扩充。除此之外，内部还有<code>map_size</code>来判断大小。</p><p><code>__deque_buf_size</code>存在默认值，每个缓冲区大小为512字节，然后根据参数类型改变。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">deque</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    iterator start;</span><br><span class="line">    iterator finish;</span><br><span class="line">    map_pointer map;</span><br><span class="line">    size_type map_size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">reference <span class="title">front</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> *start;&#125;</span><br><span class="line"><span class="function">reference <span class="title">back</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    iterator tmp = finish;</span><br><span class="line">    --tmp;</span><br><span class="line">    <span class="keyword">return</span> *tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> finish - start;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> finish == start;&#125;</span><br></pre></td></tr></table></figure><h5 id="deque迭代器"><a href="#deque迭代器" class="headerlink" title="deque迭代器"></a>deque迭代器</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">deque_iterator</span>&#123;</span></span><br><span class="line">    Elt_pointer cur;</span><br><span class="line">    Elt_pointer first;</span><br><span class="line">    Elt_pointer last;</span><br><span class="line">    Map_pointer node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="模拟连续空间"><a href="#模拟连续空间" class="headerlink" title="模拟连续空间"></a>模拟连续空间</h5><p>模拟连续空间主要是由<code>deque_iterator</code>实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *cur;</span><br><span class="line">&#125;</span><br><span class="line">pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个iterator之间距离:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">difference_type <span class="keyword">operator</span>-(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()) *(node - x.node - <span class="number">1</span>) + (cur - first) + (x.last - x.cur);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    node - x.node - 1     map中的完整缓冲区个数</span></span><br><span class="line"><span class="comment">    cur - first 尾迭代器buffer元素个数</span></span><br><span class="line"><span class="comment">    x.last - x.cur 头迭代器buffer元素个数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>++/–</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_node</span><span class="params">(map_pointer new_node)</span> </span>&#123;</span><br><span class="line">    node = new_node;</span><br><span class="line">    first = *new_node;</span><br><span class="line">    last = first +<span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self &amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">    ++cur;</span><br><span class="line">    <span class="comment">// 边界控制。跳下一个缓冲区</span></span><br><span class="line">    <span class="keyword">if</span>(cur == last) &#123;</span><br><span class="line">        <span class="built_in">set_node</span>(node + <span class="number">1</span>);</span><br><span class="line">        cur = first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    ++*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line">self &amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">    <span class="comment">// 边界控制 跳前一个缓冲区</span></span><br><span class="line">    <span class="keyword">if</span>(cur == first) &#123;</span><br><span class="line">        <span class="built_in">set_node</span>(node - <span class="number">1</span>);</span><br><span class="line">        cur = last;</span><br><span class="line">    &#125;</span><br><span class="line">    --cur;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">self <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123;</span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    --*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>+=/-=</p></blockquote><p>首先判断移动后的位置会不会跨越缓冲区边界。跨越则寻找合适位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">self&amp; <span class="keyword">operator</span>+=(difference_type n) &#123;</span><br><span class="line">    difference_type offset = n + (cur - first);</span><br><span class="line">    <span class="comment">// 不跨越缓冲区</span></span><br><span class="line">    <span class="keyword">if</span> (offset &gt;= <span class="number">0</span> &amp;&amp; offset &lt; <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>())) &#123;</span><br><span class="line">        cur += n;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//跨区</span></span><br><span class="line">        difference_type node_offset = offset &gt; <span class="number">0</span> ? offset / <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()) : -<span class="built_in">difference_type</span>((-offset - <span class="number">1</span>) / <span class="built_in">buffer_size</span>()) - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">set_node</span>(node + node_offset);</span><br><span class="line">        cur = first + (offset - node_offset * <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()));</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        三目运算符 </span></span><br><span class="line"><span class="comment">        true选项 offset / difference_type(buffer_size()) 正向 延伸 （+=）</span></span><br><span class="line"><span class="comment">        false选项 -difference_type((-offset - 1) / buffer_size()) - 1 反向延伸 (-=)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">self <span class="keyword">operator</span>+(difference_type n) <span class="keyword">const</span> &#123;</span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp += n;</span><br><span class="line">&#125;</span><br><span class="line">self &amp;<span class="keyword">operator</span>-=(different_type n) &#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span> += -n;</span><br><span class="line">&#125;</span><br><span class="line">self <span class="keyword">operator</span>-(different_type n) <span class="keyword">const</span> &#123;</span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp -= n;</span><br><span class="line">&#125;</span><br><span class="line">reference <span class="keyword">operator</span>[] (different_type n) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *(*<span class="keyword">this</span> + n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="stack-queue"><a href="#stack-queue" class="headerlink" title="stack/queue"></a>stack/queue</h5><p>底层容器可以是deque/list。此外，stack还可以选择vector作底层容器。<strong>默认</strong>是<code>deque</code>，在此基础上封装，调用<code>deque</code>去实现。</p><p>stack/queue不提供iterator，==不允许遍历==。</p><h4 id="RB-tree"><a href="#RB-tree" class="headerlink" title="RB_tree"></a>RB_tree</h4><ul><li><p>自平衡二叉搜索树。数据排列规则有利于<strong>插入</strong>和<strong>查找</strong>；</p></li><li><p><code>rb_tree</code>提供遍历功能。使用++遍历得到的结果是有序的(<code>sorted</code>)</p></li><li><p>不推荐<code>rb_tree</code>的<code>iterator</code>改值。（破坏排序规则）</p><ul><li>但并非编程层面禁止。<code>rb_tree</code>服务于<code>map</code>/<code>set</code>，而<code>map</code>允许改<code>value</code>值。</li></ul></li><li><p><code>rb_tree</code>提供两种插入<code>insert_unique()</code>和<code>insert_equal()</code>。表示是否允许key值重复。(multi)</p></li></ul><p>以下 $value = key + data$</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>,</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> <span class="title">Value</span>,  //<span class="title">value</span> =</span> key + data</span><br><span class="line">          <span class="class"><span class="keyword">class</span> <span class="title">KeyOfValue</span>, //在<span class="title">value</span>中捕获<span class="title">key</span>的方式</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> <span class="title">Compare</span>,    //<span class="title">key</span>比较方式</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;  <span class="comment">//底层分配器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">rb_tree</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> rb_tree_node&lt;Value&gt; rb_tree_node;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> rb_tree_node *link_type;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    size_type node_count;   <span class="comment">//rb_tree节点数量</span></span><br><span class="line">    link_type header;       <span class="comment">//不放值，指向根节点</span></span><br><span class="line">    Compare key_compare;    <span class="comment">//大小比较规则。是函数对象。</span></span><br><span class="line">&#125;;</span><br><span class="line">rb_tree&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, identity&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt;, alloc&gt; TreeNode;</span><br><span class="line"><span class="comment">// 仿函数.将传入的东西返回.</span></span><br><span class="line"><span class="comment">// unary_function参数：元素类型、返回值类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">identity</span> :</span> <span class="keyword">public</span> unary_function&lt;T,T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> T &amp;<span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T &amp;x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 比较方式</span></span><br><span class="line"><span class="comment">// unary_function参数：元素类型、元素类型、返回值类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">less</span> :</span><span class="keyword">public</span> binary_function&lt;T,T,<span class="keyword">bool</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T &amp;x, <span class="keyword">const</span> T &amp;y)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一个红黑树节点包括<code>3ptr+1 enum =24 Bytes</code></p><p>3ptr:<code>parent</code>、<code>right</code>、<code>left</code></p><h5 id="set-multiset-1"><a href="#set-multiset-1" class="headerlink" title="set/multiset"></a>set/multiset</h5><ul><li><code>set/multiset</code>以<code>rb_tree</code>为底层，元素会自动排序(依据<code>key</code>)。</li><li><strong>禁止</strong>通过iterator改值。</li><li>set所有操作都对底层红黑树进行操作。可以理解为<strong>容器适配器</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>,</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> <span class="title">Compare</span> =</span> less&lt;Key&gt;,</span><br><span class="line">          <span class="class"><span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">set</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// typedefs</span></span><br><span class="line">    <span class="keyword">typedef</span> Key key_type;</span><br><span class="line">    <span class="keyword">typedef</span> Key value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Compare key_compare;</span><br><span class="line">    <span class="keyword">typedef</span> Compare value_compare;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> rb_tree&lt;key_type, value_type, identity&lt;value_type&gt;, key_compare, Alloc&gt; rep_type;</span><br><span class="line">    rep_type t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_iterator iterator;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="map-multimap-1"><a href="#map-multimap-1" class="headerlink" title="map/multimap"></a>map/multimap</h5><ul><li>以<code>rb_tree</code>为底层，元素会自动排序(依据<code>key</code>)。</li><li><strong>禁止</strong>通过iterator改<code>key</code>值，但可以改<code>data</code>($data = value - key$)通过将<code>key_type</code>指定为<code>const</code>实现。</li><li>map中可以用operator[]访问。存在，则修改<code>data</code>或访问。否则，创建节点。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>,</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> <span class="title">T</span>,</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> <span class="title">Compare</span> =</span> less&lt;Key&gt;,</span><br><span class="line">          <span class="class"><span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">map</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// typedefs</span></span><br><span class="line">    <span class="keyword">typedef</span> Key key_type;</span><br><span class="line">    <span class="keyword">typedef</span> T data_type;</span><br><span class="line">    <span class="keyword">typedef</span> T mapped_type;</span><br><span class="line">    <span class="keyword">typedef</span> pair&lt;<span class="keyword">const</span> Key, T&gt; value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Compare key_compare;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> rb_tree&lt;key_type, value_type, select1st&lt;value_type&gt;, key_compare, Alloc&gt; rep_type;</span><br><span class="line">    rep_type t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator iterator;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="hashtable"><a href="#hashtable" class="headerlink" title="hashtable"></a>hashtable</h4><ul><li><p>哈希冲突时再哈希时间复杂度过高，采用==链式==存储解决此问题。</p></li><li><p>每个<code>Hash(x)</code>值为一个<code>bucket</code>。</p></li><li><p>当元素个数超过bucket个数时，<code>rehash</code>。<code>bucket</code>个数通常为<strong>质数</strong>，每次<strong>扩充</strong>约为<strong>2倍</strong>。</p></li><li><p>可以通过<code>iterator</code>改data，但<strong>不能</strong>改<code>key</code>。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">hashtable_node</span> &#123;</span></span><br><span class="line">    __hashtable_node *next;</span><br><span class="line">    Value val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>,</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> <span class="title">Key</span>,</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> <span class="title">HashFcn</span>,</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> <span class="title">EXtractKey</span>,</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> <span class="title">EqualKey</span>,</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">hashtable_iterator</span> &#123;</span></span><br><span class="line">    node *cur;</span><br><span class="line">    hashtable *ht;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>,</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> <span class="title">Key</span>,</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> <span class="title">HashFcn</span>,    //哈希映射</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> <span class="title">EXtractKey</span>, //在所存取的数据中取<span class="title">key</span></span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> <span class="title">EqualKey</span>,   //给定元素比对的原则</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hashtable</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> HashFcn hasher;</span><br><span class="line">    <span class="keyword">typedef</span> EqualKey key_equal;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    hasher hash;</span><br><span class="line">    key_equal equals;</span><br><span class="line">    EXtractKey get_key;</span><br><span class="line">    <span class="keyword">typedef</span> __hashtable_node&lt;Value&gt; node;</span><br><span class="line">    vector&lt;node *, Alloc&gt; buckets;</span><br><span class="line">    size_type num_elements;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">size_type <span class="title">bucket_count</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buckets.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="modulus运算"><a href="#modulus运算" class="headerlink" title="modulus运算"></a>modulus运算</h5><p>通过计算得出元素该存放在哪个<code>bucket</code>。</p><p>$hash(key) \mod(n)$</p><p>c++11开始，<code>hashtable_xxx</code>更名为<code>unordered_xxx</code>。</p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器共五种</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_iterator_tag</span> &#123;</span>&#125;;<span class="comment">//</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">output_iterator_tag</span> &#123;</span>&#125;;<span class="comment">//</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">forward_iterator_tag</span>:</span> <span class="keyword">public</span> input_iterator_tag&#123;&#125;;<span class="comment">//单向</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bidirectional_iterator_tag</span>:</span> <span class="keyword">public</span> forward_iterator_tag&#123;&#125;;<span class="comment">//双向</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">random_access_iterator_tag</span>:</span> <span class="keyword">public</span> bidirectional_iterator_tag&#123;&#125;;<span class="comment">//随机访问</span></span><br></pre></td></tr></table></figure><p>调用时根据萃取机获取迭代器的类型(<code>iterator_category</code>)然后进行相应的调用。<br>不同类型的迭代器对元素访问的方式也不同，因此迭代器类型不同，可能会对算法有影响</p><p>样例如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> iterator_traits&lt;InputIterator&gt;::<span class="function">difference_type <span class="title">distance</span><span class="params">(InputIterator first,InputIterator last,input_iterator_tag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::iterator_category category n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">        ++first;</span><br><span class="line">        ++n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> iterator_traits&lt;RandomAccessIterator&gt;::difference_type _distance(RandomAccessIterator first,RandomAccessIterator last, random_access_iterator_tag) &#123;</span><br><span class="line">    <span class="keyword">return</span> last - first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> iterator_traits&lt;InputIterator&gt;::<span class="function">difference_type <span class="title">distance</span><span class="params">(InputIterator first,InputIterator last)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::iterator_category category;</span><br><span class="line">    <span class="keyword">return</span> _distance(first, last, <span class="built_in">category</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于上述算法只对<code>input_iterator</code> 和<code>random_access_iterator</code>进行了实现，当使用其他类型的迭代器(如<code>forward_iterator</code>)进行调用时，由于<code>forward_iterator</code><strong>继承</strong>自<code>input_iterator</code>，故调用对<code>input_iterator</code>实现的函数。</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>标准库中所有的<code>Algorithm</code>都看不见<code>Container</code>，而是通过<code>iterator</code>进行操作。</p><p><code>Algorithm</code>一定需要传入首尾<strong>两个迭代器</strong>。</p><p><code>xxx</code>,<code>xxx_if</code>,<code>xxx_copy</code>（如replace，replace_if）前一个是一个默认条件，<code>xxx_if</code>支持自己给出一个条件，<code>xxx_copy</code>不会改原值，而是返回一个新创建的序列。</p><h3 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h3><p>又叫函数对象，服务于算法。仿函数分类：</p><ul><li>算术类：plus(+)、minus(-)</li><li>逻辑运算类：logical_and</li><li>相对关系类：equal_to、less</li></ul><p><code>GNU C++</code>（GCC）有一些独有的仿函数：identity、select1st、select2nd。（==非标准库==）</p><h3 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h3><p>适配器、改造器。可分为容器适配器、迭代器适配器、仿函数适配器。修改一些对外的接口，使得相应的组件能够适配。</p><blockquote><p>仿函数适配器</p></blockquote><h4 id="binder2nd"><a href="#binder2nd" class="headerlink" title="binder2nd"></a>binder2nd</h4><p><code>bind2nd</code>为辅助函数，其底层仍为<code>binder2nd</code>。绑定第二实参。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Operation&gt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">binder2nd</span></span></span><br><span class="line"><span class="class">    :</span> <span class="keyword">public</span> unary_function&lt;<span class="keyword">typename</span> _Operation::first_argument_type,</span><br><span class="line">    <span class="keyword">typename</span> _Operation::result_type&gt;</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">      _Operation op;</span><br><span class="line">      <span class="keyword">typename</span> _Operation::second_argument_type value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">binder2nd</span>(<span class="keyword">const</span> _Operation&amp; __x,</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">typename</span> _Operation::second_argument_type&amp; __y)</span><br><span class="line">      : <span class="built_in">op</span>(__x), <span class="built_in">value</span>(__y) &#123; &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">typename</span> _Operation::result_type</span></span><br><span class="line"><span class="function">      <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">typename</span> _Operation::first_argument_type&amp; __x)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">      </span>&#123; <span class="keyword">return</span> <span class="built_in">op</span>(__x, value); &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// _GLIBCXX_RESOLVE_LIB_DEFECTS</span></span><br><span class="line">      <span class="comment">// 109.  Missing binders for non-const sequence elements</span></span><br><span class="line">      <span class="function"><span class="keyword">typename</span> _Operation::result_type</span></span><br><span class="line"><span class="function">      <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">typename</span> _Operation::first_argument_type&amp; __x)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">      </span>&#123; <span class="keyword">return</span> <span class="built_in">op</span>(__x, value); &#125;</span><br><span class="line">    &#125; _GLIBCXX_DEPRECATED;</span><br></pre></td></tr></table></figure><p><code>typedef typename xxx xx</code>中的<code>typename</code>主要用于告诉编译器<code>xxx</code>的类型，以方便编译器能够更好的识别。</p><p>现版本的<code>binder2nd、binder1st</code>被<code>bind</code>替代。</p><h4 id="not1"><a href="#not1" class="headerlink" title="not1"></a>not1</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; class Predicate &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> std::unary_negate&lt;Predicate&gt; <span class="title">not1</span><span class="params">(<span class="keyword">const</span> Predicate&amp; pred)</span></span>;</span><br></pre></td></tr></table></figure><p>用于创建函数对象的辅助函数，该函数对象返回所传递的<strong>一元</strong>(同理，not2创建的是二元)谓词函数的补码。</p><h5 id="一元、二元"><a href="#一元、二元" class="headerlink" title="一元、二元"></a>一元、二元</h5><p>元表示的是操作数的个数。一元(<code>unary</code>)如less（＜<code>xxx</code>）。二元(<code>binary</code>)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Arg</span>,<span class="keyword">class</span> _<span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">unary_function</span></span></span><br><span class="line"><span class="class">&#123;</span><span class="comment">// base class for unary functions</span></span><br><span class="line"><span class="keyword">typedef</span> _Arg argument_type;</span><br><span class="line"><span class="keyword">typedef</span> _Result result_type;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// TEMPLATE STRUCT binary_function</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Arg1</span>,<span class="keyword">class</span> _<span class="title">Arg2</span>,<span class="keyword">class</span> _<span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binary_function</span></span></span><br><span class="line"><span class="class">&#123;</span><span class="comment">// base class for binary functions</span></span><br><span class="line"><span class="keyword">typedef</span> _Arg1 first_argument_type;</span><br><span class="line"><span class="keyword">typedef</span> _Arg2 second_argument_type;</span><br><span class="line"><span class="keyword">typedef</span> _Result result_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><p>取代了<code>bind1st,bind2nd</code>。可以绑定函数、仿函数、成员函数、成员变量。 返回值是仿函数。</p><p>以除法为例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">divide</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x/y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> x1 = <span class="built_in">bind</span>(divide,a,b);</span><br><span class="line">cout &lt;&lt; <span class="built_in">x1</span>(); <span class="comment">//a/b</span></span><br><span class="line"><span class="keyword">auto</span> x2 = <span class="built_in">bind</span>(divide,_1,b);</span><br><span class="line">cout &lt;&lt; <span class="built_in">x2</span>(x); <span class="comment">//x/b</span></span><br><span class="line"><span class="keyword">auto</span> x3 = <span class="built_in">bind</span>(divide,_2,_1);</span><br><span class="line">cout &lt;&lt; <span class="built_in">x3</span>(x,y); <span class="comment">//y/x</span></span><br><span class="line"><span class="keyword">auto</span> x4 = bind&lt;<span class="keyword">int</span>&gt;(···)<span class="comment">//指定返回值类型</span></span><br></pre></td></tr></table></figure><p>bind()绑定成员变量时，有一个隐藏的参数<code>this指针</code></p><blockquote><p>迭代器适配器</p></blockquote><h4 id="reverse-iterator"><a href="#reverse-iterator" class="headerlink" title="reverse_iterator"></a>reverse_iterator</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="built_in">reverse_iterator</span>(<span class="built_in">end</span>());&#125;</span><br><span class="line"><span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="built_in">reverse_iterator</span>(<span class="built_in">begin</span>());&#125;</span><br></pre></td></tr></table></figure><p>在实现具体使用时，对<strong>逆向后的迭代器</strong>取值相当于把<strong>正向迭代器退一格</strong>取值。<code>reverse_iterator</code>的<code>++、--、+n、-n</code>也要逆序</p><h4 id="inserter"><a href="#inserter" class="headerlink" title="inserter"></a>inserter</h4><p>以第三参数传入，调用相应的运算符重载，在数组中指定位置插入相应的新数据（后面的数据会后移）</p><h4 id="ostream-iterator"><a href="#ostream-iterator" class="headerlink" title="ostream_iterator"></a>ostream_iterator</h4><p>可以简化输出过程。利用ostream_iterator。现有一个数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt;arr&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="function">ostream_iterator&lt;<span class="keyword">int</span>&gt; <span class="title">temp</span><span class="params">(cout,<span class="string">&quot;,&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">copy</span>(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>(),temp);</span><br><span class="line"><span class="comment">//输出1,2,3,4,5,6,7,</span></span><br></pre></td></tr></table></figure><p><code>cout</code>是输出流，<code>ostream_iterator</code>将指定内容写入流中。</p><h4 id="istream-iterator"><a href="#istream-iterator" class="headerlink" title="istream_iterator"></a>istream_iterator</h4><p>输入流。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">istream_iterator&lt;<span class="keyword">double</span>&gt;eos;<span class="comment">//end-of-stream</span></span><br><span class="line">istream_iterator&lt;<span class="keyword">double</span>&gt;<span class="built_in">iit</span>(cin);</span><br><span class="line"><span class="keyword">if</span>(iit!=eos)</span><br><span class="line">    value1=*iit; <span class="comment">//取第一个值</span></span><br><span class="line">++iit;</span><br><span class="line"><span class="keyword">if</span>(iit!=eos)</span><br><span class="line">    value2=*iit;<span class="comment">//取第二个值</span></span><br><span class="line">cout&lt;&lt;value1 &lt;&lt;<span class="string">&quot;*&quot;</span>&lt;&lt;value2&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;value1*value2;</span><br></pre></td></tr></table></figure><h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><p>指定任意类型的任意元素。类似于一个临时创建的结构体。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tuple&lt;<span class="keyword">int</span>,<span class="keyword">double</span>,string&gt;<span class="built_in">t1</span>(<span class="number">41</span>,<span class="number">6.3</span>,<span class="string">&quot;niko&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> t2 = <span class="built_in">make_tuple</span>(<span class="number">41</span>,<span class="number">25</span>,<span class="string">&quot;zzz&quot;</span>);</span><br><span class="line">get&lt;<span class="number">0</span>&gt;(t1);<span class="comment">//取41</span></span><br></pre></td></tr></table></figure><p>tuple可以赋值、比较(相同类型依次比较元素)、直接cout输出。</p><p><code>tuple_size</code>可以知道元素的个数</p><p><code>tuple_element</code>可以知道元素的类型</p><p>利用可变模板元来实现的tuple。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Values&gt;<span class="class"><span class="keyword">class</span> <span class="title">tuple</span>;</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="class"><span class="keyword">class</span> <span class="title">tuple</span>&lt;</span>&gt;&#123;&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head,<span class="keyword">typename</span>... Tail&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">typle</span>&lt;</span>Head,Tail...&gt;:<span class="keyword">private</span> tuple&lt;Tail...&gt;&#123;</span><br><span class="line">    <span class="keyword">typedef</span> tuple&lt;Tail...&gt;inherited;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">tuple</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">tuple</span>(Head v, Tail... vtail):<span class="built_in">m_head</span>(v),<span class="built_in">inherited</span>(vtail...)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">typename</span> Head::type <span class="title">head</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> m_head;&#125;</span><br><span class="line">    inherited&amp; tail &#123;<span class="keyword">return</span> &amp;<span class="keyword">this</span>;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Head m_head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每次分为$1+x$.当最终没有参数时，执行<code>tuple&lt;&gt;</code>结束.</p><h3 id="type-traits"><a href="#type-traits" class="headerlink" title="type traits"></a>type traits</h3><p>将功能相同而参数不同的函数进行抽象</p><p>通过traits将不同的参数的相同属性提取出来，在函数中利用这些用traits提取的属性，使得函数对不同的参数表现一致。故，可实现在编译期计算、判断、转换、查询等等功能。</p><p><code>c++</code>为默认数据类型都提供了相应的类型萃取机制，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span>&lt;</span><span class="keyword">int</span>&gt;&#123;</span><br><span class="line">    <span class="keyword">typedef</span> __true_type has_trivial_default_constructor;</span><br><span class="line">    <span class="keyword">typedef</span> __true_type has_trivial_copy_constructor;</span><br><span class="line">    <span class="keyword">typedef</span> __true_type has_trivial_assignment_operator;</span><br><span class="line">    <span class="keyword">typedef</span> __true_type has_trivial_destructor;</span><br><span class="line">    <span class="keyword">typedef</span> __true_type is_POD_type; <span class="comment">// Plain Old Data</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="is-void"><a href="#is-void" class="headerlink" title="is_void"></a>is_void</h4><p>去除掉<code>const</code>和<code>volatile</code>之后返回类型。然后调用相应的辅助函数，如果有相应的参数（偏特化），则返回<code>true</code>，否则返回<code>false</code>。</p><p>进而扩展<code>is_class、is_union、is_enum、is_pod</code>，但并没有找到。</p><h3 id="cout"><a href="#cout" class="headerlink" title="cout"></a>cout</h3><p>cout对<code>&lt;&lt;</code>运算符的<strong>各种输入</strong>进行重载，以实现可以随意输出。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 候捷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复数类</title>
      <link href="/2022/05/23/%E5%A4%8D%E6%95%B0%E7%B1%BB/"/>
      <url>/2022/05/23/%E5%A4%8D%E6%95%B0%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>本文主要根据候捷《面向对象高级开发》课程实现的一个复数类。所涉及的功能有 加减乘（除法我高中没学过）、以及对应的+=、-=、*=。还有取模、取反、求共轭复数、判断是否相同、输出等。代码将分模块的进行讲述，不想看可以直接滑到文末。文末会给出完整代码。</p><span id="more"></span><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>首先，实现的是类的初始化及对其数据成员的访问。<br>由于访问数据成员并不会修改其相应的值，可以设置为常函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="keyword">double</span> x, <span class="keyword">double</span> y) : <span class="built_in">re</span>(x), <span class="built_in">im</span>(y)&#123;&#125;</span><br><span class="line">    <span class="built_in">Complex</span>() : <span class="built_in">re</span>(<span class="number">0</span>), <span class="built_in">im</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">real</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> re; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">imag</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> im; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> re, im;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="取模"><a href="#取模" class="headerlink" title="取模"></a>取模</h2><p>取模，即输出 $\sqrt {re^2 +im^2}$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="keyword">this</span>-&gt;re * <span class="keyword">this</span>-&gt;re + <span class="keyword">this</span>-&gt;im * <span class="keyword">this</span>-&gt;im, <span class="number">0.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> re, im;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="共轭复数"><a href="#共轭复数" class="headerlink" title="共轭复数"></a>共轭复数</h2><p>共轭复数，即实部相同，虚部互为相反数。<br>求共轭复数，并不会改变原复数。故不返回引用类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Complex <span class="title">conj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(<span class="keyword">this</span>-&gt;re, -<span class="keyword">this</span>-&gt;im);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> re, im;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><h3 id="X"><a href="#X" class="headerlink" title="X="></a>X=</h3><p>先实现的是在原对象基础上修改的操作，+=，-=，*=。在原对象的基础上与另一个对象进行运算。<br>根据相关的运算性质，有着如下的代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Complex &amp;<span class="keyword">operator</span>+=(<span class="keyword">const</span> Complex &amp;c);</span><br><span class="line">    Complex &amp;<span class="keyword">operator</span>-=(<span class="keyword">const</span> Complex &amp;c);</span><br><span class="line">    Complex &amp;<span class="keyword">operator</span>*=(<span class="keyword">const</span> Complex &amp;c);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> re, im;</span><br><span class="line">    <span class="keyword">friend</span> Complex &amp;_plus(Complex *, <span class="keyword">const</span> Complex &amp;);</span><br><span class="line">    <span class="keyword">friend</span> Complex &amp;_minus(Complex *, <span class="keyword">const</span> Complex &amp;);</span><br><span class="line">    <span class="keyword">friend</span> Complex &amp;_times(Complex *, <span class="keyword">const</span> Complex &amp;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//  + </span></span><br><span class="line"><span class="keyword">inline</span> Complex &amp;_plus(Complex *ths, <span class="keyword">const</span> Complex &amp;c) &#123;</span><br><span class="line">    ths-&gt;re += c.re;</span><br><span class="line">    ths-&gt;im += c.im;</span><br><span class="line">    <span class="keyword">return</span> *ths;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// += Complex</span></span><br><span class="line"><span class="keyword">inline</span> Complex &amp; Complex::<span class="keyword">operator</span> += (<span class="keyword">const</span> Complex &amp; c) &#123;</span><br><span class="line">    <span class="keyword">return</span> _plus(<span class="keyword">this</span>, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  - </span></span><br><span class="line"><span class="keyword">inline</span> Complex &amp;_minus (Complex *ths, <span class="keyword">const</span> Complex &amp;c) &#123;</span><br><span class="line">    ths-&gt;re -= c.re;</span><br><span class="line">    ths-&gt;im -= c.im;</span><br><span class="line">    <span class="keyword">return</span> *ths;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -= Complex</span></span><br><span class="line"><span class="keyword">inline</span> Complex &amp; Complex::<span class="keyword">operator</span> -= (<span class="keyword">const</span> Complex &amp; c) &#123;</span><br><span class="line">    <span class="keyword">return</span> _minus(<span class="keyword">this</span>, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  * </span></span><br><span class="line"><span class="keyword">inline</span> Complex &amp;_times(Complex *ths, <span class="keyword">const</span> Complex &amp;c) &#123;</span><br><span class="line">    ths-&gt;re = ths-&gt;re * c.re - ths-&gt;im * c.im;</span><br><span class="line">    ths-&gt;im = ths-&gt;re * c.im + ths-&gt;im * c.re;</span><br><span class="line">    <span class="keyword">return</span> *ths;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// *= Complex</span></span><br><span class="line"><span class="keyword">inline</span> Complex &amp; Complex::<span class="keyword">operator</span>*=(<span class="keyword">const</span> Complex &amp; c) &#123;</span><br><span class="line">    <span class="keyword">return</span> _times(<span class="keyword">this</span>, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此外，还写出了相应的与纯实数进行运算。（纯实数可以是一个<code>int、double</code>等基本数据类型，而纯虚数是实部为0的对象，故不重复实现）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    Complex &amp;<span class="keyword">operator</span>+=(<span class="keyword">const</span> T num);</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    Complex &amp;<span class="keyword">operator</span>-=(<span class="keyword">const</span> T num);</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    Complex &amp;<span class="keyword">operator</span>*=(<span class="keyword">const</span> T num);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> re, im;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// += number</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> Complex &amp; Complex::<span class="keyword">operator</span> += (<span class="keyword">const</span> T num) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;re += num;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -= number</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> Complex &amp; Complex::<span class="keyword">operator</span> -= (<span class="keyword">const</span> T num) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;re -= num;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// *=number</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> Complex &amp; Complex::<span class="keyword">operator</span> *= (<span class="keyword">const</span> T num) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;re *= num;</span><br><span class="line">    <span class="keyword">this</span>-&gt;im *= num;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title="+-*"></a>+-*</h3><p>重载完带<code>=</code>的运算符后，开始重载基本的运算符，定义了三个基本操作 <code>+-*</code>分别实现两个复数间的<code>+-*</code><br>由于在类内部尝试重载时，发生相应的错误（参数个数过多），于是在类的外部定义了相应的功能函数。<br>在该部分，考虑到运算符左右的参数类型的问题，同样进行了重载。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Complex + Complex</span></span><br><span class="line"><span class="keyword">inline</span> Complex  <span class="keyword">operator</span>+ (<span class="keyword">const</span> Complex &amp; x,<span class="keyword">const</span> Complex &amp; y) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(x.<span class="built_in">real</span>() + y.<span class="built_in">real</span>(), x.<span class="built_in">imag</span>() + y.<span class="built_in">imag</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Complex + number</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;c, T num) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(c.<span class="built_in">real</span>() + num, c.<span class="built_in">imag</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// number + Complex</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>+(T num, <span class="keyword">const</span> Complex &amp;c) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(c.<span class="built_in">real</span>() + num, c.<span class="built_in">imag</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Complex - Complex</span></span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>-(<span class="keyword">const</span> Complex &amp;x, <span class="keyword">const</span> Complex &amp;y) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(x.<span class="built_in">real</span>() - y.<span class="built_in">real</span>(), x.<span class="built_in">imag</span>() - y.<span class="built_in">imag</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Complex - number</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>-(<span class="keyword">const</span> Complex &amp;c, T num) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(c.<span class="built_in">real</span>() - num, c.<span class="built_in">imag</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// number - Complex</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>-(T num, <span class="keyword">const</span> Complex &amp;c) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(num - c.<span class="built_in">real</span>(), -c.<span class="built_in">imag</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Complex * Complex</span></span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>*(<span class="keyword">const</span> Complex &amp;x, <span class="keyword">const</span> Complex &amp;y) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(x.<span class="built_in">real</span>() * y.<span class="built_in">real</span>() - x.<span class="built_in">imag</span>() * y.<span class="built_in">imag</span>(), x.<span class="built_in">real</span>() * y.<span class="built_in">imag</span>() + x.<span class="built_in">imag</span>() * y.<span class="built_in">real</span>());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Complex * number</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>*(<span class="keyword">const</span> Complex &amp;c, T num) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(c.<span class="built_in">real</span>() * num, c.<span class="built_in">imag</span>() * num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// number * Complex</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>*(T num, <span class="keyword">const</span> Complex &amp;c) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(c.<span class="built_in">real</span>() * num, c.<span class="built_in">imag</span>() * num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="取反（-X）"><a href="#取反（-X）" class="headerlink" title="取反（-X）"></a>取反（-X）</h3><p>私以为取反是用来赋值，故并未修改原对象的成员变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -Complex</span></span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>-(<span class="keyword">const</span> Complex &amp;c) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(-c.<span class="built_in">real</span>(), -c.<span class="built_in">imag</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（！-）"><a href="#（！-）" class="headerlink" title="==（！=）"></a>==（！=）</h3><p>实部虚部完全相同为相等，任一个不同则为不同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ==</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Complex &amp;x, <span class="keyword">const</span> Complex &amp;y) &#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">return</span></span> (x.<span class="built_in">real</span>() == y.<span class="built_in">real</span>()) &amp;&amp; (x.<span class="built_in">imag</span>() == y.<span class="built_in">imag</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// !=</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Complex &amp;x, <span class="keyword">const</span> Complex &amp;y) &#123;</span><br><span class="line">    <span class="comment">// return !(x == y);   //不是相同则为不同</span></span><br><span class="line">    <span class="built_in"><span class="keyword">return</span></span> (x.<span class="built_in">real</span>() != y.<span class="built_in">real</span>()) || (x.<span class="built_in">imag</span>() != y.<span class="built_in">imag</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>输出的格式为<code>a+b i</code>，考虑到美观性，额外的判断了下<code>a==0 b==0 b &lt; 0</code>的情况。即，<code>0+3i、1+0i、1+（-3）i</code>类型特殊化处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt;(ostream&amp; os,<span class="keyword">const</span> Complex &amp; c) &#123;</span><br><span class="line">    <span class="keyword">if</span> (c.<span class="built_in">real</span>() &amp;&amp; c.<span class="built_in">imag</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c.<span class="built_in">imag</span>() &gt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> os &lt;&lt; c.<span class="built_in">real</span>() &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; c.<span class="built_in">imag</span>() &lt;&lt; <span class="string">&quot;i&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> os &lt;&lt; c.<span class="built_in">real</span>() &lt;&lt; c.<span class="built_in">imag</span>() &lt;&lt; <span class="string">&quot;i&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c.<span class="built_in">real</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> os &lt;&lt; c.<span class="built_in">real</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> os &lt;&lt; c.<span class="built_in">imag</span>() &lt;&lt; <span class="string">&quot;i&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完整代码及部分测试"><a href="#完整代码及部分测试" class="headerlink" title="完整代码及部分测试"></a>完整代码及部分测试</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="keyword">double</span> x, <span class="keyword">double</span> y) : <span class="built_in">re</span>(x), <span class="built_in">im</span>(y)&#123;&#125;</span><br><span class="line">    <span class="built_in">Complex</span>() : <span class="built_in">re</span>(<span class="number">0</span>), <span class="built_in">im</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">real</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> re; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">imag</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> im; &#125;</span><br><span class="line">    Complex &amp;<span class="keyword">operator</span>+=(<span class="keyword">const</span> Complex &amp;c);</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    Complex &amp;<span class="keyword">operator</span>+=(<span class="keyword">const</span> T num);</span><br><span class="line"></span><br><span class="line">    Complex &amp;<span class="keyword">operator</span>-=(<span class="keyword">const</span> Complex &amp;c);</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    Complex &amp;<span class="keyword">operator</span>-=(<span class="keyword">const</span> T num);</span><br><span class="line"></span><br><span class="line">    Complex &amp;<span class="keyword">operator</span>*=(<span class="keyword">const</span> Complex &amp;c);</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    Complex &amp;<span class="keyword">operator</span>*=(<span class="keyword">const</span> T num);</span><br><span class="line"></span><br><span class="line">    <span class="function">Complex <span class="title">conj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(<span class="keyword">this</span>-&gt;re, -<span class="keyword">this</span>-&gt;im);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="keyword">this</span>-&gt;re * <span class="keyword">this</span>-&gt;re + <span class="keyword">this</span>-&gt;im * <span class="keyword">this</span>-&gt;im, <span class="number">0.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> re, im;</span><br><span class="line">    <span class="keyword">friend</span> Complex &amp;_plus(Complex *, <span class="keyword">const</span> Complex &amp;);</span><br><span class="line">    <span class="keyword">friend</span> Complex &amp;_minus(Complex *, <span class="keyword">const</span> Complex &amp;);</span><br><span class="line">    <span class="keyword">friend</span> Complex &amp;_times(Complex *, <span class="keyword">const</span> Complex &amp;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//  + </span></span><br><span class="line"><span class="keyword">inline</span> Complex &amp;_plus(Complex *ths, <span class="keyword">const</span> Complex &amp;c) &#123;</span><br><span class="line">    ths-&gt;re += c.re;</span><br><span class="line">    ths-&gt;im += c.im;</span><br><span class="line">    <span class="keyword">return</span> *ths;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  - </span></span><br><span class="line"><span class="keyword">inline</span> Complex &amp;_minus (Complex *ths, <span class="keyword">const</span> Complex &amp;c) &#123;</span><br><span class="line">    ths-&gt;re -= c.re;</span><br><span class="line">    ths-&gt;im -= c.im;</span><br><span class="line">    <span class="keyword">return</span> *ths;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  * </span></span><br><span class="line"><span class="keyword">inline</span> Complex &amp;_times(Complex *ths, <span class="keyword">const</span> Complex &amp;c) &#123;</span><br><span class="line">    ths-&gt;re = ths-&gt;re * c.re - ths-&gt;im * c.im;</span><br><span class="line">    ths-&gt;im = ths-&gt;re * c.im + ths-&gt;im * c.re;</span><br><span class="line">    <span class="keyword">return</span> *ths;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// += Complex</span></span><br><span class="line"><span class="keyword">inline</span> Complex &amp; Complex::<span class="keyword">operator</span> += (<span class="keyword">const</span> Complex &amp; c) &#123;</span><br><span class="line">    <span class="keyword">return</span> _plus(<span class="keyword">this</span>, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// += number</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> Complex &amp; Complex::<span class="keyword">operator</span> += (<span class="keyword">const</span> T num) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;re += num;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -= Complex</span></span><br><span class="line"><span class="keyword">inline</span> Complex &amp; Complex::<span class="keyword">operator</span> -= (<span class="keyword">const</span> Complex &amp; c) &#123;</span><br><span class="line">    <span class="keyword">return</span> _minus(<span class="keyword">this</span>, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -= number</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> Complex &amp; Complex::<span class="keyword">operator</span> -= (<span class="keyword">const</span> T num) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;re -= num;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// *= Complex</span></span><br><span class="line"><span class="keyword">inline</span> Complex &amp; Complex::<span class="keyword">operator</span>*=(<span class="keyword">const</span> Complex &amp; c) &#123;</span><br><span class="line">    <span class="keyword">return</span> _times(<span class="keyword">this</span>, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// *=number</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> Complex &amp; Complex::<span class="keyword">operator</span> *= (<span class="keyword">const</span> T num) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;re *= num;</span><br><span class="line">    <span class="keyword">this</span>-&gt;im *= num;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Complex + Complex</span></span><br><span class="line"><span class="keyword">inline</span> Complex  <span class="keyword">operator</span>+ (<span class="keyword">const</span> Complex &amp; x,<span class="keyword">const</span> Complex &amp; y) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(x.<span class="built_in">real</span>() + y.<span class="built_in">real</span>(), x.<span class="built_in">imag</span>() + y.<span class="built_in">imag</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Complex + number</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;c, T num) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(c.<span class="built_in">real</span>() + num, c.<span class="built_in">imag</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// number + Complex</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>+(T num, <span class="keyword">const</span> Complex &amp;c) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(c.<span class="built_in">real</span>() + num, c.<span class="built_in">imag</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Complex - Complex</span></span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>-(<span class="keyword">const</span> Complex &amp;x, <span class="keyword">const</span> Complex &amp;y) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(x.<span class="built_in">real</span>() - y.<span class="built_in">real</span>(), x.<span class="built_in">imag</span>() - y.<span class="built_in">imag</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Complex - number</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>-(<span class="keyword">const</span> Complex &amp;c, T num) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(c.<span class="built_in">real</span>() - num, c.<span class="built_in">imag</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// number - Complex</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>-(T num, <span class="keyword">const</span> Complex &amp;c) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(num - c.<span class="built_in">real</span>(), -c.<span class="built_in">imag</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -Complex</span></span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>-(<span class="keyword">const</span> Complex &amp;c) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(-c.<span class="built_in">real</span>(), -c.<span class="built_in">imag</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Complex * Complex</span></span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>*(<span class="keyword">const</span> Complex &amp;x, <span class="keyword">const</span> Complex &amp;y) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(x.<span class="built_in">real</span>() * y.<span class="built_in">real</span>() - x.<span class="built_in">imag</span>() * y.<span class="built_in">imag</span>(), x.<span class="built_in">real</span>() * y.<span class="built_in">imag</span>() + x.<span class="built_in">imag</span>() * y.<span class="built_in">real</span>());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Complex * number</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>*(<span class="keyword">const</span> Complex &amp;c, T num) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(c.<span class="built_in">real</span>() * num, c.<span class="built_in">imag</span>() * num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// number * Complex</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span>*(T num, <span class="keyword">const</span> Complex &amp;c) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(c.<span class="built_in">real</span>() * num, c.<span class="built_in">imag</span>() * num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt;(ostream&amp; os,<span class="keyword">const</span> Complex &amp; c) &#123;</span><br><span class="line">    <span class="keyword">if</span> (c.<span class="built_in">real</span>() &amp;&amp; c.<span class="built_in">imag</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c.<span class="built_in">imag</span>() &gt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> os &lt;&lt; c.<span class="built_in">real</span>() &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; c.<span class="built_in">imag</span>() &lt;&lt; <span class="string">&quot;i&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> os &lt;&lt; c.<span class="built_in">real</span>() &lt;&lt; c.<span class="built_in">imag</span>() &lt;&lt; <span class="string">&quot;i&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c.<span class="built_in">real</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> os &lt;&lt; c.<span class="built_in">real</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> os &lt;&lt; c.<span class="built_in">imag</span>() &lt;&lt; <span class="string">&quot;i&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ==</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Complex &amp;x, <span class="keyword">const</span> Complex &amp;y) &#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">return</span></span> (x.<span class="built_in">real</span>() == y.<span class="built_in">real</span>()) &amp;&amp; (x.<span class="built_in">imag</span>() == y.<span class="built_in">imag</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// !=</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Complex &amp;x, <span class="keyword">const</span> Complex &amp;y) &#123;</span><br><span class="line">    <span class="comment">// return !(x == y);   //不是相同则为不同</span></span><br><span class="line">    <span class="built_in"><span class="keyword">return</span></span> (x.<span class="built_in">real</span>() != y.<span class="built_in">real</span>()) || (x.<span class="built_in">imag</span>() != y.<span class="built_in">imag</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">x</span><span class="params">(<span class="number">3</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">y</span><span class="params">(<span class="number">3</span>, <span class="number">-4</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; x.<span class="built_in">length</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; x * y &lt;&lt; endl;</span><br><span class="line">    x += <span class="number">2</span>;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; -x &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; (x == y.<span class="built_in">conj</span>())&lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; (x.<span class="built_in">conj</span>() != y) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; x + y &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="number">1</span> + x &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; y + <span class="number">3</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="number">2</span> * x &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 候捷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/05/23/hello-world/"/>
      <url>/2022/05/23/hello-world/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>正如学编程语言时首个程序是<code>Hello World!</code>一样，本blog亦是如此。</p><p>该网站旨在分享一些生活的点滴及秋招的经历。最初是在微信公众号分享，奈何修改、发表过于繁琐。后来尝试过csdn，但一些不可描述的原因又将我劝退，最终决定自己搭建网站。</p><p>当然了，建站还有一个很重要的原因是——装逼。</p><span id="more"></span><h2 id="残局"><a href="#残局" class="headerlink" title="残局"></a>残局</h2><p>endgame,残局。</p><p>csgo可谓是电子竞技中最精彩的赛事之一，他的精彩就表现在残局众多。残局，是一场比赛中最精彩、最充满期待同时也是有着最多遗憾的时刻。精彩在会有一个力挽狂澜、扭转乾坤的人出现；遗憾在纵使他的某次发挥再流传千古，可终究改变不了逆局。而此时此刻，恰如彼时彼刻。</p><h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>钱都花了，也该有点相应的规划。预想着在本网站发布一些算法刷题的经历、八股、面经以及将来实习、工作的经历，还有一些日常生活中的点滴（许久没学习的时候，水个内容）。当然了，还有另外一种可能——几天之后，<strong style="color:#e67c86;">删库跑路</strong>。</p><p>另外，还建了个<a href="https://qm.qq.com/cgi-bin/qm/qr?k=s6ItnVGSSFQaS53il_Oc3490nQvfrs6S&jump_from=webapi">QQ群</a>来分享一些相关的书籍，有兴趣的话可以来逛逛。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>奈何，本人才疏学浅，能力有限再加上语言表达能力不是很好，文章中难免会有些地方表达欠缺难以理解，甚至与事实相悖。遇到这种情况时，还望您能轻点骂，骂完能帮忙指出错误，避免我这一己之见误导了他人。网站里，留下了我的<a href="mailto:lyong000919@163.com">邮箱</a>及<a href="tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=1992018857&website=www.oicqzone.com">QQ</a>，如果您在阅读时有疑问、发现了错误又或者觉得这个人写的还可以，想交个朋友，欢迎联系我。</p><p>最后，为给您带来的不良阅读体验致歉。(本人亲测在<code>DARK REDAER</code>插件下图片阅读感极差，代码块的兼容性也较差)</p><hr><h2 id="22-4-19更新"><a href="#22-4-19更新" class="headerlink" title="22/4/19更新"></a>22/4/19更新</h2><p>关于技术性的文章，我觉得已有心无力。因为网上有着太多太多的资源，有着太多太多的博主们他们理解的比我深、讲的也比我更通透。以后，本blog更偏向于分享一些照片、读书笔记、沙雕日常亦或是吐槽。当然了，如果有我学的比较透彻的知识点（大概率是没有了），也会分享给大家。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 关于我 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象</title>
      <link href="/2022/05/05/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/2022/05/05/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p>本文是我在学习候捷《面向对象高级开发》课程时所做的笔记，在此分享给大家。</p><span id="more"></span><h2 id="基于对象"><a href="#基于对象" class="headerlink" title="基于对象"></a>基于对象</h2><p>类从思考方式上大致分为两类</p><ul><li>不带指针。（complex）复数。内容在创建的时候已经是确定的（实部、虚部及相关的函数）</li><li>带指针。（string）字符串。只存了指针，当需要添加内容时，需要额外的创建空间。</li></ul><h3 id="设计重点"><a href="#设计重点" class="headerlink" title="设计重点"></a>设计重点</h3><ol><li>成员变量必须为private</li><li>参数尽可能的使用<mark>引用传递</mark>（const与否看情况）</li><li>尽可能的将<mark>返回值以引用形式</mark>传递</li><li>类本体里面注意应该加const的地方</li><li>尽量使用构造函数的初始化形式。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> _a,<span class="keyword">int</span> _b) : <span class="built_in">a</span>(_a),<span class="built_in">b</span>(_b) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基于对象-amp-amp-面向对象"><a href="#基于对象-amp-amp-面向对象" class="headerlink" title="基于对象 &amp;&amp; 面向对象"></a>基于对象 &amp;&amp; 面向对象</h3><p>Object-Based。设计<mark>单一</mark>的class。<br>Object-Oriented。面对多个class，涉及class与class的关系。</p><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p>防卫式声明（guard）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __xxxx__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __xxxx__</span></span><br><span class="line">.......</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>只有再第一次包含头文件时，才会导入库。</p><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p>在头文件里，大致分为三个部分。</p><ol><li>前置声明</li><li>类-声明</li><li>类-定义</li></ol><h3 id="私有构造函数"><a href="#私有构造函数" class="headerlink" title="私有构造函数"></a>私有构造函数</h3><p>当把构造函数设置在private区域时，表示该类不允许被创建对象。（设计模式-Singleton）</p><h3 id="function-const"><a href="#function-const" class="headerlink" title="function() const {}"></a>function() const {}</h3><p>设计不会改变数据内容的成员函数时（如：打印private成员变量），声明为const</p><h3 id="同一class的各个object互为friend"><a href="#同一class的各个object互为friend" class="headerlink" title="同一class的各个object互为friend"></a>同一class的各个object互为friend</h3><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>在实现运算符重载时，可以按照<code>(int)(30+10.5)</code>的形式，来强制转成类的临时对象。（该行运行结束即销毁）<code>Complex(5,4)</code></p><h3 id="拷贝构造"><a href="#拷贝构造" class="headerlink" title="拷贝构造"></a>拷贝构造</h3><p>类不写拷贝构造函数及拷贝赋值的话，会默认按bit进行拷贝。（带指针的类，需要自己去写）<br>如果没有写，只是复制了个指针（指针才是类内部的东西，字符数组是动态分配的）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用默认拷贝</span></span><br><span class="line">    <span class="function">String <span class="title">a</span><span class="params">(<span class="string">&quot;HELLO&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">b</span><span class="params">(<span class="string">&quot;WORLD&quot;</span>)</span></span>;</span><br><span class="line">    b = a;</span><br></pre></td></tr></table></figure><p>上述代码中，对象a的指针指向<code>HELLO</code>，对象b的指针指向<code>WORLD</code>，当执行b=a时，对象b拷贝对象a，两个对象的指针都指向原来对象a所指向的<code>HELLO</code>地址（浅拷贝），而<code>WORLD</code>所在地址已经造成内存泄漏。</p><h3 id="拷贝赋值"><a href="#拷贝赋值" class="headerlink" title="拷贝赋值"></a>拷贝赋值</h3><p>拷贝赋值时，要加上自我赋值检测（自我赋值delete-&gt;new时，delete删掉了相应的数据，无法new相同空间及拷贝内容）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span> == &amp;str)</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br></pre></td></tr></table></figure><h3 id="new-delete"><a href="#new-delete" class="headerlink" title="new/delete"></a>new/delete</h3><p>有<code>[]</code>的new要搭配有<code>[]</code>的delete使用。中括号表示的是数组(array)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * ptr = <span class="keyword">new</span> <span class="keyword">int</span>[];</span><br><span class="line"><span class="keyword">delete</span>[] ptr;</span><br></pre></td></tr></table></figure><p>有没有[]不影响这一个对象数组在内存中的删除，而是 有[]是表示删除整个数组，根据元素个数，调用多次分别释放各自动态分配的内存。而是数组中后面的指针所分配的内存没有被释放。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String* p = <span class="keyword">new</span> String[<span class="number">3</span>];</span><br><span class="line">......</span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure><p>上述代码中，有无[].3个String所占的内存都会被释放，而有[]会调用3次析构函数，即3个String对象中指针所指向的内存都会被释放，而delete只会调用一次析构函数，String[1],String[2]这两个对象中的指针所指向的内存并没有被释放。</p><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>静态变量要在类外进行定义（类内的static进行声明，不属于对象）。<br>多个对象的成员函数<mark>只有一份</mark><br>加在数据成员、成员函数前，表示为静态。所有对象<mark>共用</mark>一个<strong>静态</strong>成员。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt;c1.<span class="built_in">real</span>();</span><br><span class="line">cout &lt;&lt;c2.<span class="built_in">real</span>();</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">cout &lt;&lt;Complex::<span class="built_in">real</span>(&amp;c1);</span><br><span class="line">cout &lt;&lt;Complex::<span class="built_in">real</span>(&amp;c2);</span><br></pre></td></tr></table></figure><p>非静态的成员，以<code>this pointer</code>的形式去传，指针地址不同，调用不同的对象。<br>而静态的成员，属于类，是类负责存储。<mark>没有</mark><code>this pointer</code><br>e.g:银行系统，利率设置为静态。利息结算函数去处理静态的变量（利率）。<br>可以通过对象去调用静态变量，也可以通过类名直接调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> m_rate;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set_rate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; x)</span> </span>&#123;m_rate = x;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> Account::m_rate = <span class="number">5</span>; <span class="comment">//类外进行初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Account::<span class="built_in">set_rate</span>(<span class="number">3</span>); <span class="comment">//通过类名调用</span></span><br><span class="line">    Account a; a.<span class="built_in">set_rate</span>(<span class="number">6</span>); <span class="comment">//通过对象调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复合（Composition）"><a href="#复合（Composition）" class="headerlink" title="复合（Composition）"></a>复合（Composition）</h3><p>比如 队列、栈是基于双端队列来设计的。故队列、栈内部会包含双端队列这个类（内部存有其他数据结构）这个概念叫做复合。一些共用的功能，可以直接返回其底层容器的东西（empty()、size()函数），不需要的功能可以不开放，不引入进来（设计模式–Adapter）<br> Adapter是改装后的，不是被改装者。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">queue</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    deque&lt;T&gt; deq;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        deq.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="container-amp-component"><a href="#container-amp-component" class="headerlink" title="container &amp;component"></a>container &amp;component</h4><p>在上述过程中，container为队列（继承者），component为双端队列（被继承者）<br>Container构造时，先构造Component的构造函数，再构造自己的。析构时则相反。先调用自己的析构函数，再调用Component的析构函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Container::<span class="built_in">Container</span>(...):<span class="built_in">Component</span>()(......)</span><br><span class="line">Container::~<span class="built_in">Container</span>(...)&#123;......~<span class="built_in">Component</span>()&#125;</span><br><span class="line"><span class="comment">//上述代码中 六个点表示Container相应函数的实现</span></span><br></pre></td></tr></table></figure><h3 id="委托（Delegation）"><a href="#委托（Delegation）" class="headerlink" title="委托（Delegation）"></a>委托（Delegation）</h3><p>又叫 Composition by reference。<br>某个类的内部，成员变量中含有另一个类的对象的指针。（想用那个类的函数时，可以直接通过指针调用另一个类的函数，即将该功能委托给另一个类）。</p><p>Handle/Body<br>衍生设计模式：<br>    * 类的对外接口在该类内部实现，类的底层在被委托者里具体实现。</p><p>好处：对外接口不变，内部通过指针指向不同的实现类，从而改变底层。（底层变动不影响接口，从而不影响客户端。）即，底层改变时，编译时候只需要编译底层，不需要编译对外接口等。（节省时间）<br>而且可以多个不同的对外接口文件共用同一份底层代码。</p><h3 id="Composition-amp-Delegation"><a href="#Composition-amp-Delegation" class="headerlink" title="Composition &amp; Delegation"></a>Composition &amp; Delegation</h3><ul><li>生命周期不同<ul><li>Composition直接涵盖另一个类的源码，二者同生共死。</li><li>Delegation中另一个类对象的指针，只有调用时才创建。</li></ul></li></ul><h3 id="继承-amp-amp-虚函数"><a href="#继承-amp-amp-虚函数" class="headerlink" title="继承&amp;&amp;虚函数"></a>继承&amp;&amp;虚函数</h3><p>成员函数+virtual关键字。继承函数是继承的<mark>调用权</mark><br>设计模式（Template Method)。比如 各种软件打开文件功能，其打开步骤都是相似的（打开对话框、选择文件、检查文件是否存在、在磁盘里读取）这些基础动作基本相同，不同的是以什么形式读取。可以直接封装一个类实现这些基础功能，读取的具体实现，取决于软件继承这个类后去重写。这个东西也叫作Application framework。（应用框架），微软MFC是一个典型例子。</p><h3 id="继承-复合构造析构的顺序"><a href="#继承-复合构造析构的顺序" class="headerlink" title="继承+复合构造析构的顺序"></a>继承+复合构造析构的顺序</h3><p>派生类Component其余类对象时，派生类的构造/析构次序：<code>基类构造-&gt;复合类构造-&gt;自身构造</code>， <code>自身析构-&gt;复合类析构-&gt;基类析构。</code></p><h3 id="继承-委托"><a href="#继承-委托" class="headerlink" title="继承+委托"></a>继承+委托</h3><p>设计模式（Observer)某个文件内部包括多个查看操作的委托，该文件支持多个人同时查看。（内部可以增加注册、注销等功能以便于管理。）</p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="实现对象和非对象的运算"><a href="#实现对象和非对象的运算" class="headerlink" title="实现对象和非对象的运算"></a>实现对象和非对象的运算</h3><h4 id="conversion-function"><a href="#conversion-function" class="headerlink" title="conversion function"></a>conversion function</h4><p>类对象—&gt;非类的对象<br>转换函数conversion function。（比如分数类，实现分数和小数的转换）<br>以<code>operator</code>开头，函数名为返回值类型。不需要写返回值类型。也不需要参数。通常加上<code>const</code>(因为不需要改变内容)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Frac</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Frac</span>(<span class="keyword">double</span> _y, <span class="keyword">double</span> _x) : <span class="built_in">x</span>(_x), <span class="built_in">y</span>(_y)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>)y / x;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>至此，可以用一个数字去这个分数类进行运算。（无需重载运算符）</p><h4 id="non-explicit-one-argument-ctor"><a href="#non-explicit-one-argument-ctor" class="headerlink" title="non-explicit-one-argument ctor"></a>non-explicit-one-argument ctor</h4><p>非类的对象—&gt;类对象<br>non-explicit-one-argument ctor。要重载运算符。（整数默认分母是1，可以使得分母默认为1，只输入一个实参便可以）如果只写了分数间加法时，当调用分数+小数（整数）时，会调用相应的构造函数转换成分数再加。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Frac</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Frac</span>(<span class="keyword">double</span> _y, <span class="keyword">double</span> _x = <span class="number">1</span>) : <span class="built_in">x</span>(_x), <span class="built_in">y</span>(_y) &#123;&#125;</span><br><span class="line">    Frac <span class="keyword">operator</span>+(<span class="keyword">const</span> Frac &amp;f) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Frac</span>(...);</span><br><span class="line">        <span class="comment">//...为具体实现的方式</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>non-explicit-one-argument ctor与转换函数并存会产生二义性，报错。</li></ul><h4 id="explicit-one-argument-ctor"><a href="#explicit-one-argument-ctor" class="headerlink" title="explicit-one-argument ctor"></a>explicit-one-argument ctor</h4><p>explicit关键字放在<mark>构造函数前</mark>，告诉编译器，不会将非对象的参数转换为对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Frac</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Frac</span><span class="params">(<span class="keyword">double</span> _y, <span class="keyword">double</span> _x = <span class="number">1</span>)</span> : x(_x), y(_y) &#123;</span>&#125;</span><br><span class="line">    Frac <span class="keyword">operator</span>+(<span class="keyword">const</span> Frac &amp;f) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Frac</span>(...);</span><br><span class="line">        <span class="comment">//...为具体实现的方式</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//运行会报错。</span></span><br></pre></td></tr></table></figure><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>cpp的类大致分为两类，类的对象长得像指针的，长得像函数的。</p><h4 id="pointer-like-class"><a href="#pointer-like-class" class="headerlink" title="pointer-like class"></a>pointer-like class</h4><p>像指针的类。内部一定含有指针，实现一些比指针更高级的功能(智能指针)。作用在指针上的运算符(<code>*</code> 、 <code>-&gt;</code>等)要进行重载。<br>shared_ptr(智能指针)、 iterator(迭代器)</p><ul><li>shared_ptr。在不同类中，实现基本一致。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shared_ptr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T &amp;<span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> *px;</span><br><span class="line">    &#125;</span><br><span class="line">    T &amp;<span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> px;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">shared_ptr</span>(T *ptr) : <span class="built_in">px</span>(ptr)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *px;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">shared_ptr&lt;Foo&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> Foo)</span></span>;</span><br><span class="line"><span class="function">Foo <span class="title">f</span><span class="params">(*sp)</span></span>;</span><br><span class="line">sp-&gt;<span class="built_in">function</span>(); <span class="comment">// &lt;==&gt;  px-&gt;function();</span></span><br></pre></td></tr></table></figure><ul><li>iterator。根据功能不同会改动，且会重载其他运算符（如 自增、自减）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Ref</span>, <span class="keyword">class</span> <span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">list_iterator</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> __list_iterator&lt;T, Ref, Ptr&gt; self;</span><br><span class="line">    <span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">    <span class="keyword">typedef</span> Ref reference;</span><br><span class="line">    <span class="keyword">typedef</span> __list_node&lt;T&gt; *link_type;</span><br><span class="line">    link_type node;</span><br><span class="line">    ... </span><br><span class="line">    reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> (*node).data; &#125;</span><br><span class="line">    pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">list&lt;Foo&gt;::iterator iter;</span><br><span class="line">*iter; <span class="comment">//获取Foo对象</span></span><br><span class="line">iter-&gt;<span class="built_in">function</span>();    <span class="comment">//调用Foo::function();</span></span><br><span class="line"><span class="comment">// iter-&gt;function() &lt;==&gt; *(iter).function() &lt;==&gt; (&amp;(*iter))-&gt;function()</span></span><br></pre></td></tr></table></figure><h4 id="function-like-class"><a href="#function-like-class" class="headerlink" title="function-like class"></a>function-like class</h4><p>像函数的类。仿函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">identity</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> T &amp;<span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T &amp;x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">select1st</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">typename</span> Pair::first_type &amp;<span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Pair &amp;x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x.first; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">select2nd</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">typename</span> Pair::second_type &amp;<span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Pair &amp;x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x.second; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h3><p>命名空间。用于分隔开不同开发团队的成果（防止名字冲突，具有二义性）</p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><h4 id="class-template"><a href="#class-template" class="headerlink" title="class template"></a>class template</h4><p>类模板。参考复数类。成员变量类型、成员函数的返回值类型可以用模板替换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="keyword">double</span> x, <span class="keyword">double</span> y) : <span class="built_in">re</span>(x), <span class="built_in">im</span>(y)&#123;&#125;</span><br><span class="line">    <span class="built_in">Complex</span>() : <span class="built_in">re</span>(<span class="number">0</span>), <span class="built_in">im</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="function">T <span class="title">real</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> re; &#125;</span><br><span class="line">    <span class="function">T <span class="title">imag</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> im; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T re, im;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Complex&lt;<span class="keyword">int</span>&gt; <span class="title">c</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="function-template"><a href="#function-template" class="headerlink" title="function template"></a>function template</h4><p>函数模板。有一些函数，所实现的功能很通用。可以直接封装成函数模板。（一些其他类重载运算符）编译器会根据传入值自动推导相应的类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">const</span> T&amp; <span class="title">min</span> <span class="params">(cosntT&amp; a,constT&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? b : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="member-function"><a href="#member-function" class="headerlink" title="member function"></a>member function</h4><p>成员模板。模板里面嵌套模板。常用于标准库中，用某一个数据类型的变量来初始化另一个数据类型的变量。<br>比如，现在封装了一个鱼类，以及一个鲫鱼类。<br>我们声明了一个鲫鱼对象，用他去初始化一个鱼类对象。（构造函数更有弹性）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pair</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T1 first_type;</span><br><span class="line">    <span class="keyword">typedef</span> T2 second_type;</span><br><span class="line">    T1 first;</span><br><span class="line">    T2 second;</span><br><span class="line">    <span class="built_in">pair</span>() : <span class="built_in">first</span>(<span class="built_in">T1</span>()), <span class="built_in">second</span>(<span class="built_in">T2</span>())&#123;&#125;</span><br><span class="line">    <span class="built_in">pair</span>(<span class="keyword">const</span> T1 &amp;a, <span class="keyword">const</span> T2 &amp;b) : <span class="built_in">first</span>(a), <span class="built_in">second</span>(b)&#123;&#125;</span><br><span class="line">    <span class="function">temppalte&lt;class U1, classU2&gt;</span></span><br><span class="line"><span class="function">    <span class="title">pair</span><span class="params">(<span class="keyword">const</span> pair&lt;U1, U2&gt; &amp;p)</span> : first(p.first), second(p.second)&#123;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="模板特化"><a href="#模板特化" class="headerlink" title="模板特化"></a>模板特化</h3><p>specialization。通过模板实现了泛化，而其中一些东西可能并不太适用，会有些不同，需要特殊处理（特化）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过模板泛化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&#123;</span>&#125;;</span><br><span class="line"><span class="comment">//当输入类型为指定类型时，进行特化处理</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;</span><span class="keyword">char</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">char</span> x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;</span><span class="keyword">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span> * x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="偏特化"><a href="#偏特化" class="headerlink" title="偏特化"></a>偏特化</h3><p>局部特化，可以从个数、范围上产生差异。</p><ul><li>个数。比如模板的参数有2个，可以绑定部分参数。（bool类型用特定的底层做容器容易浪费，偏特化处理）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> Alloc=...&gt;</span><br><span class="line">class vector</span><br><span class="line">&#123;</span><br><span class="line">    ...<span class="comment">//具体实现略</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Alloc=...&gt;</span><br><span class="line">class vector&lt;<span class="keyword">bool</span>,Alloc&gt;</span><br><span class="line">&#123;</span><br><span class="line">    ...<span class="comment">//具体实现略</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>范围。模板支持任意类型，偏特化为 任意指针类型。（其余类型使用泛化模板，指针使用偏特化）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...<span class="comment">//具体实现略</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>&lt;</span>T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">    ...<span class="comment">//具体实现略</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="模板模板参数"><a href="#模板模板参数" class="headerlink" title="模板模板参数"></a>模板模板参数</h3><p>模板的一个参数也为模板。用来初始化时，容器实现底层所采用的数据类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Container</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="variadic-templates"><a href="#variadic-templates" class="headerlink" title="variadic templates"></a>variadic templates</h3><p>模板参数可变化。允许写任意个数的模板参数(用<code>...</code>来省略)(每次都分为<code>1 + n</code>进行运行)通过<code>sizeof...()</code>函数获取<code>n</code>值。</p><p>以下代码调用时，可以一直递归为<code>1 + n</code>直至运行<code>1 + 0</code>全部运行完，程序结束。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//最后的0个参数时调用的函数，用来退出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Types&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> T&amp; firstArg,<span class="keyword">const</span> Types&amp;...args)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; firstArg &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">print</span>(args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><p>自动推导相应的数据类型。比如容器的迭代器，写起来过长可以直接<code>auto</code>让编译器<mark>根据返回值类型</mark>自动推导相应的类型。再比如lambda表达式返回值比较复杂，可以auto推导。</p><h3 id="for-decl-coll"><a href="#for-decl-coll" class="headerlink" title="for(decl:coll)"></a>for(decl:coll)</h3><p>另一种遍历的形式。每次从右边的容器中取出值赋给左边的变量。默认为值传递，不会改变原来值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;::iterator iter = vec.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">auto</span> iter = vec.<span class="built_in">begin</span>();</span><br></pre></td></tr></table></figure><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用，给变量取一个别名，取出后可以去修改。<br>变量和其引用大小相同，地址相同。<br>指针可以重新指向其他元素，而引用一旦确定不能变。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;x;</span><br><span class="line"><span class="keyword">int</span> &amp;r = x;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">5</span>;</span><br><span class="line">p = y;    <span class="comment">//指针p指向了y 再赋值改变的是y值，不会影响x。</span></span><br><span class="line">r = y;    <span class="comment">//用y的值给r赋值 r = 5 x  = 5;</span></span><br></pre></td></tr></table></figure><p>指针传递、值传递、引用传递中，指针和引用可以改原始值，三者调用对象的方式有些差异。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(Cls *pobj)</span> </span>&#123; pobj-&gt;<span class="built_in">function</span>(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(Cls obj)</span> </span>&#123; obj.<span class="built_in">function</span>(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">(Cls &amp;obj)</span> </span>&#123; obj.<span class="built_in">function</span>(); &#125;</span><br></pre></td></tr></table></figure><p>同名同类型一个值传递、一个引用传递的函数不能重载。（二义性）但一个<code>const</code>一个非const可以并存。</p><h3 id="虚指针-amp-虚表"><a href="#虚指针-amp-虚表" class="headerlink" title="虚指针&amp;虚表"></a>虚指针&amp;虚表</h3><p>vptr &amp; vtbl。只要有虚函数，类内部就会有出现<mark>一个</mark>指针。虚指针用来指向虚表中的<mark>函数指针</mark>指向虚函数的地址。未重写的虚函数，基类和派生类共用。重写了的，各自虚表中指向重写后的地址。<br>下列代码中存在一些问题，可以不必纠结。（为了方便理解）。<br>通过指针，向上转型，指向虚函数。<code>(*p-&gt;vptr[n])(p)</code><br><img src="/2022/05/05/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20220611144047216.png" alt="vptr+vtbl"></p><h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p>通过对象调用函数时，对象的地址传<code>this</code>指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">&#125;;</span><br><span class="line">B b;</span><br><span class="line">A::<span class="built_in">func</span>(&amp;b); </span><br><span class="line">b.<span class="built_in">func</span>(); <span class="comment">//等价 </span></span><br><span class="line"><span class="comment">//this指针为&amp;b</span></span><br></pre></td></tr></table></figure><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>非const对象可以调用所有的成员函数，const对象只能调用const成员函数。当成语函数const和非cosnt同时存在时，const对象只能调用const函数，非const对象只能调用非const函数。</p><h3 id="operator-new-delete"><a href="#operator-new-delete" class="headerlink" title="operator new/delete"></a>operator new/delete</h3><p>是运算符，可以重载。（全局，类内部 都可以）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span> size);</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* ptr)</span></span>;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> *<span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span>* ptr);</span><br></pre></td></tr></table></figure><h3 id="重载new-delete"><a href="#重载new-delete" class="headerlink" title="重载new/delete"></a>重载new/delete</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> _id;</span><br><span class="line">    <span class="keyword">long</span> _data;</span><br><span class="line">    string _str;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>() : _id(<span class="number">0</span>) &#123; cout &lt;&lt; <span class="string">&quot;default ctor.this&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;id=&quot;</span> &lt;&lt; _id &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="keyword">int</span> i):_id(i) &#123; cout &lt;&lt; <span class="string">&quot;ctor.this&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;id=&quot;</span> &lt;&lt; _id &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">Foo</span>() &#123; cout &lt;&lt; <span class="string">&quot;dtor.this&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;id=&quot;</span> &lt;&lt; _id &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span> size);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* Foo::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    Foo *p = (Foo *)<span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> Foo::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span>* Foo::<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span> size) &#123;</span><br><span class="line">    Foo *p = (Foo *)<span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Foo::<span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size) &#123;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 优先从类成员函数调用，如果没有就用全局。</span></span><br><span class="line">Foo *pf = <span class="keyword">new</span> Foo;</span><br><span class="line"><span class="keyword">delete</span> pf;</span><br><span class="line"><span class="comment">//默认使用全局函数</span></span><br><span class="line">Foo *pf = ::<span class="keyword">new</span> Foo;</span><br><span class="line">::<span class="keyword">delete</span> pf;</span><br></pre></td></tr></table></figure><h3 id="重载new-delete-1"><a href="#重载new-delete-1" class="headerlink" title="重载new(),delete()"></a>重载new(),delete()</h3><p>new()可以重载出多个版本，但第一参数必须为<code>size_t</code>。同时也可以重载对应的delete()，但其不会被调用。只有在new()抛出异常才会调用delete()</p><h3 id="new-amp-amp-delete"><a href="#new-amp-amp-delete" class="headerlink" title="new &amp;&amp; delete"></a>new &amp;&amp; delete</h3><p>二者对于基本数据类型的操作基本没有差异，而当为类的对象分配空间时，会有一些区别。<br>以下是候捷老师课程中关于malloc/new区别的代码以更好的区分二者。<br><img src="/2022/05/05/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/malloc+new.png" alt="malloc+new"><br>假设我们现在已经有一个复数类，当我们用new进行分配时，首先自动获取对象所占空间，执行<code>operator new</code>，在其内部调用malloc分配相应的大小。然后调用<code>static_cast</code>显式的进行强制类型转换。最终再执行类的构造函数。<br>从图中，我们可以看出二者的一些区别：</p><ol><li>new无需强制类型转换和指定分配的大小，而malloc需要。</li><li>new为一个对象开辟空间时，会调用构造函数，而malloc不会。(故，malloc为对象申请空间时，一些在构造函数里的初始化操作无法执行。)</li></ol><h3 id="free-amp-amp-delete"><a href="#free-amp-amp-delete" class="headerlink" title="free &amp;&amp; delete"></a>free &amp;&amp; delete</h3><p>下面是关于free/delete的区别<br><img src="/2022/05/05/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/free+delete.png" alt="free+delete"><br>可以看出，当我们对一个对象执行<code>delete</code>操作时，首先要调用析构函数再通过<code>operator delete</code>执行<code>free</code>操作。<br>由此，我们可以知道</p><ul><li>free使用不当会造成内存泄漏。</li></ul><p>如果该类是不带指针的类（比如复数类，成员变量只有实部和虚部），不调用类的析构函数也没有任何问题，也会正常的释放掉为对象所分配的内存空间。而如果这个类<mark>带有指针</mark>（比如 string），free时虽然会释放掉对象所占的空间，但由于<code>string</code>存储的只是个指针，我们对字符串进行修改时，对象内部会为指针分配相应的空间来存储内容。我们执行free时，内存中为其具体内容分配的空间没有得到释放。（指针消亡，但指向的内存空间并没有被释放）。</p><h3 id="delete-amp-amp-delete"><a href="#delete-amp-amp-delete" class="headerlink" title="delete &amp;&amp; delete[]"></a>delete &amp;&amp; delete[]</h3><p>当我们为一个数组new相应的空间时，使用<code>delete</code>释放也会造成内存泄漏。<br><img src="/2022/05/05/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/delete.png" alt="delete"><br>从图中可以看出，使用delete释放为数组开辟的空间时，我们会释放掉所分配的空间，同样的也会调用析构函数。这对于不带指针的类来说可能没有太大的区别，当我们的类带指针时，由于只能够调用一次析构函数。数组<code>array</code>中，只有<code>array[0]</code>所指向的内存空间被释放掉了，其余的几个指针指向的空间并没有被释放。<br>由此可以知道，当我们为数组new一片内存时（<code>new xxx[]</code>)，也要使用相应的<code>delete[] xxx</code>。</p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h3><p>通过<strong>复合</strong>。某个类内部含有另一个类的对象，一些可复用的功能直接通过对象去调用。<br>实例：栈、队列从双端队列改写代码。已实现的功能直接调用，其余自己再写。</p><h3 id="Handle-Body"><a href="#Handle-Body" class="headerlink" title="Handle/Body"></a>Handle/Body</h3><p>通过<strong>委托</strong>。某个类内部含有另一个类 对象的指针。这个类可以用来提供对外借口，而底层具体实现在指针指向的对象内实现。（接口改变、底层改变可以只编译一部分）</p><h3 id="Template-Method"><a href="#Template-Method" class="headerlink" title="Template Method"></a>Template Method</h3><p>通过<strong>继承</strong>。有些东西在每个软件中所展示出的操作没有太大区别，我们可以将其相似的功能进行编写，细微差异部分以虚函数的形式留给所继承到具体的类中去实现。<br>实例：打开文件操作。各个软件打开文件的次序基本一致：选择文件，检查文件是否存在，在磁盘中进行读取，xxx，关闭文件。我们可以将其余功能都封装好，对外提供一个具体读取方式的接口。</p><h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><p>通过<strong>继承+委托</strong>。文件类内部包括多个查看操作的委托，具体到某个文件时，支持多个人同时查看。（文件内部可以增加注册、注销等功能以便于管理。）</p><h3 id="Composite"><a href="#Composite" class="headerlink" title="Composite"></a>Composite</h3><p>通过<strong>继承+委托</strong>。当某个类内部可以包含多种不同内容时（自身+其余的类），我们可以将自身及 要包含的类继承自同一个父类。然后该类的内部包含基类的委托。<br>e.g. 类A内部要可以包含A的指针也可以包含B的指针。我们可以将A B都继承自父类C（功能多少不重要，重要的是A中可以包含B的委托），A中包含父类的委托。</p><h3 id="Prototype"><a href="#Prototype" class="headerlink" title="Prototype"></a>Prototype</h3><p>通过<strong>继承+委托</strong>。父类可以创建未来将要出现的子类。（父类是发行商自己写的，子类是客户买回去自己写的相应的类）。<br>派生类构造函数设置为私有，构造函数内部实现将自身的指针返回给基类，保存在基类的容器中。派生类中含有一个clone()函数，以让基类调用，生成一个副本提供给父类。还需要另外一个的构造函数（以便clone函数构造自己时调用，防止再次调用上次的私有构造 陷入死循环）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 候捷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022/04月度总结</title>
      <link href="/2022/04/30/2022-04%E6%9C%88%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
      <url>/2022/04/30/2022-04%E6%9C%88%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>不知不觉，马上就来到了五月。大学的课程也只剩下一两门。在大学时光结束之前，记录一下生活。可以将这东西理解为日记(流水账)，但俺懒到一个月才写一次。</p><span id="more"></span><p>这一个月是疯狂投简历的一个月。一共投了将近20份简历吧，只面试了一次。本来觉得我算法还可以，背了几天面经。然后笔试了几次发现，算法垃圾的一批，又再天天刷题。再加上这学期很多门课都是有实验的，有些实验异常浪费时间，实际的学习的时间很少、效率很低。而且还少交了一些作业，直接摆烂了一些作业（指，写一半不想写了直接交）<br><img src="/2022/04/30/2022-04%E6%9C%88%E5%BA%A6%E6%80%BB%E7%BB%93/leetcode.png" alt="力扣刷题"><br>最大的感受是，很多题基本上在看到题的一瞬间就注定结果了。会就是会，不会憋半天也没任何想法（卡样例的想法除外）。<br>一个月来相关的笔试如下（感谢华为的面试让我觉得自己又行了）：<br><img src="/2022/04/30/2022-04%E6%9C%88%E5%BA%A6%E6%80%BB%E7%BB%93/%E6%97%A5%E5%8E%86.jpg" alt="笔试安排"><br>实在学不下去了的时候，看了几本书:《动物凶猛》、《过把瘾就死》、《限时医院》、《潮骚》。影视剧已经被搁置了一段时间。（太令我沉迷）。</p><p>这个月，最<mark>烦心</mark>的是阿里的笔试。周五晚上的笔试，三个编程题，后两个只有一个样例没过，可以说是我发挥最好的一场笔试，结果周一上午直接给我挂了。当然了，最<mark>意外的收获</mark>也就是华为的面试。虽然笔试600分我只有90,但还是给了我面试资格。面试体验感也极好。<br>送给大家最近听到的比较喜欢的一句话（华为面试时，反问面试官职业规划的建议时他说的）</p><blockquote><p>人生中存在着很多的变数。怎么说呢，把握机遇吧。</p></blockquote><p>虽然这句话听起来很俗。但在听完他的故事以及看到他沧桑的面孔后，能说出这句话，又透露着多少的遗憾。<br>最后分享一组最近拍摄的照片的原图。<br><img src="/2022/04/30/2022-04%E6%9C%88%E5%BA%A6%E6%80%BB%E7%BB%93/IMG_20220406_182704.jpg" alt="p1"><br><img src="/2022/04/30/2022-04%E6%9C%88%E5%BA%A6%E6%80%BB%E7%BB%93/IMG_20220424_145256.jpg" alt="p2"><br><img src="/2022/04/30/2022-04%E6%9C%88%E5%BA%A6%E6%80%BB%E7%BB%93/IMG_20220409_124116.jpg" alt="p3"><br><img src="/2022/04/30/2022-04%E6%9C%88%E5%BA%A6%E6%80%BB%E7%BB%93/IMG_20220427_144040.jpg" alt="p4"><br><img src="/2022/04/30/2022-04%E6%9C%88%E5%BA%A6%E6%80%BB%E7%BB%93/IMG_20220427_144056.jpg" alt="p5"><br><img src="/2022/04/30/2022-04%E6%9C%88%E5%BA%A6%E6%80%BB%E7%BB%93/IMG_20220413_165828.jpg" alt="p6"><br><img src="/2022/04/30/2022-04%E6%9C%88%E5%BA%A6%E6%80%BB%E7%BB%93/IMG_20220412_174942.jpg" alt="p7"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实习笔面试</title>
      <link href="/2022/04/14/%E5%AE%9E%E4%B9%A0%E7%AC%94%E9%9D%A2%E8%AF%95/"/>
      <url>/2022/04/14/%E5%AE%9E%E4%B9%A0%E7%AC%94%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>本文用于记录本人投23实习岗的一些题目。<br>截止至5/15（学校所给出的最终时间），0offer结束实习招聘。（还有一些还未凉，后续流程就当积累经验了）</p><span id="more"></span><h2 id="字节飞书后端-已凉"><a href="#字节飞书后端-已凉" class="headerlink" title="字节飞书后端(已凉)"></a>字节飞书后端(已凉)</h2><h3 id="笔试-22-4-10"><a href="#笔试-22-4-10" class="headerlink" title="笔试(22/4/10)"></a>笔试(22/4/10)</h3><p>$2h = 4 \times 编程题$</p><h4 id="涨潮（20）"><a href="#涨潮（20）" class="headerlink" title="涨潮（20）"></a>涨潮（20）</h4><p>一个矩阵0/1表示陆地/海洋。涨潮时，上下左右四方向和两个海洋相邻的陆地变为海洋。矩阵外默认全是陆地。求涨潮后的矩阵。</p><h4 id="跳格子（20）"><a href="#跳格子（20）" class="headerlink" title="跳格子（20）"></a>跳格子（20）</h4><p><a href="https://leetcode-cn.com/problems/jump-game/">力扣第55题跳跃游戏</a></p><h4 id="装网球（30）"><a href="#装网球（30）" class="headerlink" title="装网球（30）"></a>装网球（30）</h4><p>K个网球，标号为$1\to K$，N个球筒。从1开始依次将网球装入。给定N行输入表示网球在相应桶中的顺序，问顺序是否合法。</p><h4 id="凑卡组（30）"><a href="#凑卡组（30）" class="headerlink" title="凑卡组（30）"></a>凑卡组（30）</h4><p>m个卡组，每组3张牌。牌号$0\to 9$，至少要多少组牌，使得凑齐$\left[0,9\right]$。</p><h2 id="百度后端"><a href="#百度后端" class="headerlink" title="百度后端"></a>百度后端</h2><h3 id="笔试-22-4-12"><a href="#笔试-22-4-12" class="headerlink" title="笔试(22/4/12)"></a>笔试(22/4/12)</h3><p>$2h = 3 \times 编程题 + 20\times选择$</p><h4 id="选择（3-20）"><a href="#选择（3-20）" class="headerlink" title="选择（3*20）"></a>选择（3*20）</h4><h5 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h5><ul><li>KMP给定两个串,需要多少次匹配</li><li>哈弗曼编码是否合法</li><li>中后序遍历构造二叉树</li><li>二分查找(哪个不是经历两次后的)</li></ul><h5 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h5><ul><li>重写</li><li>shell中{0..100..6}含义（$\left [0, 100\right]$中6的倍数）</li><li>std::funcional代替函数指针（写程序运行结果）</li><li><mark>函数</mark>传入三个变量a,b,c。指针初始指向b，<code>cout &lt;&lt; *(ptr-1)</code>的运行结果。</li><li>二维数组给定某个元素地址，问一个元素地址。</li></ul><h4 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h4><h5 id="坐标（10）"><a href="#坐标（10）" class="headerlink" title="坐标（10）"></a>坐标（10）</h5><p>初始在坐标轴原点 输入一个只包含UDLR（分别表示上、下、左、右移动）的字符串。问最终位置。</p><h5 id="迷宫（15）"><a href="#迷宫（15）" class="headerlink" title="迷宫（15）"></a>迷宫（15）</h5><p>输入一个包含”FS#.”（初始位置、最终位置、墙、路)的二维数组。其中有k个墙是特殊的，需要碰到（四方向相邻）后才能离开。问最少走多少步可以从F到达S。</p><h5 id="对应位置差值和最大（15）"><a href="#对应位置差值和最大（15）" class="headerlink" title="对应位置差值和最大（15）"></a>对应位置差值和最大（15）</h5><p>给定两个数组a和b，每次能够交换a中相邻两个元素$swap\left( a_i, a_{i+1}\right)$至少交换多少次使得 $\sum_{i = 0}^{size -1}\left | a_i-b_i \right |$最大。</p><h2 id="阿里CTO线后端-已凉"><a href="#阿里CTO线后端-已凉" class="headerlink" title="阿里CTO线后端(已凉)"></a>阿里CTO线后端(已凉)</h2><h3 id="笔试-22-4-15"><a href="#笔试-22-4-15" class="headerlink" title="笔试(22/4/15)"></a>笔试(22/4/15)</h3><p>$1.5h = 6 \times 单选 + 6 \times 不定项 + 3\times 编程题$</p><h4 id="单选（6-1）"><a href="#单选（6-1）" class="headerlink" title="单选（6*1）"></a>单选（6*1）</h4><ul><li>shell多行输出</li><li>数据库 输出<strong>在Table1且不在Table2的元素</strong>。</li><li>给定一组数，存入哈希表。问碰撞次数</li><li>给定数组，插入排序6次结果</li></ul><h4 id="不定项（6-2，不全给2-3分）"><a href="#不定项（6-2，不全给2-3分）" class="headerlink" title="不定项（6*2，不全给2/3分）"></a>不定项（6*2，不全给2/3分）</h4><ul><li>ip子网划分</li><li>二叉树（先序、中序、兄弟节点）</li><li>三次握手目的</li></ul><ul><li>共n个元素（偶数个）入栈，第一次弹 $\frac{n}{2}$，第二次弹$n - 1$。第三次可能弹？</li></ul><h4 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h4><p>允许使用本地编译器。（故，有代码）</p><h5 id="手机键盘输入（24）"><a href="#手机键盘输入（24）" class="headerlink" title="手机键盘输入（24）"></a>手机键盘输入（24）</h5><p>手机九键，输入一个按键字符串。<mark>按到1</mark>或者<mark>其他按键</mark>输出本格的内容。（故，最后一个元素不是1不输出）</p><p>1.0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;string&gt; temp = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;ABC&quot;</span>, <span class="string">&quot;DEF&quot;</span>, <span class="string">&quot;GHI&quot;</span>, <span class="string">&quot;JKL&quot;</span>, <span class="string">&quot;MNO&quot;</span>, <span class="string">&quot;PQRS&quot;</span>, <span class="string">&quot;TUV&quot;</span>, <span class="string">&quot;WXYZ&quot;</span>&#125;;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    string str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="comment">// 按键与数组 差一</span></span><br><span class="line">        <span class="keyword">int</span> index = (str[i] - <span class="string">&#x27;0&#x27;</span> - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(!index)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; str.<span class="built_in">size</span>() &amp;&amp; str[i] == str[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            ++num;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> x = temp[index].<span class="built_in">size</span>();</span><br><span class="line">        res += temp[index][num % x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(str[str.<span class="built_in">size</span>() - <span class="number">1</span>] != <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        res.<span class="built_in">pop_back</span>();</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="四子棋（28）"><a href="#四子棋（28）" class="headerlink" title="四子棋（28）"></a>四子棋（28）</h5><p>输入m行n列字符串。包括<code>r p .</code>（A的、B的、空）。横、竖、斜连成4个，该玩家胜利。问谁赢（A胜、B胜、继续玩）。</p><p>暴力8/9</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;string&gt; str;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        string temp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        cin &gt;&gt; temp;</span><br><span class="line">        str.<span class="built_in">push_back</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m;++j) &#123;</span><br><span class="line">            <span class="comment">// 同行</span></span><br><span class="line">            <span class="keyword">if</span>(j + <span class="number">3</span> &lt; m) &#123;</span><br><span class="line">                <span class="keyword">if</span> (str[i][j] == str[i][j + <span class="number">1</span>] &amp;&amp; str[i][j + <span class="number">1</span>] == str[i][j + <span class="number">2</span>] &amp;&amp; str[i][j + <span class="number">2</span>] == str[i][j + <span class="number">3</span>]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (str[i][j] == <span class="string">&#x27;r&#x27;</span>) &#123;</span><br><span class="line">                        cout &lt;&lt; <span class="string">&quot;kou&quot;</span>;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                        cout &lt;&lt; <span class="string">&quot;yukari&quot;</span>;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 同列</span></span><br><span class="line">            <span class="keyword">if</span>(i + <span class="number">3</span> &lt; n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (str[i][j] == str[i + <span class="number">1</span>][j] &amp;&amp; str[i + <span class="number">1</span>][j] == str[i + <span class="number">2</span>][j] &amp;&amp; str[i + <span class="number">2</span>][j] == str[i + <span class="number">3</span>][j]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (str[i][j] == <span class="string">&#x27;r&#x27;</span>) &#123;</span><br><span class="line">                        cout &lt;&lt; <span class="string">&quot;kou&quot;</span>;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                        cout &lt;&lt; <span class="string">&quot;yukari&quot;</span>;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对角线</span></span><br><span class="line">            <span class="keyword">if</span>(i + <span class="number">3</span> &lt; n &amp;&amp; j + <span class="number">3</span> &lt; m)&#123;</span><br><span class="line">                <span class="keyword">if</span> (str[i][j] == str[i + <span class="number">1</span>][j + <span class="number">1</span>] &amp;&amp; str[i + <span class="number">1</span>][j + <span class="number">1</span>] == str[i + <span class="number">2</span>][j + <span class="number">2</span>] &amp;&amp; str[i + <span class="number">2</span>][j + <span class="number">2</span>] == str[i + <span class="number">3</span>][j + <span class="number">3</span>]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (str[i][j] == <span class="string">&#x27;r&#x27;</span>) &#123;</span><br><span class="line">                        cout &lt;&lt; <span class="string">&quot;kou&quot;</span>;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                        cout &lt;&lt; <span class="string">&quot;yukari&quot;</span>;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;to be continued&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="二叉树最小权值差（30）"><a href="#二叉树最小权值差（30）" class="headerlink" title="二叉树最小权值差（30）"></a>二叉树最小权值差（30）</h5><p>给出含有n个节点，（n-1）个指向（数对）的二叉树的权值。每个节点的权值为其子树权值和。<br>求不是父子节点的最小权值差。<br>输入</p><ol><li>n（节点数）</li><li>$value_i\quad$(n个节点权值)</li><li>(n - 1)个数对（前者是后者的父节点）</li></ol><p>9/10</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 0.9</span></span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="comment">// n个节点</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">arr</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">father</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// n-1条边</span></span><br><span class="line">    vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; <span class="built_in">temp</span>(n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; temp[i].first;</span><br><span class="line">        cin &gt;&gt; temp[i].second;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="comment">// 加权得出相应的值</span></span><br><span class="line">        arr[temp[i].first - <span class="number">1</span>] += arr[temp[i].second - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 父节点</span></span><br><span class="line">        father[temp[i].second - <span class="number">1</span>] = temp[i].first - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (father[j] != i)</span><br><span class="line">            &#123;</span><br><span class="line">                res = <span class="built_in">min</span>(res, <span class="built_in">abs</span>(arr[j] - arr[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="360服务端"><a href="#360服务端" class="headerlink" title="360服务端"></a>360服务端</h2><h3 id="笔试（22-4-16）"><a href="#笔试（22-4-16）" class="headerlink" title="笔试（22/4/16）"></a>笔试（22/4/16）</h3><p>$2h = 40\times选择 +2\times 编程$</p><h4 id="选择（40-1-5）"><a href="#选择（40-1-5）" class="headerlink" title="选择（40* 1.5）"></a>选择（40* 1.5）</h4><p>很杂，计网、数据库、操作系统、cpp（语法、运行结果）、java等啥都有。。。</p><ul><li>String 赋值、new  值相等 or 完全相同？</li><li>判断代码长度（char数组尾部插0，问角标）</li><li>给定递归表达式，问某一个要执行多少次</li><li>100条边将平面划分多少个区域</li><li>S锁的权限</li><li>linux文件夹复制</li><li>int * const || const int* || int const *</li><li>只有头节点的树（度？深度？前or中序相同？ 中or后续相同？）</li><li>cpp new的元素 初始值是 ？</li><li>cpp友元函数能否改对象的值？</li><li>堵车问题+交警 打破死锁的什么条件</li><li>html/web 传输层协议</li><li>数据库 游标</li><li>linux 下Apache服务器用的虚拟机地址，调用协议？？？（邮件收发、DNS、talnet）</li><li>凑硬币（1、2、5、10、20、50、100纸币各xx张，凑687元）</li><li>UML 椭圆柱表示？</li></ul><h4 id="编程-1"><a href="#编程-1" class="headerlink" title="编程"></a>编程</h4><h5 id="最大流（20）"><a href="#最大流（20）" class="headerlink" title="最大流（20）"></a>最大流（20）</h5><p>一个长度为n的数组，表示n个相邻格子的高低。从波峰浇水可以流到比他低的格子里。问一次浇水最多流几个格子。<br>（样例 5 1 2 1 5.从2浇水流中间3个）。<br>暴力 0.85<br>三次遍历</p><ol><li>第一次从左到右算左侧流几个。（left[i] = (left[i] &gt; left[i- 1] ? left[i - 1] + 1: 0); ）</li><li>第二次从右到左算右侧流几个。（right[i] = (right[i] &gt; right[i + 1] ? right[i + 1 ] + 1: 0);） </li><li>求最值（res = max(res,left[i] + right[i] + [1])<mark>左、右、本身</mark>。</li></ol><h5 id="最大体积差（20）"><a href="#最大体积差（20）" class="headerlink" title="最大体积差（20）"></a>最大体积差（20）</h5><p>给定一个长方体的体积V。边长假定为a、b、c，求(a+2)(b+2)(c+1) - V的最大值。</p><h2 id="京东后端"><a href="#京东后端" class="headerlink" title="京东后端"></a>京东后端</h2><h3 id="笔试（22-4-16）-1"><a href="#笔试（22-4-16）-1" class="headerlink" title="笔试（22/4/16）"></a>笔试（22/4/16）</h3><p>$2h = 30 \times 选择 + 2\times 编程题$</p><h4 id="选择（30-2）"><a href="#选择（30-2）" class="headerlink" title="选择（30*2）"></a>选择（30*2）</h4><ul><li>结构体中一个变量为<code>char data[0]</code> 运行时？</li><li>图的邻接矩阵 BFS</li><li>linux文件权限<code>rw-r--r--</code>数字表示</li><li>delete 和delete[]区别</li><li>函数重载定义（给出定义了问这叫什么）</li><li>类成员变量通常以什么开头</li><li>const char *</li><li>ip类型区分（哪个和其他不一样）<ul><li>101.16.1.1</li><li>10.16.1.1</li><li>172.16.1.1</li><li>192.168.1.1</li></ul></li><li>linux path加路径 语句</li><li>结构体 union</li><li>shell获取某变量长度 怎么写</li><li>深拷贝or浅拷贝定义</li><li>域解析符是？</li><li>linux shell中 ctrl + c 用语句表示</li><li>堆栈、文件系统and so on 用到串的有？</li><li>以下哪个变量名在cpp合法</li><li>判断两个字符串是否相等，函数名</li></ul><h4 id="编程题-1"><a href="#编程题-1" class="headerlink" title="编程题"></a>编程题</h4><h5 id="语言是否合法（20）"><a href="#语言是否合法（20）" class="headerlink" title="语言是否合法（20）"></a>语言是否合法（20）</h5><p>某种语言，语句xxx 后要end xxx。给定一些输入 问是否合法 （Yes/No）<br>e.g.</p><ul><li>if</li><li>end if</li><li>while</li><li>if</li><li>end if</li><li>end while</li></ul><p>（一次输入可能进行多次测试）<br>0.45</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">string <span class="title">my_substr</span><span class="params">(string&amp; str,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        res += str[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// num次判断</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; num;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">loop:    <span class="keyword">while</span>(num--) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">        cin &gt;&gt; m;</span><br><span class="line">        vector&lt;string&gt; str;</span><br><span class="line">        <span class="keyword">if</span> (m % <span class="number">2</span>) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输入</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            string temp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            cin &gt;&gt; temp;</span><br><span class="line">            <span class="keyword">while</span>(temp == <span class="string">&quot;end&quot;</span>) &#123;</span><br><span class="line">                temp = <span class="string">&quot;end &quot;</span>;</span><br><span class="line">                string buffer;</span><br><span class="line">                cin &gt;&gt; buffer;</span><br><span class="line">                temp += buffer;</span><br><span class="line">            &#125;</span><br><span class="line">            str.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        stack&lt;string&gt; stk;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; ch : str) &#123;</span><br><span class="line">            <span class="comment">// 不能提子串 一定是开始</span></span><br><span class="line">            <span class="keyword">if</span>(ch.<span class="built_in">size</span>() &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                string temp = <span class="string">&quot;end &quot;</span> + ch;</span><br><span class="line">                stk.<span class="built_in">push</span>(temp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    string buffer = <span class="built_in">my_substr</span>(ch, <span class="number">3</span>);</span><br><span class="line">                    <span class="keyword">if</span>(buffer == <span class="string">&quot;end&quot;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(stk.<span class="built_in">empty</span>() || stk.<span class="built_in">top</span>()!=ch) &#123;</span><br><span class="line">                        res.<span class="built_in">push_back</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">                        <span class="keyword">goto</span> loop;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(stk.<span class="built_in">top</span>() == ch) &#123;</span><br><span class="line">                        stk.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    string temp = <span class="string">&quot;end &quot;</span> + ch;</span><br><span class="line">                    stk.<span class="built_in">push</span>(temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i !=res.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">            cout &lt;&lt; res[i] &lt;&lt; endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; res[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="中位数"><a href="#中位数" class="headerlink" title="中位数"></a>中位数</h5><p>给定一个数组，在数组中提取子串。要求</p><ol><li>相邻两个元素至少选一个</li><li>中位数最大</li></ol><blockquote><p>卡样例（0.18）：当该数组升序时。中位数的角标越大，值越大。小于n/2的部分取越少越好，大于n/2的部分取越多越好。故小于n/2部分隔一个一取，大于n/2部分全取(共3/4n个元素)中位数在这个数组的中间位置。即，5/8n = 1/4n（前半部分未取的）+3/8n（子串中点）</p></blockquote><h2 id="华为云计算软件开发"><a href="#华为云计算软件开发" class="headerlink" title="华为云计算软件开发"></a>华为云计算软件开发</h2><h3 id="笔试-22-4-20"><a href="#笔试-22-4-20" class="headerlink" title="笔试(22/4/20)"></a>笔试(22/4/20)</h3><p>$2h = 编程题 \times 3$</p><h4 id="得分情况（100）"><a href="#得分情况（100）" class="headerlink" title="得分情况（100）"></a>得分情况（100）</h4><p>一张100分试卷，判断$10\times 2$ +单选 $10\times 4$ + 多选 $5\times 8$。从前往后做，错三个离场。<br>给定一个分值，问有多少种情况</p><h4 id="二叉树插入（200）"><a href="#二叉树插入（200）" class="headerlink" title="二叉树插入（200）"></a>二叉树插入（200）</h4><p>第一行以$\left[1,2,3,4,5\right]$形式给出值，构造一颗二叉树。（原树）<br>第二行以<code>\1\2\5</code>给出从根节点递归找二叉树的节点“5”。（指定节点）<br>第三行同样以第一行的形式给出另外一根二叉树。（插入树）<br>将插入树插在原树的指定节点。<br>（结束后写的 能过多少样例不清楚）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 数据结构定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="keyword">int</span> val) : <span class="built_in">val</span>(val), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="keyword">int</span> val, TreeNode *left, TreeNode *right) : <span class="built_in">val</span>(val), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 建树</span></span><br><span class="line"><span class="function">TreeNode *<span class="title">CreateTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= nums.<span class="built_in">size</span>() || nums[index] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode *node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[index]);</span><br><span class="line">    node-&gt;left = <span class="built_in">CreateTree</span>(nums, <span class="number">2</span> * index + <span class="number">1</span>);</span><br><span class="line">    node-&gt;right = <span class="built_in">CreateTree</span>(nums, <span class="number">2</span> * index + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 释放</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteTree</span><span class="params">(TreeNode * root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DeleteTree</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">DeleteTree</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">delete</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 层序遍历</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">printTree</span><span class="params">(TreeNode * root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">    queue&lt;TreeNode *&gt; que;</span><br><span class="line">    que.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode *node = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        temp.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left) &#123;</span><br><span class="line">            que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;right) &#123;</span><br><span class="line">            que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 找节点</span></span><br><span class="line"><span class="function">TreeNode * <span class="title">findTree</span><span class="params">(TreeNode * root, vector&lt;<span class="keyword">int</span>&gt; target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 题目说 一定能找到 且唯一</span></span><br><span class="line">    <span class="comment">// 直接把新的树 替换其父节点的子节点  故返回父节点</span></span><br><span class="line">    <span class="keyword">while</span>(index &lt;target.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left-&gt;val == target[index]) &#123;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        ++index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    string str;</span><br><span class="line">    <span class="built_in">getline</span>(cin, str);</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="comment">// 题目给出节点的值为个位数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ch:str) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(ch - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode *root = <span class="built_in">CreateTree</span>(vec, <span class="number">0</span>);</span><br><span class="line">    str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    <span class="built_in">getline</span>(cin, str);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ch:str) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(ch - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode *in = <span class="built_in">findTree</span>(root, tmp);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="built_in">getline</span>(cin, str);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ch:str) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(ch - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode *node = <span class="built_in">CreateTree</span>(res, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入</span></span><br><span class="line">    <span class="keyword">if</span>(in-&gt;left-&gt;val == tmp.<span class="built_in">back</span>()) &#123;</span><br><span class="line">        in-&gt;left = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        in-&gt;right = node;</span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="built_in">clear</span>();</span><br><span class="line">    res = <span class="built_in">printTree</span>(root);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        cout &lt;&lt; res[i];</span><br><span class="line">        <span class="keyword">if</span>(i != res.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    <span class="built_in">DeleteTree</span>(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="权值路径数（300）"><a href="#权值路径数（300）" class="headerlink" title="权值路径数（300）"></a>权值路径数（300）</h4><p>给出一个二叉树及 经过每个节点消耗的能量，从一个节点到父、子节点需要消耗差值的能量。从任一节点开始到任一节点结束，能量恰好耗完。（原题描述挺复杂，简而言之就是这样子。）（比如从值为1的节点走向其值为5的父节点 共消耗$1 + 5 + |5 -1| = 10$）<br>第一行给出节点数<br>第二行给出每个节点的权<br>第三行给出每个节点所耗能量<br>第四行给出能量数。<br>问有多少种走法。</p><h3 id="一面（22-4-29"><a href="#一面（22-4-29" class="headerlink" title="一面（22/4/29)"></a>一面（22/4/29)</h3><p>面试时长30分钟左右，<mark>没有问</mark>任何八股。聊了会儿天，顺便问了问项目、课程、竞赛什么的（也和闲聊差不多）。然后甩了道算法题。面试体验感拉满（虽然第一次面）</p><h4 id="重排链表"><a href="#重排链表" class="headerlink" title="重排链表"></a>重排链表</h4><p>两个升序链表，将其合并为一个新的链表。要求：新链表的头部值不小于尾部节点值，去掉头尾节点后亦然。</p><blockquote><p>样例1<br>输入: l1=[1,2,4],l2=[1,3,5];<br>输出: [1,3,5,4,2,1];</p></blockquote><blockquote><p>样例2<br>输入：l1=[5,10,15],l2=[20,40];<br>输出：[10,20,40,15,5]</p></blockquote><p>补充：时间有限，不用实现链表以及<code>cin&amp;cout</code>.</p><blockquote><p>ps:第一次面试，发现有点水。本以为是kpi面，字码一半发现过了。</p></blockquote><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; a1 = &#123;<span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>&#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; a2 = &#123;<span class="number">20</span>,<span class="number">40</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> len1 = a1.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> len2 = a2.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">temp</span><span class="params">(len1 + len2, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; len1 &amp;&amp; j &lt; len2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a1[i] &lt; a2[j]) &#123;</span><br><span class="line">            temp[index++] = a1[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[index++]  = a2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; len1 || j &lt; len2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; len1) &#123;</span><br><span class="line">            temp[index++] = a1[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[index++] = a2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    j = len1 + len2 - <span class="number">1</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(len1 + len2, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; len1 + len2;) &#123;</span><br><span class="line">        res[j--] = temp[index++];</span><br><span class="line">        <span class="keyword">if</span>(index &lt; len1+len2) &#123;</span><br><span class="line">            res[i++] = temp[index++];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; a:res) &#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="美团后端"><a href="#美团后端" class="headerlink" title="美团后端"></a>美团后端</h2><h3 id="笔试-22-4-23"><a href="#笔试-22-4-23" class="headerlink" title="笔试(22/4/23)"></a>笔试(22/4/23)</h3><p>$2h = 5\times 编程题$</p><h4 id="考试座位（20）"><a href="#考试座位（20）" class="headerlink" title="考试座位（20）"></a>考试座位（20）</h4><p>第一行给出n个参加考试的人。<br>第二行给出这n个人分别使用的语言<code>C or J</code><br>每次交换相邻两个元素<br>问，最少多少次交换，保证无作弊（相邻两个人使用同一语言会作弊）。 不能避免 <code>返回 -1</code>。<br>0.64</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; num;</span><br><span class="line">    string str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    <span class="keyword">int</span> Cnum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> Jnum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ch : str) &#123;</span><br><span class="line">        ch == <span class="string">&#x27;C&#x27;</span> ? Cnum++ : Jnum++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(Cnum - Jnum) &gt; <span class="number">1</span>) </span><br><span class="line">        res = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> length = str.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(length &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(str[index]==str[<span class="number">0</span>]) &#123;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            res += (index - <span class="number">1</span>);</span><br><span class="line">            str.<span class="built_in">erase</span>(str.<span class="built_in">begin</span>() + index);</span><br><span class="line">            str.<span class="built_in">erase</span>(str.<span class="built_in">begin</span>());</span><br><span class="line">            length -= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="买卖股票的最佳时机（20）"><a href="#买卖股票的最佳时机（20）" class="headerlink" title="买卖股票的最佳时机（20）"></a>买卖股票的最佳时机（20）</h4><p>初始1000块，第一行给出n天，第二行给出n天股票的价格。持仓超一百万不能再买。<br>问，最后会有多少钱。</p><h4 id="带颜色的数字排序（20）"><a href="#带颜色的数字排序（20）" class="headerlink" title="带颜色的数字排序（20）"></a>带颜色的数字排序（20）</h4><p>给出一组数字及每个数字的颜色，每次可以交换相邻两个元素（不同色），问最终能否排好序</p><h4 id="画板染色（20）"><a href="#画板染色（20）" class="headerlink" title="画板染色（20）"></a>画板染色（20）</h4><p>给定$m\times n$大小的画板，每次染色$2\times 2$大小的方块。同一个方格的后一次染色会覆盖前一次染色。问最终能否出现给出的画板颜色状况。</p><h4 id="时间片轮转法（20）"><a href="#时间片轮转法（20）" class="headerlink" title="时间片轮转法（20）"></a>时间片轮转法（20）</h4><p>给出每个时间片大小 及输入行数<br>每一行有如下几个语句： <code>ADD x num</code>添加需要num时长且编号为x的进程、<code>类似于wait x</code>（原题中不是wait x）等待x秒,<code>select</code> （原题中也不是这个）查询现在在运行的进程（空闲即-1）。</p><h2 id="网易雷火游戏研发"><a href="#网易雷火游戏研发" class="headerlink" title="网易雷火游戏研发"></a>网易雷火游戏研发</h2><h3 id="笔试-22-4-23-1"><a href="#笔试-22-4-23-1" class="headerlink" title="笔试(22/4/23)"></a>笔试(22/4/23)</h3><p>$3h = 4\times 编程题$</p><h4 id="六宫格（10）"><a href="#六宫格（10）" class="headerlink" title="六宫格（10）"></a>六宫格（10）</h4><p>类似于数独，每次验证输入一个$6\times6$大小的矩阵，保证每行、列、$2\times3$大小的矩阵（只有六个）。验证是否符合规则。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">JudgeRow</span><span class="params">(vector&lt;string&gt; &amp;str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>;++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>;++j) &#123;</span><br><span class="line">            sum += str[i][j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum == <span class="number">21</span>) &#123;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">JudgeCol</span><span class="params">(vector&lt;string&gt; &amp;str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>;++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>;++j) &#123;</span><br><span class="line">            sum += str[j][i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum == <span class="number">21</span>) &#123;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">JudgeMatrix</span><span class="params">(vector&lt;string&gt; &amp;str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>;++i ) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>;j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            sum += str[<span class="number">2</span> * i][<span class="number">3</span> * j] - <span class="string">&#x27;0&#x27;</span> + str[<span class="number">2</span> * i][<span class="number">3</span> * j + <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span> + str[<span class="number">2</span> * i][<span class="number">3</span> * j + <span class="number">2</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            sum += str[<span class="number">2</span> * i + <span class="number">1</span>][<span class="number">3</span> * j] - <span class="string">&#x27;0&#x27;</span> + str[<span class="number">2</span> * i + <span class="number">1</span>][<span class="number">3</span> * j + <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span> + str[<span class="number">2</span> * i + <span class="number">1</span>][<span class="number">3</span> * j + <span class="number">2</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(sum == <span class="number">21</span>) &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Judge</span><span class="params">(vector&lt;string&gt; &amp;str)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断行</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">JudgeRow</span>(str) == <span class="number">6</span> &amp;&amp; <span class="built_in">JudgeCol</span>(str) == <span class="number">6</span> &amp;&amp; <span class="built_in">JudgeMatrix</span>(str) == <span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    string temp;</span><br><span class="line">    <span class="built_in">getline</span>(cin, temp);</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">str</span>(n, vector&lt;string&gt;(<span class="number">6</span>, <span class="string">&quot;&quot;</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; ++j) &#123;</span><br><span class="line">            temp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="built_in">getline</span>(cin, temp);</span><br><span class="line">            str[i][j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Judge</span>(str[i])) &#123;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="虚弱状态（25）"><a href="#虚弱状态（25）" class="headerlink" title="虚弱状态（25）"></a>虚弱状态（25）</h4><p>给定一个血量，虚弱状态的临界值（上、下临界）。以及n个技能的伤害。问至少几次攻击让小怪进入虚弱状态</p><h4 id="rpc（25）"><a href="#rpc（25）" class="headerlink" title="rpc（25）"></a>rpc（25）</h4><p>n行输入n个rpc函数。（以 <code>编号 函数名 参数类型</code>给出两两之间有空格） 参数类型包括<code>i</code>(int)和<code>s</code>(string)<br>最后一行给定16进制字符串，还原出调用函数的过程。<br>一个不太恰当的例子。</p><ul><li>比如<code>0 ADD ii</code><br>读取时，前两位对应标号，接下来每8位对应一个16进制表示的int(补码表示)。（s的读取没读懂）</li></ul><h4 id="模拟助手（40）"><a href="#模拟助手（40）" class="headerlink" title="模拟助手（40）"></a>模拟助手（40）</h4><p>给出m个问助手的查询语句，n个规则库。<br>问这m个语句分别匹配什么规则。（and优先级高于or）、（有歧义时，保留最长的）</p><h2 id="拼多多服务端"><a href="#拼多多服务端" class="headerlink" title="拼多多服务端"></a>拼多多服务端</h2><h3 id="笔试-22-4-29"><a href="#笔试-22-4-29" class="headerlink" title="笔试(22/4/29)"></a>笔试(22/4/29)</h3><p>$2h =4 \times 编程题$</p><h4 id="算法调度（25）"><a href="#算法调度（25）" class="headerlink" title="算法调度（25）"></a>算法调度（25）</h4><p>已知有n个算法，每个都要训练完再运行一次。每次只能训练一个算法，可以同时运行多个算法。<br>接下来n行每行给出两个数字，分别表示，第i个算法运行、训练耗时。<br>问，至少用多久运行完。</p><p>0.6（假定除训练外，运行时间只需最短的那个）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="comment">// temp1 运行 temp2训练</span></span><br><span class="line">    vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; <span class="built_in">temp</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; pr : temp) &#123;</span><br><span class="line">        cin &gt;&gt; pr.first;</span><br><span class="line">        cin &gt;&gt; pr.second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> val = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; pr:temp) &#123;</span><br><span class="line">        val = pr.first &gt; val ? val : pr.first;</span><br><span class="line">        res += pr.second;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res + val;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="差分数组值连续（25）"><a href="#差分数组值连续（25）" class="headerlink" title="差分数组值连续（25）"></a>差分数组值连续（25）</h4><p>给定含有n个元素的数组。<br>生成一个新的仅含有n-1个元素的数组。 生成规则 new[i] = abs(old[i] - old[i+1]);<br>问，新数组中的每个元素是否唯一且连续。 是，则输出YES+最大值+最小值。否，则输出NO+最多的元素出现了几次+范围内缺失元素个数。<br>样例1</p><blockquote><p>输入：4<br>[1,4,2,3]<br>解释：差分数组为[3,2,1]。连续包含1~3，且无重复。<br>输出：<br>YES<br>3 1</p></blockquote><p>样例2</p><blockquote><p>输入：4<br>[1,2,3,4]<br>解释:差分数组[1,1,1]。有重复元素。 出现次数最多元素出现3次。 区间1~1缺失0个元素<br>输出:<br>NO<br>3 0</p></blockquote><p>0.68</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">temp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; a:temp) &#123;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        temp[i] = <span class="built_in">abs</span>(temp[i] - temp[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    temp.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="built_in">sort</span>(temp.<span class="built_in">begin</span>(), temp.<span class="built_in">end</span>());</span><br><span class="line">    string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; my_map;</span><br><span class="line">    <span class="keyword">int</span> MaxSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        my_map[temp[i]] = i;</span><br><span class="line">        <span class="keyword">if</span>(temp[i] == temp[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i + <span class="number">1</span> &lt; n - <span class="number">1</span> &amp;&amp; temp[i] == temp[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        MaxSize = i - my_map[temp[i]] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 共有my_map.size()个不同的数字。角标差和数字个数相同，则无重复。</span></span><br><span class="line">    <span class="keyword">if</span> ((temp.<span class="built_in">back</span>() - temp[<span class="number">0</span>]) - my_map.<span class="built_in">size</span>() + <span class="number">1</span> == <span class="number">0</span> &amp;&amp; (temp.<span class="built_in">back</span>() - temp[<span class="number">0</span>]) == n - <span class="number">2</span>) &#123;</span><br><span class="line">        res = <span class="string">&quot;YES&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">            res = <span class="string">&quot;NO&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(res == <span class="string">&quot;YES&quot;</span>) &#123;</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; temp[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; temp.<span class="built_in">back</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; MaxSize &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (temp.<span class="built_in">back</span>() - temp[<span class="number">0</span>]) - my_map.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="回文子序列（25）"><a href="#回文子序列（25）" class="headerlink" title="回文子序列（25）"></a>回文子序列（25）</h4><p>每次输入验证T次。<br>每次给定m个字符串，在其中提取子串，如果有回文子串，则输出YES，没有则输出NO。<br>代码未考虑的情况 {“ab”,”ab”,”a”}中，提取”ab” +”ab”+”a” = “ababa”子串也是回文。<br>代码只考虑了自身 + 含有镜像。<br>0.6</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//     仅考虑本身是回文 未考虑多个连接后 (&quot;ab&quot; +&quot;a&quot;)形式.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">        cin &gt;&gt; m;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">str1</span><span class="params">(m, <span class="string">&quot;&quot;</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">str2</span><span class="params">(m, <span class="string">&quot;&quot;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            cin &gt;&gt; str1[i];</span><br><span class="line"></span><br><span class="line">            str2[i] = str1[i];</span><br><span class="line">            <span class="built_in">reverse</span>(str2[i].<span class="built_in">begin</span>(), str2[i].<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (str1[i] == str2[j]) &#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="最少花费（25）"><a href="#最少花费（25）" class="headerlink" title="最少花费（25）"></a>最少花费（25）</h4><p>给定n个树木的高度及砍掉所花费的体力。<br>问，至少花费多少体力，使得高度最高的树木占数量的一半<mark>以上</mark>。</p><h2 id="10-奇安信c-c-软件开发"><a href="#10-奇安信c-c-软件开发" class="headerlink" title="10. 奇安信c/c++软件开发"></a>10. 奇安信c/c++软件开发</h2><h3 id="笔试-22-5-8"><a href="#笔试-22-5-8" class="headerlink" title="笔试(22/5/8)"></a>笔试(22/5/8)</h3><p>$2h = 20 \times 单选 + 10\times 多选  + 2 \times 编程题$</p><h4 id="单选-20-2"><a href="#单选-20-2" class="headerlink" title="单选(20*2)"></a>单选(20*2)</h4><ul><li>sizeof(class)</li><li>dfs不适用条件（有环图、无环图、最短路径….）</li><li>linux文件权限10位分4段，第4段表示？</li><li>DDos</li><li>DHCPv6</li><li>vlan</li><li>大根堆</li><li>死锁</li><li>静态链接/动态链接优缺点</li><li>linux/c fork()功能</li><li>三维数组给定array[0][0][0]所在位置，求某一位置所在位置。</li><li>数据库 分区域适用的关键字（Group by）</li><li>多线程，共享进行的xx资源？</li><li>链式栈与顺序栈的优缺点？</li><li>数组指针定义</li><li>strcpy、memset、strncpy等函数哪个用来初始化更安全</li><li>shell  <code>-o</code>的含义</li><li>数据库 索引设置原则</li></ul><h4 id="多选-10-2"><a href="#多选-10-2" class="headerlink" title="多选(10*2)"></a>多选(10*2)</h4><ul><li>数据库索引设置原则</li><li>常指针</li><li>IPSec安全特性</li><li>程序运行设置优先级的指令</li><li>cron后台常驻功能</li><li>static作用</li><li>IS-IS</li><li>linux 所有用户的变量存在哪里</li><li>运行一个shell脚本所需要的权限</li></ul><h4 id="编程题-2-20"><a href="#编程题-2-20" class="headerlink" title="编程题(2*20)"></a>编程题(2*20)</h4><h5 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h5><p>给定一个二叉树，除了根节点有两个子树外，其余各节点最多只有一个子树（或0）。从中选取部分节点，要求父子不能同时选，问选中节点和的最大值。<br>（后续发现，将根节点左子树后续遍历+根节点值+根节点的右子树先序遍历可以展成一个数组，即<a href="https://leetcode-cn.com/problems/house-robber/">打家劫舍</a>。）<br>（后续又发现，这个题目是<a href="https://leetcode.cn/problems/house-robber-iii/description/">打家劫舍3</a>）<br>0.6 相邻节点必取一个，未考虑连续两个不取的情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *int val;</span></span><br><span class="line"><span class="comment"> *struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> *TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> res1;</span><br><span class="line">    <span class="keyword">int</span> res2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 帮助夏娃挑选苹果</span></span><br><span class="line"><span class="comment">     * @param tree TreeNode类 苹果树</span></span><br><span class="line"><span class="comment">     * @return int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(depth%<span class="number">2</span>) &#123;</span><br><span class="line">            res1+=root-&gt;val;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res2+=root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left,depth+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right,depth+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">eating</span><span class="params">(TreeNode* tree)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        res1=<span class="number">0</span>;</span><br><span class="line">        res2=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(tree,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(res1,res2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="棋盘连线"><a href="#棋盘连线" class="headerlink" title="棋盘连线"></a>棋盘连线</h5><p>给定一个二维数组，array.size()表示棋子的个数（<code>array.size() &gt; 3</code>），<code>array[i][0],array[i][1]</code>表示棋子所在棋盘中的位置。<br>注：棋子放在棋盘的线上（类似于中国象棋、五子棋那种）。<br>问，划一笔（可以转弯）连上3个棋子，需要走格子数的最小值。<br>样例</p><blockquote><p>输入：[[0,0],[1,1],[0,2],[10,10]]<br>输出：4<br>解释: (0,0)–&gt;(0,1)–&gt;(0,2)–&gt;(1,2)–&gt;(1,1) 走四个格子。（走法不唯一）</p></blockquote><p>编译失败/内存超限</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    map&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;, <span class="keyword">int</span> &gt; umap;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 得到短珠串的长度。【连三颗即成串，不必把所有珠子连起来】</span></span><br><span class="line"><span class="comment">     * @param pearls int整型vector&lt;vector&lt;&gt;&gt; n*2的二维数组，珠子的坐标，坐标值都为非负整数</span></span><br><span class="line"><span class="comment">     * @return int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>&amp; num,<span class="keyword">int</span> length,<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">3</span>) &#123;</span><br><span class="line">            res = <span class="built_in">min</span>(length,res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> ||x &gt;m || y &gt;n) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(umap[&#123;x,y&#125;]) &#123;</span><br><span class="line">            umap[&#123;x,y&#125;]--;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(num,length+<span class="number">1</span>,x+<span class="number">1</span>,y);</span><br><span class="line">        <span class="built_in">dfs</span>(num,length+<span class="number">1</span>,x<span class="number">-1</span>,y);</span><br><span class="line">        <span class="built_in">dfs</span>(num,length+<span class="number">1</span>,x,y+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(num,length+<span class="number">1</span>,x,y<span class="number">-1</span>);</span><br><span class="line">        umap[&#123;x,y&#125;]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMinLength</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt;&amp; pearls)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        m = <span class="number">0</span>;</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; pearl:pearls) &#123;</span><br><span class="line">            umap[<span class="built_in">pair</span>(pearl[<span class="number">0</span>],pearl[<span class="number">1</span>])]++;</span><br><span class="line">            m = <span class="built_in">max</span>(m,pearl[<span class="number">0</span>]);</span><br><span class="line">            n = <span class="built_in">max</span>(n,pearl[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        res = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; pearl:pearls) &#123;</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(num,val,pearl[<span class="number">0</span>],pearl[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="一面-22-5-12"><a href="#一面-22-5-12" class="headerlink" title="一面(22/5/12)"></a>一面(22/5/12)</h3><p>30分钟，无算法题</p><ul><li>自我介绍</li><li>线程/进程/协程</li><li>进程线程区别/联系</li><li>多线程</li><li>进程通信方式</li><li>三次握手</li><li>socket连接过程</li><li>管道原理</li><li>I/O多路复用</li><li>堆栈区别</li><li>什么会导致栈溢出</li><li>大根堆/小根堆</li><li>linux内存占用过大怎么办</li><li>数据库为什么用B+树</li><li>项目实现过程</li><li>了解哪些排序算法，快排、桶排序原理及时间复杂度。</li><li>TCP、UDP区别，对应应用层协议</li><li>三次握手</li><li>学习中最大挑战</li><li>项目遇到的困难</li><li>最近在学什么</li><li>网络安全了解哪些</li><li>nmap扫描端口原理</li><li>反问</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 笔面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B树</title>
      <link href="/2022/03/06/B%E6%A0%91/"/>
      <url>/2022/03/06/B%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>AVL 树 和红黑树，都假设所有的数据放在主存当中。而当数据量达到亿级，主存当中根本存储不下，我们只能以块的形式从磁盘读取数据，与主存的访问时间相比，磁盘的 I/O 操作相当耗时，而提出 B-树的主要目的就是减少磁盘的 I/O 操作。</p><span id="more"></span><p> B树的一个节点$x$如果包含$n$个$key$，则其有$n+1$个孩子。（$n$个key将其余数据划分为$n+1$个区间，每个孩子介于相应的区间中）</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>B树所具有的的性质人如下:</p><ol><li>每个节点$x$应具有如下属性：<ol><li>$x.n$即，存储在$x$节点的$key$个数</li><li>节点$x$的n个key以<strong style="color:red;">非降序</strong>排列。$x.key_1 \le x.key_2 \le \cdots \le x.key_{x.n}$</li><li>$ x.leaf$，布尔值。用来表示x是(true)否(false)为叶子节点</li></ol></li><li>每个<strong style="color:red;">非叶子节点</strong>还包括$x.n + 1$个指向其孩子的指针:$x.c_1,x.c_2,x.c_3\cdots,x.c_{x.n +1}$。<mark>叶子节点没有该定义</mark>。</li><li>$x.key_i$对其子节点进行分割。假设$k_i$为其子节点的$key$值。则有 </li></ol><p>$$<br>k_1 \le x.key_1 \le k_2 \le x.key_2 \le \cdots \le x.key_{x.n} \le k_{x.n +1}<br>$$<br>4. 所有的<strong style="color:red;">叶子节点深度相同</strong><br>5. B树的<strong>最小度数</strong>$t \ge 2$以限制每个节点所包含$key$值的个数(上下限)。<br>    1. 除根节点外，每个节点必须<strong>至少</strong>有$t-1$个$key$。（除叶子节点外，每个节点至少有$t$个孩子）<br>    2. 每个节点至多有$2t-1$个key。（除叶子节点外，每个节点至多有$2t$个孩子）当B树恰好拥有$2t-1$个$key$时，称该节点为满的。（结合性质5.1即B树要求半满）</p><p>一个B树的样例如下：<br><img src="/2022/03/06/B%E6%A0%91/BTreeExp.png" alt="B树样例"><br>一个较为简单的B树定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BTreeNode</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">int</span> *keys; <span class="comment">// 存储key值</span></span><br><span class="line">    <span class="keyword">int</span> t;  <span class="comment">// 最小度 </span></span><br><span class="line">    BTreeNode **C; <span class="comment">// 子节点</span></span><br><span class="line">    <span class="keyword">int</span> n;  <span class="comment">// key的个数</span></span><br><span class="line">    <span class="keyword">bool</span> leaf; <span class="comment">// 是否为叶子节点</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p><strong>B树的高度</strong><br>B树大部分操作的磁盘存取次数与B树的高度成正比。对于任意一个包含$n$个$key$,高度为$h$,最小度为$t$的B树，有</p><p>$$<br>    h \le \log_{t}{\frac{n+1}{2} }<br>$$</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>在此假定：B树始终在主存中，无需读取磁盘。</p><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>B树的搜索，不过是在二叉搜索树的基础上，每个节点有多个$key$值。<br>以上述的样例图中查找33为例。</p><ol><li>首先，访问根节点。先和第一个$key$值20比较，发现 $37&gt;20$。然后与第二个$key$值40比较，此时$37&lt;40$。于是递归到20与40之间的子节点去查找。<br><img src="/2022/03/06/B%E6%A0%91/BTreeSearch1.png" alt="B树搜索样例1_1"></li><li>接着，访问$\left[24,35\right]$节点。先和第一个$key$ 24比较，发现$37&gt;24$。然后与第二个$key$ 35比较,发现$37 &gt; 35$。访问该节点的最后一个子节点。<br><img src="/2022/03/06/B%E6%A0%91/BTreeSearch2.png" alt="B树搜索样例1_2"></li><li>最后在叶子节点$\left[ 37,39\right]$中，查找到37,结束。<br><img src="/2022/03/06/B%E6%A0%91/BTreeSearch3.png" alt="B树查找样例1_3"><br>相关过程代码如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BTreeNode *<span class="title">BTreeNode::search</span><span class="params">(<span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> <span class="comment">// 找到第一个大于待查找k 的key值</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span> (i &lt; n &amp;&amp; k &gt; keys[i]) &#123;</span><br><span class="line">    i++; </span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">// 相等即找到 </span></span><br><span class="line"> <span class="keyword">if</span> (keys[i] == k) </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>; </span><br><span class="line"></span><br><span class="line"> <span class="comment">// 如果没有找到，且当前结点为叶子结点则无解</span></span><br><span class="line"> <span class="keyword">if</span> (leaf == <span class="literal">true</span>) </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>; </span><br><span class="line"></span><br><span class="line"> <span class="comment">// 递归访问恰当的子代</span></span><br><span class="line"> <span class="keyword">return</span> C[i]-&gt;<span class="built_in">search</span>(k); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>插入、删除。过于复杂，先略了，有空再写。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构&amp;算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/2022/01/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2022/01/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<p>虽然，Carl的<a href="https://programmercarl.com/">《代码随想录》</a>和labuladong的<a href="https://labuladong.gitee.io/algo/">《算法小抄》</a>对“动态规划”类问题有着详尽且优质的解答，但仍然想在这里简单啰嗦一下<strong>动态规划</strong>。在这里，并不想以《算法导论》中较为晦涩且难懂的<code>「矩阵连乘」</code>、<code>「最优二叉搜索树」</code>等为样例进行讲解。</p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>动态规划，英文名：Dynamic Programming，简称DP。其算法的基本思想是：将待求解的问题<strong>分解成若干个子问题</strong>，先求解子问题，再<strong>由子问题的解得到原问题的解</strong>。换句话说，将一个复杂的问题，分解为多个相互联系的较为简单的子问题，对每个子问题进行求解，复杂问题的答案蕴含在子问题中（<strong>具备「最优子结构」</strong>）。</p><span id="more"></span><p>通常，可以用动态规划求解的问题也可以用<strong style="color:red;">穷举</strong>来解决问题。但在穷举的过程中会<strong>存在「重叠子问题」</strong>。即，在暴力穷举求解时，一些中间值会进行多次的重复计算，严重影响效率。以斐波那契数列为例:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fib</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">2</span>) ? n: <span class="built_in">Fib</span>(n - <span class="number">1</span>) + <span class="built_in">Fib</span>(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归树如下:</p><p><img src="/2022/01/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/DPFib.png" alt="斐波那契数列"></p><center>随着递归的进行，$Fib(n)\quad n \in \left[ 2,18\right]$均计算了多次</center><p>我们知道，这些进行<strong style="color:red;">重复计算的值</strong>如果<strong style="color:red;">只计算一次</strong>的话，求解问题的<strong style="color:red;">效率</strong>会有一定的<strong style="color:red;">提高</strong>。</p><p>为解决该问题，引入了「备忘录方法」。即，其在<strong style="color:red;">自顶向下</strong>递归过程中<strong style="color:#e67c86;">用一个表来保存已解决问题的答案</strong>，在求解时先查表，表中有的直接用，没有的再递归。上述斐波那契数列在每次递归求解$Fib(n-1)+Fib(n-2)$时，$Fib(n-2)$的值在求解$Fib(n-1)$时已经求过，直接从表中引用。</p><p>我们发现，在利用「备忘录方法」进行求解时，我们是每求解一个问题记录一次，当<strong>并非所有子问题都需要求解时</strong>，「备忘录方法」可以严格的只求解需要的问题，而当所有子问题都需要求解一次或多次时，考虑使用动态规划。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N &lt;= <span class="number">1</span>) <span class="keyword">return</span> N;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(N + <span class="number">1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基本要素"><a href="#基本要素" class="headerlink" title="基本要素"></a>基本要素</h1><p>动态规划三个基本要素分别为：最优子结构、重叠子问题、状态转移方程。</p><ol><li>最优子结构：当<strong>问题的最优解包含了其子问题的最优解</strong>时，称该问题具有最优子结构性质。分析最优子结构性质时，一般假设由问题的最优解导出的子问题不是最优的，然后再设法说明在这个假设下可以构造出一个比原问题更优解更好的解，从而导出矛盾。</li><li>重叠子问题：在用递归算法自顶向下解此问题时，每次产生的子问题并不总是新问题，<strong>有些子问题被反复计算多次</strong>。动态规划算法对每个问题只解一次，而后将其解保存在一个表格中，当再次需要解此问题时，用常数时间查看一下结果。因此，用动态规划算法通常只需要多项式时间。</li><li>状态转移方程：动态规划中，一个状态向另一个状态转变时的规则。实际的算法问题中，列出状态转移方程往往较为困难。在列相应的状态转移方程时，我们需要注意：确定状态数组<code>dp</code>中角标的含义、初始化时已确定的状态及递归公式。</li></ol><h1 id="求解步骤"><a href="#求解步骤" class="headerlink" title="求解步骤"></a>求解步骤</h1><ol><li>找出最优解的性质，并刻划最优解的结构特征。</li><li> 递归地定义最优值。</li><li> 以自底向上的方式计算出最优值。</li><li> 根据计算最优值时得到的信息，构造最优解。</li></ol><h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><p>首先，<strong style="color:red;">动态规划和分治法</strong>都是分解成子问题，由子问题的解得到原问题的解。但需要将二者进行区分：动态规划中除了有诸多的重叠子问题外，各子问题之间还存在着一定的关联(通过状态转移方程递推其他状态)。而分治法中，各子问题相对独立。</p><p>再者，<strong style="color:red;">贪心算法和动态规划</strong>也同样的都需要分解子问题来求解。二者所不同的是：<strong style="color:#9b2ebd;">动态规划</strong>在求解问题时需要<strong style="color:#9b2ebd;">遍历所有的可能</strong>情况。而<strong style="color:rgb(0, 191, 166);">贪心算法</strong>在每个子问题求解时<strong style="color:rgb(0, 191, 166);">只考虑局部最优解</strong>的情况。语言介绍较为苍白无力，接下来用<strong style="color:#e67c86;">「拼凑面额问题」</strong>来对比二者的区别。在此，我们将会引入一些面额的纸币以方便举例。</p><h2 id="能否凑出面额"><a href="#能否凑出面额" class="headerlink" title="能否凑出面额"></a>能否凑出面额</h2><p>假设，我们去商店买东西。已知，口袋里有如下几种面额的纸币各<strong>一张</strong>：<code>1</code>,<code>2</code>,<code>5</code>,<code>10</code>,<code>13</code>，我们需要支付的金额为<code>17</code>。而由于种种原因，商店并没有零钱。即，我们需要用上述五个数字中的部分进行加和，让值恰好为17。</p><ul><li><strong style="color:#c04851;">贪心算法</strong><ol><li>首先拿出面值为<code>13</code>的纸币。由于<code>13&lt;17</code>，面值<code>13</code>的纸币<strong>一定要使用</strong>。接下来，我们需要用<code>1</code>,<code>2</code>,<code>5</code>,<code>10</code>四张纸币支付<code>4</code>。</li><li>面值为<code>10</code>的纸币超过了要支付的金额，不予使用。</li><li>面值为<code>5</code>的纸币超过了要支付的金额，不予使用。</li><li>由于<code>2 &lt; 4</code>，面值为<code>2</code>的纸币也一定使用。</li><li>最后，剩下一张面值为<code>1</code>的纸币，不足以支付剩余的金额<code>2</code>。则贪心算法的结果是不能支付。</li></ol></li><li><strong>动态规划</strong><ol><li>我们假设在此按照自顶向下(最大面值开始)求解该问题时，同样的也会经历上述步骤。但，上述步骤执行完时并不直接返回<code>false</code>，而是继续考虑。</li><li>这一次，我们将考虑不需要面值为<code>13</code>的纸币。而是使用面值为<code>10</code>的纸币。这一次，我们需要利用剩下的面值为<code>1</code>,<code>2</code>,<code>5</code>面值的纸币凑出<code>7</code>。</li><li>由于<code>5 &lt; 7</code>，使用面值为<code>5</code>的纸币，我们需要利用剩下的面值为<code>1</code>和<code>2</code>的纸币凑够金额2。显然这是可以的。因此利用动态规划得到的结果是可以支付。</li></ol></li></ul><h2 id="最少纸币数量"><a href="#最少纸币数量" class="headerlink" title="最少纸币数量"></a>最少纸币数量</h2><p>这一次，我们有面值为<code>2</code>,<code>8</code>,<code>10</code>的纸币，假设每种纸币的数量<strong>足够多</strong>。我们需要做的是拼凑出金额<code>16</code>。我们所做的是怎么用较少的纸币数量拼凑出相应的金额。</p><ul><li><strong>贪心算法</strong><ol><li>首先，我们拿出面值为<code>10</code>的纸币，一张即可（<code>10 &lt; 16 &lt; 2 * 10</code>）。接下来，需要利用面值为<code>2</code>和<code>8</code>的纸币凑够金额<code>6</code></li><li>面值为<code>8</code>的纸币超过了要支付的金额，不予使用。</li><li><code>3 * 2 = 6</code>。故需要4张纸币。</li></ol></li><li><strong>动态规划</strong><ul><li>在上述基础上，动态规划还会去考虑不使用面值为<code>10</code>时候的其他情况，分别<code>2 * 8</code>，<code>8 + 4 * 2</code>，<code>8 * 2</code>三种方案，最终确定为使用2张面值<code>8</code>的纸币所用纸币数量最少。</li></ul></li></ul><p>最后，需要声明的是，以上样例中动态规划的解法是为方便理解，效率上有着改进的空间。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构&amp;算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红黑树</title>
      <link href="/2022/01/05/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
      <url>/2022/01/05/%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>由于二叉搜索树很不平衡，很容易退化为一条类似链表的结构，从而造成时间复杂度从$O(lgN)$降低为$O(N)$。</p><p>为解决这一问题，引入了<strong>“平衡”二叉搜索树</strong>，红黑树就是其中的一种。红黑树在树的基础上，为每个节点增加了一个<strong>颜色位</strong>，可以是<code>RED</code>，也可以是<code>BLACK</code>。通过对每条路径的颜色进行约束，保证红黑树处于<strong style="color:#e67c86;">近似平衡</strong>的状态，从而保证了查找最坏情况为$O(lgN)$。</p><span id="more"></span><h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p>红黑树除了本身是<strong style="color:rgb(0, 191, 166);">二叉搜索树</strong>外，还满足以下条件：</p><ol><li>每个节点<strong style="color:red;">要么是红色</strong>的，<strong style="color:red;">要么是黑色</strong>的。</li><li><strong style="color:red;">根节点</strong>是<strong style="color:red;">黑色</strong>的。</li><li>每个空节点(<strong style="color:red;">NIL</strong>)都是<strong style="color:red;">黑色</strong>的。</li><li><strong style="color:red;">红色节点</strong>的两个<strong style="color:red;">子节点</strong>都是<strong style="color:red;">黑色</strong>的。</li><li><strong style="color:red;">每个节点</strong><strong>到</strong>其后代<strong style="color:red;">叶子节点</strong>的路径上包含的<strong style="color:red;">黑色节点数目相同</strong>。</li></ol><p>红黑树的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">RBTColor</span>&#123;</span>RED, BLACK&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RBTNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    T key;</span><br><span class="line">        RBTColor color;</span><br><span class="line">        RBTNode *left;</span><br><span class="line">        RBTNode *right;</span><br><span class="line">        RBTNode *parent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>样例如图：</p><p><img src="/2022/01/05/%E7%BA%A2%E9%BB%91%E6%A0%91/RedBlackTree.png" alt="红黑树样例"></p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>由于结点的插入、删除操作对树进行了修改。修改后的红黑树可能<strong style="color:red;">不再满足</strong>上面所列出的<strong style="color:red;">红黑性质</strong>，故需要对树的某些结点进行<strong style="color:pink;">旋转</strong>或<strong style="color:pink;">变色</strong>使其自平衡。</p><p>忽略红黑特性，以一个二叉搜索树为例进行演示旋转。样例如下：</p><p><img src="/2022/01/05/%E7%BA%A2%E9%BB%91%E6%A0%91/RBTreeRotate.png" alt="红黑树旋转"></p><p>图中<code>x y</code>是两个节点，<code>a b c</code>表示任意子树。</p><p>不难看出，图中的旋转仍然保持了二叉搜索树的性质：a子树所有节点的key值小于<code>x.key</code>;c子树所有节点的key值大于<code>y.key</code>;b子树key值介于<code>x.key</code>与<code>y.key</code>之间。伪代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左旋</span></span><br><span class="line">LEFT-<span class="built_in">ROTATE</span>(T, x)</span><br><span class="line">y = x.right</span><br><span class="line">x.right = y.left<span class="comment">//上图中，b子树的移动</span></span><br><span class="line"><span class="keyword">if</span> y.left != <span class="literal">nullptr</span></span><br><span class="line">    y.left.parent = x<span class="comment">//过继过去的b子树父节点改变</span></span><br><span class="line">y.parent = x.parent</span><br><span class="line">    <span class="comment">//改变x的父节点的指向</span></span><br><span class="line"><span class="keyword">if</span> x.parent == <span class="literal">nullptr</span></span><br><span class="line">    T.root = y<span class="comment">//x父节点为空，证明x为根节点 即左旋后的y节点变为根节点</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> x == x.parent.left</span><br><span class="line">    x.parent.left = x</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    x.parent.right = y</span><br><span class="line">y.left = x<span class="comment">//将x链接在y的左侧</span></span><br><span class="line">x.parent = y</span><br><span class="line"></span><br><span class="line"><span class="comment">//右旋</span></span><br><span class="line">RIGHT-<span class="built_in">ROTATE</span>(T, y)</span><br><span class="line">x = y.left</span><br><span class="line">y.left = x.right</span><br><span class="line"><span class="keyword">if</span> x.right != <span class="literal">nullptr</span></span><br><span class="line">    x.right.parent = y</span><br><span class="line">x.parent = y.parent</span><br><span class="line"><span class="keyword">if</span> y.parent == <span class="literal">nullptr</span></span><br><span class="line">    T.root = x</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> y == y.parent.left</span><br><span class="line">    y.parent.left = x</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    y.parent.right = x</span><br><span class="line">x.right = y</span><br><span class="line">y.parent = x</span><br></pre></td></tr></table></figure><p>旋转操作只改变所旋转元素附近的指针，其他属性均未改变。可以在常数时间$O(1)$内完成。</p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>由于红黑树对黑色节点的要求较为苛刻，新插入的节点<strong>默认为红色</strong>。</p><p>将某个节点插入到红黑树，详细过程如下：</p><ol><li>首先，红黑树本身是一个<strong>二叉搜索树</strong>，依据其性质可以找到相应的插入位置，保证节点<strong>插入后</strong>key仍<strong>有序</strong>。</li><li>插入后，进行一系列的<strong style="color:red;">旋转</strong>、<strong style="color:red;">着色</strong>使其继续<strong style="color:red;">保持红黑特性</strong>。</li></ol><p>正常情况下(排除红黑树从0开始构建的情况)，当我们插入一个节点后如果违反了红黑树的红黑特性，那么所违反的应该为特性4(红节点的两个子节点均为黑色)。我们需要<strong>从当前节点向根节点</strong>逐层向上判断是否调整并作出相应的<strong>调整</strong>。相关调整方案如下：</p><p><img src="/2022/01/05/%E7%BA%A2%E9%BB%91%E6%A0%91/RBTreeInsert.png" alt="RBTreeInsert"></p><p>最后，<strong style="color:red;">根节点</strong>恒<strong style="color:red;">染为黑色</strong>。</p><p>下面给出一个范例，显示一个红黑树上的调整操作。</p><p><img src="/2022/01/05/%E7%BA%A2%E9%BB%91%E6%A0%91/RBTreeInsertExp.png" alt="RBTreeInsertExp"></p><p>在上图中，初始状态<code>x</code>为插入的节点，其父节点(<code>key = 5</code>)违背红黑规则4，需要进行调整：</p><ol><li>由于<code>x</code>的父节点和叔节点都是红色（调整方案1.2），调整时需要将其父节点(<code>key = 5</code>)和叔节点(<code>key = 8</code>)染成黑色，将其祖父节点(<code>key = 7</code>)染成红色，然后考虑其祖父节点。<code>x节点</code>上移为其祖父节点(<code>key = 7</code>)，此时<code>x节点</code>的父节点(<code>key = 2</code>)违背红黑规则4</li><li>叔节点不为红色，调整策略对应为1.1。观察到<strong style="color:pink;">父节点是祖父节点的左子树，自己是父节点的右节点</strong>(1.1.1.1)。当前节点上移为其父节点(<code>key = 2</code>)然后左旋。左旋后的<code>x节点</code>执行调整方案1.1.1.2</li><li>父节点(<code>key = 7</code>)染成黑色，祖父节点(<code>key = 11</code>)染成红色，将祖父节点右旋。<code>x节点</code>的父节点(<code>key = 11</code>)不再是红色，退出循环。此时当前红黑树不再违背红黑规则。</li><li>循环退出后，将其<strong style="color:red;">根节点染成黑色</strong>。</li></ol><p>调整方案对应的伪代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> x.parent.color == RED<span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> x.parent == x.parent.parent.left</span><br><span class="line">        y = x.parent.parent.right<span class="comment">//叔节点</span></span><br><span class="line">        <span class="keyword">if</span> y.color == RED<span class="comment">//1.2</span></span><br><span class="line">            x.parent.color = BLACK</span><br><span class="line">            y.color = BLACK</span><br><span class="line">            x.parent.parent.color = RED</span><br><span class="line">            x = x.parent.parent</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span> x == x.parent.right<span class="comment">//1.1.1.1</span></span><br><span class="line">                <span class="comment">//父节点左旋并置为当前</span></span><br><span class="line">                x = x.parent</span><br><span class="line">                LEFT-<span class="built_in">ROTATE</span>(T, x)</span><br><span class="line">            <span class="comment">//1.1.1.2</span></span><br><span class="line">            x.parent.color = BLACK</span><br><span class="line">            x.parent.parent.color = RED</span><br><span class="line">            RIGHT-<span class="built_in">ROTATE</span>(T, x.parent.parent)</span><br><span class="line">    <span class="comment">//父节点为右</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        y = x.parent.parent.left</span><br><span class="line">        <span class="keyword">if</span> y.color == RED</span><br><span class="line">            x.parent.color = BLACK</span><br><span class="line">            y.color = BLACK</span><br><span class="line">            x.parent.parent.color = RED</span><br><span class="line">            x = x.parent.parent</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span> x == x.parent.left <span class="comment">//1.1.2.2</span></span><br><span class="line">                x = x.parent</span><br><span class="line">                RIGHT-<span class="built_in">ROTATE</span>(T, x)</span><br><span class="line">            <span class="comment">//1.1.2.1</span></span><br><span class="line">            x.parent.color = BLACK</span><br><span class="line">            x.parent.parent.color = RED</span><br><span class="line">            LEFT-<span class="built_in">ROTATE</span>(T, x.parent.parent)</span><br><span class="line">T.root.color = BLACK</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除和插入操作类似，也分为两个步骤：</p><ol><li>红黑树本身是一个<strong>二叉搜索树</strong>，根据其性质<strong style="color:red;">寻找到对应节点并删除</strong>掉。删除的情况如下<ul><li>若该节点是<strong style="color:red;">叶子节点</strong>，则<strong>直接删除</strong>。</li><li>若<strong style="color:red;">只有一个子树</strong>，则用子树<strong>替代当前节点</strong>。</li><li>若<strong style="color:red;">有两个子树</strong>，则用<strong>右子树的最小值</strong>(大于被删除元素的最小值)替代当前节点。</li></ul></li><li>通过旋转、着色等操作将红黑树修正，使之成为新的红黑树。</li></ol><p>根据所替代节点的相关信息来进行调整：</p><p><img src="/2022/01/05/%E7%BA%A2%E9%BB%91%E6%A0%91/RBTreeDelete.png" alt="RBTreeDelete"></p><p>同样的，在循环结束之后，将<strong style="color:red;">当前节点染成黑色</strong>。</p><p>下面给出几个具体样例进行分析：</p><ul><li><p>例一</p><p><img src="/2022/01/05/%E7%BA%A2%E9%BB%91%E6%A0%91/RBTreeDeleteExp1.png" alt="RBTreeDeleteExp1"></p><p>在该样例中，A<strong>节点为黑色</strong>，且是其<strong>父节点的左节点</strong>，<strong>兄弟节点D为红色</strong>，满足调整方案1.1.1。所做出的调整为将其父节点<code>B</code>染成红色，兄弟节点<code>D</code>染成黑色。然后将其父节点<code>B</code>进行左旋。此后均满足条件。</p></li><li><p>例二</p><p><img src="/2022/01/05/%E7%BA%A2%E9%BB%91%E6%A0%91/RBTreeDeleteExp2.png" alt="RBTreeDeleteExp2"></p><p>在该样例中，A<strong>节点为黑色</strong>，且是其<strong>父节点的左节点</strong>，<strong>兄弟节点D为黑色</strong>，两个<strong>侄子节点</strong><code>C</code>和<code>E</code><strong>均为黑色</strong>，满足调整方案1.1.2.1。调整时，将其兄弟结点<code>D</code>染成红色，<code>x</code>已上移为根节点<code>B</code>，循环结束。需要特别注意的是，此刻应再将节点<code>B</code>染成黑色。</p></li><li><p>例三</p><p><img src="/2022/01/05/%E7%BA%A2%E9%BB%91%E6%A0%91/RBTreeDeleteExp3.png" alt="RBTreeDeleteExp3"></p><p>在该样例中，A<strong>节点为黑色</strong>，且是其<strong>父节点的左节点</strong>，<strong>兄弟节点D为黑色</strong>，左侄子<code>C</code>为红色,右侄子<code>E</code>为黑色，满足调整方案1.1.2.2。调整时，将其左侄子<code>C</code>染成黑色，兄弟节点<code>D</code>染成红色，并将兄弟节点D右旋，然后再按照调整方案1.1.2.3进行调整，在此略过。</p></li><li><p>例四</p><p><img src="/2022/01/05/%E7%BA%A2%E9%BB%91%E6%A0%91/RBTreeDeleteExp4.png" alt="RBTreeDeleteExp4"></p><p>在该样例中，A<strong>节点为黑色</strong>，且是其<strong>父节点的左节点</strong>，<strong>兄弟节点D为黑色</strong>，右侄子<code>E</code>为红色，满足调整方案1.1.2.3。调整时，兄弟节点<code>D</code>颜色随父节点<code>B</code>，右侄子<code>E</code>和父节点<code>B</code>染成黑色，将父节点<code>B</code>左旋。</p></li></ul><p>调整方案对应伪代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> x != T.root <span class="keyword">and</span> x.color == BLACK</span><br><span class="line">    <span class="keyword">if</span> x == x.parent.left</span><br><span class="line">w = x.parent.right<span class="comment">//兄弟节点</span></span><br><span class="line">        <span class="keyword">if</span> w.color == RED<span class="comment">// 1.1.1</span></span><br><span class="line">            w.color = BLACK</span><br><span class="line">            x.parent.color = RED</span><br><span class="line">            LEFT-<span class="built_in">ROTATE</span>(T, x.parent)</span><br><span class="line">            w = x.parent.right</span><br><span class="line">        <span class="keyword">if</span> w.left.color == BLACK <span class="keyword">and</span> w.right.color == BLACK<span class="comment">//1.1.2.1</span></span><br><span class="line">            w.color = RED</span><br><span class="line">            x = x.parent</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span> w.right.color == BLACK<span class="comment">//1.1.2.2</span></span><br><span class="line">            w.left.color = BLACK</span><br><span class="line">                w.color = RED</span><br><span class="line">                RIGHT-<span class="built_in">ROTATE</span>(T, w)</span><br><span class="line">               w = x.parent.right</span><br><span class="line">            w.color = x.parent.color<span class="comment">//1.1.2.3</span></span><br><span class="line">            x.parent.color = BLACK</span><br><span class="line">            w.right.color = BLACK</span><br><span class="line">            LEFT-<span class="built_in">ROTATE</span>(T, x.parent)</span><br><span class="line">            x = T.root</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        w = x.parent.left</span><br><span class="line">        <span class="keyword">if</span> w.color == RED<span class="comment">//1.2.2</span></span><br><span class="line">            w.color = BLACK</span><br><span class="line">            x.parent.color = RED</span><br><span class="line">            RIGHT-<span class="built_in">ROTATE</span>(T, x.parent)</span><br><span class="line">            w = x.parent.left</span><br><span class="line">        <span class="keyword">if</span> w.right.color == BLACK <span class="keyword">and</span> w.left.color == BLACK<span class="comment">//1.2.1.1</span></span><br><span class="line">            w.color =RED</span><br><span class="line">            x = x.parent</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span> w.left.color == BLACK<span class="comment">//1.2.1.2</span></span><br><span class="line">                w.right.color = BLACK</span><br><span class="line">                w.color = RED</span><br><span class="line">                LEFT-<span class="built_in">ROTATE</span>(T, w)</span><br><span class="line">            w.color = x.parent.color<span class="comment">//1.2.1.3</span></span><br><span class="line">            x.parent.color = BLACK</span><br><span class="line">            w.left.color = BLACK</span><br><span class="line">   RIGHT-<span class="built_in">ROTATE</span>(T, x.parent)</span><br><span class="line">            x = T.root</span><br><span class="line">x.color = BLACK</span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>红黑树插入、删除节点的情况虽然复杂，但基本处于<strong>对称</strong>情况，且有一个模型通过拼凑其他模型来实现。本文中的伪代码、样例均选自《算法导论》，红黑树的图采用<a href="https://draw.io/">drawio</a>绘制。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构&amp;算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>左孩子右兄弟树</title>
      <link href="/2022/01/04/%E5%B7%A6%E5%AD%A9%E5%AD%90%E5%8F%B3%E5%85%84%E5%BC%9F%E6%A0%91/"/>
      <url>/2022/01/04/%E5%B7%A6%E5%AD%A9%E5%AD%90%E5%8F%B3%E5%85%84%E5%BC%9F%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>在二叉树的基础上，我们可以扩展出任意多个叉的树。即，多叉树。然而，此时又面临着另外一个问题：</p><ul><li>当孩子结点无限制时，我们并不知道<strong>预先要分配多少个属性</strong>，且当<strong>仅有少数元素拥有多个子节点</strong>时，将会造成大量的空间浪费。</li></ul><p>此时，提出了一种新的表示形式:</p><p>$left-child \quad right-sibling \quad representation$。</p><span id="more"></span><h1 id="左孩子右兄弟表示法"><a href="#左孩子右兄弟表示法" class="headerlink" title="左孩子右兄弟表示法"></a>左孩子右兄弟表示法</h1><p>对于任意一个结点T，其仅包含两个指针：</p><ol><li><code>T.left-child</code>，指向T结点的最左侧子节点。</li><li><code>T.right-sibling</code>，指向T右侧最邻近的兄弟结点。</li></ol><p>特别的，当二者不存在时，相应的指针皆为空，即<code>NIL</code>。该方法只需要$O(n)$空间来存储含$n$个结点的树。</p><p>由于其与二叉树的相似性，故又叫<code>树的二叉树表示法</code>。</p><p>在此，给出一个样例：</p><p><img src="/2022/01/04/%E5%B7%A6%E5%AD%A9%E5%AD%90%E5%8F%B3%E5%85%84%E5%BC%9F%E6%A0%91/LchildRsiblingTree.png" alt="LchildRsiblingTree"></p><p>该样例旨在为下述算法提供一个参考。</p><h1 id="相关算法"><a href="#相关算法" class="headerlink" title="相关算法"></a>相关算法</h1><h2 id="深度"><a href="#深度" class="headerlink" title="深度"></a>深度</h2><p>对于该种树而言，任意一个节点和其右节点的深度相同。也就意味着对于一个节点T，其高度为要么<strong>和右子树高度相同</strong>，要么<strong>比左子树低一层</strong>。从叶子节点向上递归，即可得出最大深度。即：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Height</span><span class="params">(Tree&amp; t)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(t == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Height</span>(t-&gt;left) + <span class="number">1</span> &gt; <span class="built_in">Height</span>(t-&gt;right) ? <span class="built_in">Height</span>(t-&gt;left) + <span class="number">1</span> : <span class="built_in">Height</span>(t-&gt;right);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="叶子节点数"><a href="#叶子节点数" class="headerlink" title="叶子节点数"></a>叶子节点数</h2><p>基于二叉树中的定义，<strong>叶子节点</strong>是没有子节点的节点。在该种表示方法中，即<strong>左指针为空</strong>的节点（某一层的最后一个叶子节点右子树也为空，故只看左指针就行）。对于一个节点的叶子节点数，即：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Count</span><span class="params">(Tree&amp; t)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(t == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(t-&gt;left == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Count</span>(t-&gt;left) + <span class="built_in">Count</span>(t-&gt;right); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><p>先序遍历，对于某个节点而言，其<strong>左指针</strong>为<strong>第一个子节点</strong>。向左指针递归即寻找孩子，回溯时输出右指针的兄弟。与二叉树的先序遍历完全一致。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Tree&amp; t)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(t == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">cout&lt;&lt;t-&gt;val&lt;&lt;<span class="string">&quot; &quot;</span>;<span class="comment">//输出值</span></span><br><span class="line">TreeNode* p = t-&gt;left;</span><br><span class="line"><span class="keyword">while</span>(p != <span class="literal">nullptr</span>)&#123;</span><br><span class="line"><span class="built_in">preOrder</span>(p);</span><br><span class="line">p = p-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>后序遍历过程中，对于一个节点，应该打印其左指针和全部右侧的节点后才打印该节点，即回溯时才打印当前节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(Tree&amp; t)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(t == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">TreeNode* p = t-&gt;left;</span><br><span class="line"><span class="keyword">while</span>(p != <span class="literal">nullptr</span>)&#123;</span><br><span class="line"><span class="built_in">PostOrder</span>(p); <span class="comment">//递归找“根”</span></span><br><span class="line">p = p-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;t-&gt;val&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>层序遍历，即类似于广度优先算法。对于一个节点，当打印左节点时，应将其右侧所有兄弟节点都打印再去下一层。打印其兄弟节点时，保留其左节点，即其子节点的兄弟。基于此，也可统计出每层的<strong>宽度</strong>。有注释的几行即为相应的宽度统计。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(Tree&amp; t)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(t == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">queue&lt;TreeNode*&gt; q;</span><br><span class="line">TreeNode* p;</span><br><span class="line">    <span class="keyword">int</span> max = INT_MIN; <span class="comment">//宽度</span></span><br><span class="line">q.<span class="built_in">push</span>(t);</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line"><span class="keyword">int</span> width = q.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; width;i ++)&#123;</span><br><span class="line">p = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">cout&lt;&lt;p-&gt;val&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">p = p-&gt;left;</span><br><span class="line"><span class="keyword">while</span>(p != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">q.<span class="built_in">push</span>(p);</span><br><span class="line">p = p-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        max = max &gt; width ? max: width;        <span class="comment">//一层遍历结束 统计宽度</span></span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> max;<span class="comment">//返回宽度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构&amp;算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
